/*******************************************************************************
*
* @Project     : WebFrap WGT WebFrap GUI Toolkit
* @author      : Dominik Bonsch <dominik.bonsch@webfrap.net>
* @date        :
* @copyright   : Webfrap Developer Network <contact@webfrap.net>
* @publisher   : S-DB Software-Engineering Dominik Bonsch
* @project     : Webfrap Web Frame Application
* @projectUrl  : http://webfrap.net
*
* Dual licenced, if you want to develop free Software you can use WebFrap
* with the conditions of GPLv3.
* If GPLv3 is nothing for you contact us: <contact@s-db.de>.
* Depeding on what you want to do we have some commercial licences
* from free of cost use to enterprise versions or conditions by negotiation.
*
* @licence free : (GNU GENERAL PUBLIC LICENSE 3.0) see: LICENCE/GPLv3.txt
*
* @licence com  : Commercial <contact@s-db.de>
*
* @version: @package_version@  Revision: @package_revision@
*
* Changes:
*
*******************************************************************************/


if ( !console ){
  // console log fix
  // sicher stellen, dass der IE keinen fehler bei console wirft
  var console = {
    log: function(){},
    debug: function(){},
    info: function(){},
    warn: function(){},
    error: function(){},
    time: function(){},
    timeEnd: function(){},
    trace: function(){},
    group: function(){},
    groupEnd: function(){},
    assert: function(){}
  };
}

// no need for ; here
(function(window,undefined){

  /**
   * Configuration Class
   * @return
   */
  function WgtConf(){
    
    this.windowTitle      = 'InnoSuite Desktop';
    
    this.fn               = WgtConf.prototype;
  
    //this.DEBUG = true;
    this.DEBUG = {
      WCM: {
        ACTION : false,
        UI : false,
        WIDGET : false
      },
      UI: false,
      REQUEST : true
    };
    
    this.WEB_ROOT         = 'http://127.0.0.1//WorkspaceWebFrap/WebFrap_Wgt/example/gw/../../';
    this.SERVER_ADDR      = 'http://127.0.0.1/';
    this.WEB_WGT          = 'http://127.0.0.1//WorkspaceWebFrap/WebFrap_Wgt/example/gw/../';
    this.WEB_ICONS        = 'http://127.0.0.1//WorkspaceWebFrap/WebFrap_Wgt/example/gw/../../icons/default/';
    this.WEB_THEME        = 'http://127.0.0.1//WorkspaceWebFrap/WebFrap_Wgt/example/gw/../../themes/default/';
    
    this.WEB_GW           = 'http://127.0.0.1//WorkspaceWebFrap/WebFrap_Wgt/example/gw/';
    this.HTTPS            = false;

    document.cookie = [
     'WEB_ROOT', '=',
     encodeURIComponent(this.WEB_ROOT),
     '; path=/',
     this.HTTPS ? '; secure' : ''
   ].join('');
    
    document.cookie = [
      'WEB_WGT', '=',
      encodeURIComponent(this.WEB_WGT),
      this.HTTPS ? '; secure' : ''
    ].join('');
    
    document.cookie = [
      'WEB_ICONS', '=',
      encodeURIComponent(this.WEB_ICONS),
      this.HTTPS ? '; secure' : ''
    ].join('');
    
    document.cookie = [
      'WEB_THEME', '=',
      encodeURIComponent(this.WEB_THEME),
      this.HTTPS ? '; secure' : ''
    ].join('');
    
    document.cookie = [
      'WEB_GW', '=',
      encodeURIComponent(this.WEB_GW),
      this.HTTPS ? '; secure' : ''
    ].join('');
  
    this.iconPath         = this.WEB_ICONS;
    this.imagePath        = this.WEB_THEME+'images/';
    
    var cpath = this.iconPath+'xsmall/control/';
    
    /*
    this.icon ={
      callendar    :cpath+'calendar.png',
      clock        :cpath+'clock.png',
      sortDesc     :cpath+'sort_up.png',
      sortAsc      :cpath+'sort_down.png',
      sortNone     :cpath+'sort_none.png',
      refresh      :cpath+'cancel.png',
      add          :cpath+'add.png',
      edit         :cpath+'edit.png',
      show         :cpath+'show.png',
      delete       :cpath+'delete.png',
      save         :cpath+'save.png',
      connect      :cpath+'connect.png',
      opened       :cpath+'opened.png',
      closed       :cpath+'closed.png'
    };
    */
    
    this.iconCallendar    = cpath+'calendar.png';
    this.iconClock        = cpath+'clock.png';
    this.iconSortDesc     = cpath+'sort_up.png';
    this.iconSortAsc      = cpath+'sort_down.png';
    this.iconSortNone     = cpath+'sort_none.png';
    this.iconRefresh      = cpath+'cancel.png';
    this.iconAdd          = cpath+'add.png';
    this.iconEdit         = cpath+'edit.png';
    this.iconShow         = cpath+'show.png';
    this.iconDelete       = cpath+'delete.png';
    this.iconSave         = cpath+'save.png';
    this.iconConnect      = cpath+'connect.png';
    this.iconClose        = cpath+'close.png';
    
    this.iconOpened       = cpath+'opened.png';
    this.iconClosed       = cpath+'closed.png';
  
    this.formatTime       = 'h:i';
    this.formatTimeSec    = 'h:i:s';
    this.timeSep          = ':';
    this.formatDate       = 'yy-mm-dd';
    this.formatDateMonth  = 'yy-mm';
    this.dateSep          = '-';
    this.theme            = 'default';
    this.lang             = 'en';
    
    /**
     * color codes for selectbox & status
     */
    this.colorCodes = {
        'access':{
          '0':'#C85E60',
          '1':'#D6EBBE',
          '2':'#B6DB8C',
          '4':'#99CD5D',
          '8':'#7ABE2F',
          '16':'#CAE2FF',
          '32':'#9EC9FF',
          '64':'#77B4FF',
          '128':'#4096FF',
          '256':'#AE2CFF'
        },
        'system':{
          'controll':'#ffffff',
          'defbg':'#E0F0FC'
        }
      };
  
  }
  
  // Expose Wgt to the global object
  window.$C = new WgtConf();

})(window);



/* Licence see: /LICENCES/wgt/licence.txt */


// key numbers
window.key = {
  RETURN:13,
  TAB:9,
  ESC:27,
  ARRLEFT:37,
  ARRUP :38,
  ARRRIGHT:39,
  ARRDOWN:40,
  BACKSPACE:8,
  DELETE:46
};

// status
window.stat = {
  UD:'undefined'
};

/**
 * indexOf für Arrays implementieren, wenn die JS Engine 
 * keine native indexOf Funktionalität besitzt
 */
if (!Array.indexOf) {
 
  Array.prototype.indexOf = function(obj, start) {
    for (var i = (start || 0), j = this.length; i < j; i++) {
        if (this[i] === obj) { return i; }
    }
    return -1;
  };
  
  /*
  Array.prototype.indexOf = function (obj, start) {
    for (var i = (start || 0); i < this.length; i++) {
      if (this[i] == obj) {
        return i;
      }
    }
  }
  */
}

if(typeof String.prototype.trim !== 'function') {
  String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g, ''); 
  }
}


/*!
 * Lets take a moment an thank the MOST STUPID; MOST UGLY; MOST UARGWDIOUBDFPWQIUBDQWPIFDBQ!!!!
 * GOD DAMN MOTHER FPEEEEP PEEEEEEP PEEEEP! PEEEEEEEEP PEEEEEEEEEEP!!!!!! PEEEEP!
 * WHO THE HELL THINKS IT'S A GOOD IDEA TO MAKE CONSOLE IMUTEABLE?
 * HOW COULD ANY HUMAN BEEIN THINK IT'S A AN OPTION TO THROW AN UNDEFINED 
 * ERROR IN AN FUNCTION THAT CHECKS IF SMTH IS UNDEFINDED???
 * 
 */
var $console = {
  
    log: function( message ){
      console.log( message );
    },
    debug: function( message ){
      console.log( message );
    },
    info: function( message ){
      console.info( message );
    },
    warn: function( message ){
      console.warn( message );
    },
    error: function( message ){
      console.error( message );
    },
    time: function(){
      console.error( message );      
    },
    timeEnd: function(){
      
    },
    trace: function( message ){
      console.log( message );
    },
    group: function(){
      
    },
    groupEnd: function(){
      
    }
    
}//end console

/**
 * Shortcut für document.getElementById
 * 
 * @param id
 * @returns DomNode
 */
function getById( id ){
  
  return document.getElementById(id);
}//end function getById


function str_replace ( search, replace, subject ) {
  
  // Replace all occurrences of the search string with the replacement string
  //
  // +    discuss at: http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_str_replace/
  // +       version: 803.1715
  // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +   improved by: Gabriel Paderni
  // *     example 1: str_replace(' ', '.', 'Kevin van Zonneveld');
  // *     returns 1: 'Kevin.van.Zonneveld'

  if(!(replace instanceof Array)){
    replace=new Array(replace);
    if(search instanceof Array){//If search    is an array and replace    is a string, then this replacement string is used for every value of search
      while(search.length>replace.length){
        replace[replace.length]=replace[0];
      }
    }
  }

  if(!(search instanceof Array))
    search=new Array(search);
  
  while(search.length>replace.length){//If replace    has fewer values than search , then an empty string is used for the rest of replacement values
    replace[replace.length]='';
  }

  if(subject instanceof Array){//If subject is an array, then the search and replace is performed with every entry of subject , and the return value is an array as well.
    for(k in subject){
      subject[k]=str_replace(search,replace,subject[k]);
    }
    return subject;
  }

  for(var k=0; k<search.length; k++) {
    
    if( subject == null )
      continue;

    var i = subject.indexOf(search[k]);
    while(i>-1){
      
      subject = subject.replace(search[k], replace[k]);
      i = subject.indexOf(search[k],i);
    }
  }

  return subject;

}//end function str_replace */

function trim( str, charlist ) {
    // Strip whitespace (or other characters) from the beginning and end of a string
    //
    // +    discuss at: http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_trim/
    // +       version: 803.1715
    // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: mdsjack (http://www.mdsjack.bo.it)
    // +   improved by: Alexander Ermolaev (http://snippets.dzone.com/user/AlexanderErmolaev)
    // +      input by: Erkekjetter
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // *     example 1: trim('    Kevin van Zonneveld    ');
    // *     returns 1: 'Kevin van Zonneveld'
    // *     example 2: trim('Hello World', 'Hdle');
    // *     returns 2: 'o Wor'

    charlist = !charlist ? ' \s\xA0' : charlist.replace(/([\[\]\(\)\.\?\/\*\{\}\+\$\^\:])/g, '\$1');
    var re = new RegExp('^[' + charlist + ']+|[' + charlist + ']+$', 'g');
    return str.replace(re, '');
}//

function strlen (string) {
    // http://kevin.vanzonneveld.net
    // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: Sakimori
    // +      input by: Kirk Strobeck
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   bugfixed by: Onno Marsman
    // +    revised by: Brett Zamir (http://brett-zamir.me)
    // %        note 1: May look like overkill, but in order to be truly faithful to handling all Unicode
    // %        note 1: characters and to this function in PHP which does not count the number of bytes
    // %        note 1: but counts the number of characters, something like this is really necessary.
    // *     example 1: strlen('Kevin van Zonneveld');
    // *     returns 1: 19
    // *     example 2: strlen('A\ud87e\udc04Z');
    // *     returns 2: 3

    var str = string+'';
    var i = 0, chr = '', lgth = 0;

    var getWholeChar = function (str, i) {
        var code = str.charCodeAt(i);
        var next = '', prev = '';
        if (0xD800 <= code && code <= 0xDBFF) { // High surrogate (could change last hex to 0xDB7F to treat high private surrogates as single characters)
            if (str.length <= (i+1))  {
                throw 'High surrogate without following low surrogate';
            }
            next = str.charCodeAt(i+1);
            if (0xDC00 > next || next > 0xDFFF) {
                throw 'High surrogate without following low surrogate';
            }
            return str.charAt(i)+str.charAt(i+1);
        } else if (0xDC00 <= code && code <= 0xDFFF) { // Low surrogate
            if (i === 0) {
                throw 'Low surrogate without preceding high surrogate';
            }
            prev = str.charCodeAt(i-1);
            if (0xD800 > prev || prev > 0xDBFF) { //(could change last hex to 0xDB7F to treat high private surrogates as single characters)
                throw 'Low surrogate without preceding high surrogate';
            }
            return false; // We can pass over low surrogates now as the second component in a pair which we have already processed
        }
        return str.charAt(i);
    };

    for (i=0, lgth=0; i < str.length; i++) {
        if ((chr = getWholeChar(str, i)) === false) {
            continue;
        } // Adapt this line at the top of any loop, passing in the whole string and the current iteration and returning a variable to represent the individual character; purpose is to treat the first part of a surrogate pair as the whole character and then ignore the second part
        lgth++;
    }
    return lgth;
}

function var_dump (){
  
    // http://kevin.vanzonneveld.net
    // +   original by: Brett Zamir (http://brett-zamir.me)
    // +   improved by: Zahlii
    // +   improved by: Brett Zamir (http://brett-zamir.me)
    // -    depends on: echo
    // %        note 1: For returning a string, use var_export() with the second argument set to true
    // *     example 1: var_dump(1);
    // *     returns 1: 'int(1)'

    var output = '', pad_char = ' ', pad_val = 4, lgth = 0, i = 0, d = this.window.document;
    var _getFuncName = function (fn) {
        var name = (/\W*function\s+([\w\$]+)\s*\(/).exec(fn);
        if (!name) {
            return '(Anonymous)';
        }
        return name[1];
    };

    var _repeat_char = function (len, pad_char) {
        var str = '';
        for (var i = 0; i < len; i++) {
            str += pad_char;
        }
        return str;
    };
    var _getInnerVal = function (val, thick_pad) {
        var ret = '';
        if (val === null) {
            ret = 'NULL';
        }
        else if (typeof val === 'boolean') {
            ret = 'bool(' + val + ')';
        }
        else if (typeof val === 'string') {
            ret = 'string(' + val.length+') "' + val + '"';
        }
        else if (typeof val === 'number') {
            if (parseFloat(val) == parseInt(val, 10)) {
                ret = 'int(' + val + ')';
            }
            else {
                ret = 'float('+val+')';
            }
        }
        // The remaining are not PHP behavior because these values only exist in this exact form in JavaScript
        else if (typeof val === 'undefined') {
            ret = 'undefined';
        }
        else if (typeof val === 'function') {
            var funcLines = val.toString().split('\n');
            ret = '';
            for (var i = 0, fll = funcLines.length; i < fll; i++) {
                ret += (i !== 0 ? '\n'+thick_pad : '') + funcLines[i];
            }
        }
        else if (val instanceof Date) {
            ret = 'Date('+val+')';
        }
        else if (val instanceof RegExp) {
            ret = 'RegExp('+val+')';
        }
        else if (val.nodeName) { // Different than PHP's DOMElement
            switch(val.nodeType) {
                case 1:
                    if (typeof val.namespaceURI === 'undefined' || val.namespaceURI === 'http://www.w3.org/1999/xhtml') { // Undefined namespace could be plain XML, but namespaceURI not widely supported
                        ret = 'HTMLElement("' + val.nodeName + '")';
                    }
                    else {
                        ret = 'XML Element("' + val.nodeName + '")';
                    }
                    break;
                case 2:
                    ret = 'ATTRIBUTE_NODE(' + val.nodeName + ')';
                    break;
                case 3:
                    ret = 'TEXT_NODE(' + val.nodeValue + ')';
                    break;
                case 4:
                    ret = 'CDATA_SECTION_NODE(' + val.nodeValue + ')';
                    break;
                case 5:
                    ret = 'ENTITY_REFERENCE_NODE';
                    break;
                case 6:
                    ret = 'ENTITY_NODE';
                    break;
                case 7:
                    ret = 'PROCESSING_INSTRUCTION_NODE(' + val.nodeName + ':' + val.nodeValue+')';
                    break;
                case 8:
                    ret = 'COMMENT_NODE(' + val.nodeValue + ')';
                    break;
                case 9:
                    ret = 'DOCUMENT_NODE';
                    break;
                case 10:
                    ret = 'DOCUMENT_TYPE_NODE';
                    break;
                case 11:
                    ret = 'DOCUMENT_FRAGMENT_NODE';
                    break;
                case 12:
                    ret = 'NOTATION_NODE';
                    break;
            }
        }
        return ret;
    };

    var _formatArray = function (obj, cur_depth, pad_val, pad_char) {
        var someProp = '';
        if (cur_depth > 0) {
            cur_depth++;
        }

        var base_pad = _repeat_char(pad_val * (cur_depth - 1), pad_char);
        var thick_pad = _repeat_char(pad_val * (cur_depth + 1), pad_char);
        var str = '';
        var val = '';

        if (typeof obj === 'object' && obj !== null) {
            if (obj.constructor && _getFuncName(obj.constructor) === 'PHPJS_Resource') {
                return obj.var_dump();
            }
            lgth = 0;
            for (someProp in obj) {
                lgth++;
            }
            str += 'array('+lgth+') {\n';
            for (var key in obj) {
                var objVal = obj[key];
                if (typeof objVal === 'object' && objVal !== null &&
                    !(objVal instanceof Date) && !(objVal instanceof RegExp) && !objVal.nodeName) {
                    str += thick_pad + '[' + key + '] =>\n' + thick_pad + _formatArray(objVal, cur_depth + 1, pad_val, pad_char);
                } else {
                    val = _getInnerVal(objVal, thick_pad);
                    str += thick_pad + '[' + key + '] =>\n' + thick_pad + val + '\n';
                }
            }
            str += base_pad + '}\n';
        } else {
            str = _getInnerVal(obj, thick_pad);
        }
        return str;
    };

    output = _formatArray(arguments[0], 0, pad_val, pad_char);
    for (i=1; i < arguments.length; i++) {
        output += '\n' + _formatArray(arguments[i], 0, pad_val, pad_char);
    }

    if (d.body)
    {
        return output;
    }
    else
    {
      try
      {
        d = XULDocument; // We're in XUL, so appending as plain text won't work
        return '<pre xmlns="http://www.w3.org/1999/xhtml" style="white-space:pre;">'+output+'</pre>';
      }
      catch (e)
      {
        return output; // Outputting as plain text may work in some plain XML
      }
    }
}

 
function escapearg(s){
  
  if(s == undefined || !s) return '';
  return s.replace('\\','\\\\').
           replace('*','\\*').
           replace('.','\\.').
           replace('/','\\/');
}

function htmlspecialchars(s){
  
  if(s == undefined || !s) 
    return '';
  
  return s.replace('&','&amp;').
           replace('<','&lt;').
           replace('>','&gt;');
}

function ltrim(s){
  
  if(s == undefined || !s) 
    return '';
  
  return s.replace(/^\s+/g,'');
}












/*!
 * jQuery JavaScript Library v1.7.2
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Wed Mar 21 12:46:34 2012 -0700
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.2",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

		// Sets many values
		if ( key && typeof key === "object" ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;

		// Sets one value
		} else if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = pass === undefined && jQuery.isFunction( value );

			if ( bulk ) {
				// Bulk operations only iterate when executing function values
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};

				// Otherwise they run against the entire set
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}

			if ( fn ) {
				for (; i < length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}

			chainable = 1;
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			fired = true;
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		pixelMargin: true
	};

	// jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
	jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "name", "t" );

	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for ( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			marginDiv, conMarginTop, style, html, positionTopLeftWidthHeight,
			paddingMarginBorderVisibility, paddingMarginBorder,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		paddingMarginBorder = "padding:0;margin:0;border:";
		positionTopLeftWidthHeight = "position:absolute;top:0;left:0;width:1px;height:1px;";
		paddingMarginBorderVisibility = paddingMarginBorder + "0;visibility:hidden;";
		style = "style='" + positionTopLeftWidthHeight + paddingMarginBorder + "5px solid #000;";
		html = "<div " + style + "display:block;'><div style='" + paddingMarginBorder + "0;display:block;overflow:hidden;'></div></div>" +
			"<table " + style + "' cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = paddingMarginBorderVisibility + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='" + paddingMarginBorder + "0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check if div with explicit width and no margin-right incorrectly
		// gets computed margin-right based on width of container. For more
		// info see bug #3333
		// Fails in WebKit before Feb 2011 nightlies
		// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
		if ( window.getComputedStyle ) {
			div.innerHTML = "";
			marginDiv = document.createElement( "div" );
			marginDiv.style.width = "0";
			marginDiv.style.marginRight = "0";
			div.style.width = "2px";
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
		}

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.innerHTML = "";
			div.style.width = div.style.padding = "1px";
			div.style.border = 0;
			div.style.overflow = "hidden";
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "block";
			div.style.overflow = "visible";
			div.innerHTML = "<div style='width:5px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
		}

		div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		if ( window.getComputedStyle ) {
			div.style.marginTop = "1%";
			support.pixelMargin = ( window.getComputedStyle( div, null ) || { marginTop: 0 } ).marginTop !== "1%";
		}

		if ( typeof container.style.zoom !== "undefined" ) {
			container.style.zoom = 1;
		}

		body.removeChild( container );
		marginDiv = div = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				data = this.triggerHandler( "getData" + part, [ parts[0] ] );

				// Try to fetch any internally stored data first
				if ( data === undefined && elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}

				return data === undefined && parts[1] ?
					this.data( parts[0] ) :
					data;
			}

			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );

				self.triggerHandler( "setData" + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + part, parts );
			});
		}, null, value, arguments.length > 1, null, false );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise( object );
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l, isBool,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );

					// See #9699 for explanation of this approach (setting first, then removal)
					// Do not do this for boolean attributes (see #10870)
					if ( !isBool ) {
						jQuery.attr( elem, name, "" );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( isBool && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true,
		coords: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /(?:^|\s)hover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: selector && quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

				// Don't process events on disabled elements (#6911, #8165)
				if ( cur.disabled !== true ) {
					selMatch = {};
					matches = [];
					jqcur[0] = cur;
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;

						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = (
								handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
							);
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},
		
		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) { // && selector != null
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;

	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];

			parts.push( m[1] );

			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}

				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];

		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );

			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}

			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},

	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},

		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					if ( type === "first" ) {
						return true;
					}

					node = elem;

					/* falls through */
				case "last":
					while ( (node = node.nextSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}

					doneName = match[0];
					parent = elem.parentNode;

					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;

						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}

						parent[ expando ] = doneName;
					}

					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},

		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}
// Expose origPOS
// "global" as in regardless of relation to brackets/parens
Expr.match.globalPOS = origPOS;

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}

	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}

		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );

					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}

				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );

					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}

						} else {
							return makeArray( [], extra );
						}
					}

					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}

			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );

		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try {
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}

	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.globalPOS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];

		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					null;
			}


			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( "*" ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						jQuery.ajax({
							type: "GET",
							global: false,
							url: elem.src,
							async: false,
							dataType: "script"
						});
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
					}

					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;

	// IE blanks contents when cloning scripts
	} else if ( nodeName === "script" && dest.text !== src.text ) {
		dest.text = src.text;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );

	// Clear flags for bubbling special change/submit events, they must
	// be reattached when the newly cloned events are first activated
	dest.removeAttribute( "_submit_attached" );
	dest.removeAttribute( "_change_attached" );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType, script, j,
				ret = [];

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div"),
						safeChildNodes = safeFragment.childNodes,
						remove;

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;

					// Clear elements from DocumentFragment (safeFragment or otherwise)
					// to avoid hoarding elements. Fixes #11356
					if ( div ) {
						div.parentNode.removeChild( div );

						// Guard against -1 index exceptions in FF3.6
						if ( safeChildNodes.length > 0 ) {
							remove = safeChildNodes[ safeChildNodes.length - 1 ];

							if ( remove && remove.parentNode ) {
								remove.parentNode.removeChild( remove );
							}
						}
					}
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				script = ret[i];
				if ( scripts && jQuery.nodeName( script, "script" ) && (!script.type || rscriptType.test( script.type )) ) {
					scripts.push( script.parentNode ? script.parentNode.removeChild( script ) : script );

				} else {
					if ( script.nodeType === 1 ) {
						var jsTags = jQuery.grep( script.getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( script );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnum = /^[\-+]?(?:\d*\.)?\d+$/i,
	rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
	rrelNum = /^([\-+])=([\-+.\de]+)/,
	rmargin = /^margin/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },

	// order is important!
	cssExpand = [ "Top", "Right", "Bottom", "Left" ],

	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	return jQuery.access( this, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	}, name, value, arguments.length > 1 );
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {},
			ret, name;

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// DEPRECATED in 1.3, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle, width,
			style = elem.style;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {

			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// WebKit uses "computed value (percentage if specified)" instead of "used value" for margins
		// which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !jQuery.support.pixelMargin && computedStyle && rmargin.test( name ) && rnumnonpx.test( ret ) ) {
			width = style.width;
			style.width = ret;
			ret = computedStyle.width;
			style.width = width;
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( rnumnonpx.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		i = name === "width" ? 1 : 0,
		len = 4;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i += 2 ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ];
	}

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test(val) ) {
		return val;
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i += 2 ) {
			val += parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ]) ) || 0;
			}
		}
	}

	return val + "px";
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWidthOrHeight( elem, name, extra );
				} else {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				}
			}
		},

		set: function( elem, value ) {
			return rnum.test( value ) ?
				value + "px" :
				value;
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						return curCSS( elem, "margin-right" );
					} else {
						return elem.style.marginRight;
					}
				});
			}
		};
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {

	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ],
				expanded = {};

			for ( i = 0; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};
});




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = ( typeof s.data === "string" ) && /^application\/x\-www\-form\-urlencoded/.test( s.contentType );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									try {
										responses.text = xhr.responseText;
									} catch( _ ) {
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( (display === "" && jQuery.css(elem, "display") === "none") ||
						!jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e, hooks, replace,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			// first pass over propertys to expand / normalize
			for ( p in prop ) {
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				if ( ( hooks = jQuery.cssHooks[ name ] ) && "expand" in hooks ) {
					replace = hooks.expand( prop[ name ] );
					delete prop[ name ];

					// not quite $.extend, this wont overwrite keys already present.
					// also - reusing 'p' from above because we have the correct "name"
					for ( p in replace ) {
						if ( ! ( p in prop ) ) {
							prop[ p ] = replace[ p ];
						}
					}
				}
			}

			for ( name in prop ) {
				val = prop[ name ];
				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return ( -Math.cos( p*Math.PI ) / 2 ) + 0.5;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				if ( self.options.hide ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.start );
				} else if ( self.options.show ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.end );
				}
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Ensure props that can't be negative don't go there on undershoot easing
jQuery.each( fxAttrs.concat.apply( [], fxAttrs ), function( i, prop ) {
	// exclude marginTop, marginLeft, marginBottom and marginRight from this list
	if ( prop.indexOf( "margin" ) ) {
		jQuery.fx.step[ prop ] = function( fx ) {
			jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
		};
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( jQuery.support.boxModel ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var getOffset,
	rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	getOffset = function( elem, doc, docElem, box ) {
		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow( doc ),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	getOffset = function( elem, doc, docElem ) {
		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var elem = this[0],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return null;
	}

	if ( elem === doc.body ) {
		return jQuery.offset.bodyOffset( elem );
	}

	return getOffset( elem, doc, doc.documentElement );
};

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					jQuery.support.boxModel && win.document.documentElement[ method ] ||
						win.document.body[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	var clientProp = "client" + name,
		scrollProp = "scroll" + name,
		offsetProp = "offset" + name;

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( value ) {
		return jQuery.access( this, function( elem, type, value ) {
			var doc, docElemProp, orig, ret;

			if ( jQuery.isWindow( elem ) ) {
				// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
				doc = elem.document;
				docElemProp = doc.documentElement[ clientProp ];
				return jQuery.support.boxModel && docElemProp ||
					doc.body && doc.body[ clientProp ] || docElemProp;
			}

			// Get document width or height
			if ( elem.nodeType === 9 ) {
				// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
				doc = elem.documentElement;

				// when a window > document, IE6 reports a offset[Width/Height] > client[Width/Height]
				// so we can't use max, as it'll choose the incorrect offset[Width/Height]
				// instead we use the correct client[Width/Height]
				// support:IE6
				if ( doc[ clientProp ] >= doc[ scrollProp ] ) {
					return doc[ clientProp ];
				}

				return Math.max(
					elem.body[ scrollProp ], doc[ scrollProp ],
					elem.body[ offsetProp ], doc[ offsetProp ]
				);
			}

			// Get width or height on the element
			if ( value === undefined ) {
				orig = jQuery.css( elem, type );
				ret = parseFloat( orig );
				return jQuery.isNumeric( ret ) ? ret : orig;
			}

			// Set the width or height on the element
			jQuery( elem ).css( type, value );
		}, type, value, arguments.length, null );
	};
});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );

/* Licence see: /LICENCES/wgt/licence.txt */

;(function($S, undefined){
  
  $S.fn.reverse = Array.reverse;

  /**
  * get on single Parent with a given selector als match
  */
  $S.fn.parentX = function( selector ){
  
    var node = $S(this).parent();
    var level = 0;
  
    while(level <100){
      ++level;
      if(node.is(selector)){
          return node;
      }
      else if( node.is('body') || node.is('HTML') ){
          return null;
      }
      else{
        node = node.parent();
        if(!node)
          return null;
      }
    }
    
    return null;
    
  };
  
  /**
   * get all classes of an element as array
   */
  $S.fn.classes = function( ){
    
    var nodeC = this.get(0).className;
    
    if( typeof nodeC != 'string' ){
      console.error( "Requestes class from classless node "+$S(this.get(0)).getNodePath( '/' ) );
      return [];
    }
   
    return nodeC.split(" ");
  };

  
  /**
   * Den Pfad eines Nodes verfolgen
   */
  $S.fn.getNodePath = function( joinBy, depth ){
    
    if( !joinBy )
      joinBy = ' ';
    
    if( !depth )
      depth = 3;
    
    var pos = 0;
    
    var rightArrowParents = [];
    
    var entry = this.get(0).tagName.toLowerCase();
    if ( this.prop('id') ) {
        entry += "#" + this.prop('id');
    }
    rightArrowParents.push(entry);
    
    $S(this.get(0)).parents().not('html').each(function() {
        
        if( pos > depth )
          return;
      
        entry = this.tagName.toLowerCase();
        if ( $S(this).prop('id') ) {
            entry += "#" + $S(this).prop('id');
        }
        rightArrowParents.push(entry);
        
        ++pos;
    });
    rightArrowParents.reverse();
    
    var currentDate = new Date()
   
    return rightArrowParents.join(joinBy)+' '+currentDate.getMinutes()+'.'+currentDate.getSeconds()+'.'+currentDate.getMilliseconds();
  };

  /**
   * Disable the textselection
   */
  $S.fn.disableTextSelect = function( ){

    // Disable text selection
    if( $S.browser.mozilla ) {
      $S(this).each( function() { 
        $S(this).css({ 'MozUserSelect' : 'none' });
      });
    } else if( $S.browser.msie ) {
      $S(this).each( function() { 
        $S(this).bind('selectstart.disableTextSelect', function() {
          return false;
        });
      });
    } else {
      $S(this).each(function() { 
        $S(this).bind('mousedown.disableTextSelect', function() {
          return false;
        });
      });
    }
    
    return $S;
  };

  /**
   * Summe von Werten aus Inputfeldern berechnen
   */
  $S.fn.calcSum = function(  ){
   
    var sum = 0;
    
    $S(this).each( function(){
      
      if( isNaN(sum) )
        return;
      
      var $node = $S(this);
      var value = $node.val();

      if( '' == value )
        value = 0;
      
      if( isNaN(value) ){
        sum = '(not a number)';
      }
      
      sum += parseFloat(value);
      
      return;
      
    });
    
    return sum;
  };
  
  /**
   * Durchschnittswert von Inputfeldern berechnen
   */
  $S.fn.calcAvg = function(  ){
   
    var sum = 0;
    
    var elements = $S(this);
    
    if( !elements.length )
      return 0;
    
    elements.each( function(){
      
      if( isNaN(sum) )
        return;
      
      var $node = $S(this);
      var value = $node.val();

      if( '' == value )
        value = 0;
      
      if( isNaN(value) ){
        sum = '(not a number)';
      }
      
      sum += parseFloat(value);
      
      return;
      
    });
    
    console.log( 'SUM '+sum );
    
    if( isNaN(sum) )
      return sum;
    
    return (sum / elements.length).toFixed(2);
  };
  
  /**
   * get all classes of an element as array
   */
  $S.fn.niceValue = function( value ){

    var slctElem = $S(this);
    slctElem.val(value);

    var slctNode = slctElem.get(0);
    var niceElem = $S('input#display-'+slctElem.prop('id'));
   
    niceElem.val(slctNode.options[slctNode.selectedIndex].innerHTML);

  };
  
 /**
  * get on single Parent with a given selector als match
  */
  $S.fn.iconToggle = function( contrl ){
     
    var _$ = $S(this);
   
    if(_$.is(':visible')){
      $S(contrl).find('img').attr('src',$C.iconClosed).attr('alt','closed');
      
      _$.toggle();
    }
    else{
      $S(contrl).find('img').attr('src',$C.iconOpened).attr('alt','opened');
        _$.toggle();
    }
  };
   
 /**
  * get first class with a given prefix
  * @param start
  * @param cut
  */
  $S.fn.getActionClass = function( start, cut, sep ){
    
    if(undefined ==cut)
      cut = true;
    
    if( undefined == sep )
      sep = '_'; 

    var _$        = $S(this);
    var cString   = ''+_$.prop('class');

    var classParts  = cString.split(' ');
    var tmpLenght   = classParts.length;
    
    // append _
    start += sep;
    
    var pLength     = start.length;

    for (var index = 0; index < tmpLenght; ++index){

      var tmp = classParts[index];
      if( start == tmp.substring(0,pLength) ) {
        if(cut){
          return tmp.substring(pLength,tmp.length);
        }
        else{
          return tmp;
        }
      }
    }
    
    // found no class
    return null;

  };
   
})(jQuery);



/* Licence see: /LICENCES/wgt/licence.txt */

// Map jQuery in an non conclickt mode in $S
window.$S = jQuery.noConflict();

(function(window){

  /**
   * @author dominik alexander bonsch <db@webfrap.net>
   * 
   * das Wgt Objekt
   * Die Mutter des WGT WebFrap Gui Toolkit
   * Ich möchte an dieser Stelle mir danken dass ich so total bescheuert bin
   * und mich darauf einlasse mal noch schnell ein GUI Toolkit aus dem Boden
   * zu stampfen dass eine saubere Architektur hat.
   *
   * Hier ist der Konstruktor des WGT Objektes
   *
   * @extends js_wgt/jquery.js
   */
  function Wgt(){

    // use correct document
    var document = window.document;
    
    /**
     * referenz auf this für das parent object
     */
    var self = this;
    
    /**
     * referenz auf prototype um das WGT objekt leicht erweitern zu können
     */
    this.fn = Wgt.prototype;
    
    /**
     * @var string
     */
    this.name = 'WGT WebFrap Gui Toolkit';

    /**
     * @var int
     */
    this.version = '0.6';

    /**
     * pool for actions that has to be done on window ready
     */
    this.initPool = [];
    
    /**
     * Pool für generische Elemente, um nicht jedesmal den iterator implementieren
     * zu müssen
     */
    this.eventsPool = {};
    
    /**
     * Liste der Module die schon geladen wurden
     * zu müssen
     */
    this.modules = {};
    
    /**
     * Einzelne JS Dateien
     * zu müssen
     */
    this.singleFiles = {};
    
    /**
     * Style Listen verwalten
     */
    this.styles = {};

/*
 * Module Logik
 ********************/
    
    /**
     * @param key string der key für das zu ladente Modul
     */
    this.moduleIsLoaded = function( key ){
      
      if( self.modules[key] == undefined ){
        
        return false;
      }
      else{
        
        return true;
      }
      
    };//end this.moduleIsLoaded
    
    /**
     * @param key string der key für das zu ladente Modul
     */
    this.loadModule = function( key, callback ){

      if( self.modules[key] == undefined ){
    	  
        var WEB_GW = (tmp = new RegExp('(?:^|; )' + encodeURIComponent('WEB_GW') + '=([^;]*)').exec(document.cookie)) 
          ? decodeURIComponent(tmp[1]) : null;
        
        self.modules[key] = true;
        
        if( WEB_GW !== undefined ){
          $S('head').append( '<script type="text/javascript" src="'+WEB_GW+'js.php?l=list.'+key+'" ></script>' );
        }
        else if( $C.WEB_GW ){
          $S('head').append( '<script type="text/javascript" src="'+$C.WEB_GW+'js.php?l=list.'+key+'" ></script>' );
        }
        else{
          $S('head').append( '<script type="text/javascript" src="js.php?l=list.'+key+'" ></script>' );
        }
        
        if( callback )
          callback();
         
      }
      
    };//end this.loadModule
    
/*
 * JS File Logik
 ********************/
    
    /**
     * @param key string der key für das zu ladente Modul
     */
    this.fileIsLoaded = function( key ){
      
      if( self.singleFiles[key] == undefined ){
        return false;
      }
      else{
        return true;
      }
      
    };//end this.moduleIsLoaded
    
    /**
     * @param key string der key für das zu ladente Modul
     */
    this.loadSingleFile = function( file ){
      
      if( self.singleFiles[key] == undefined ){
        
        self.singleFiles[key] = true;
        $S('head').append( '<script type="text/javascript" src="'+file+'" ></script>' );
      }
    };//end this.loadSingleFile
    
/*
 * Style Logik
 ********************/
      
    /**
     * @param key string der key für das zu ladente Modul
     */
    this.styleIsLoaded = function( key ){
      
      if( self.styles[key] == undefined ){
        return false;
      }
      else{
        return true;
      }
      
    };//end this.moduleIsLoaded
    
    /**
     * @param key string der key für das zu ladente Modul
     */
    this.loadStyle = function( key ){
      
      if( self.styles[key] != undefined ){
	    
	    var WEB_GW = (tmp = new RegExp('(?:^|; )' + encodeURIComponent('WEB_GW') + '=([^;]*)').exec(document.cookie)) 
	      ? decodeURIComponent(tmp[1]) : null;
        
        self.styles[key] = true;
        
        if( WEB_GW !== undefined ){
          $S('head').append( '<link type="text/css" href="'+WEB_GW+'css.php?l=list.'+key+'" rel="stylesheet" />' );
        }
        else if( $C.WEB_GW ){
          $S('head').append( '<link type="text/css" href="'+$C.WEB_GW+'css.php?l=list.'+key+'" rel="stylesheet" />' );
        }
        else{
          $S('head').append( '<link type="text/css" href="css.php?l=list.'+key+'" rel="stylesheet" />' );
        }

      }
      
    };//end this.loadStyle
    
/*
 * Event Logik
 ********************/
    

    /**
     * request the actual running version
     * @param callBack
     */
    this.addInitCall = function( callBack ){
      
      this.initPool.push(callBack);
    };//end this.addInitCall
    
    /**
     * @param string key den key des Events
     * @param function callBack ein annonyme funktion die aufgerufen werden soll 
     */
    this.addEvent = function( key, callBack ){
      
      if( undefined === this.eventsPool[key] ){
        this.eventsPool[key]=[];
      }
      
      this.eventsPool[key].push(callBack);

    };//end addEvent */
    
    /**
    * Triggern eines bestimmten Events
    * 
    * @param string key, der Key des Events das getriggert werden soll
    */
   this.triggerEvent = function( key ) {

     if( undefined === this.eventsPool[key] ) {
       return;
     }
     
     var length = this.eventsPool[key].length;
     for (var index = 0; index < length; ++index) {

       var callback = this.eventsPool[key][index];
       try {

         callback();
       } catch( e ) {

         window.$D.errorWindow( e.name, e.message );
       }
     }

   };// this.triggerEvent

    /**
     *
     */
   this.eventInit = function( ) {

    var length = this.initPool.length;
    for (var index = 0; index < length; ++index) {

      var callback = this.initPool[index];
      try {

        callback();
      } catch( e ) {

        //alert(e.message);
        window.$D.errorWindow( e.name, e.message );
        //this.desktop.errorWindow( exception.name, exception.message );
      }
    }

   };//end this.eventInit

  /**
   * request the actual running version
   */
  this.getVersion = function( ){
    
    return this.version;
  };//end this.getVersion */

  /**
   * Die Sandbox ist dazu da um Methode einfach in einer gesicherte
   * Umgebung laufen zu lassen.
   * Im Moment beschränkt sich die Sicherung auf einen Try Catch Block
   */
  this.sandbox = function( callback ){

    try{

      callback();
    } 
    catch( e ) {

      $D.errorWindow( e.name, e.message );
    }

  };//end this.sandbox  */

    /**
     * create an empty document fragment
     */
    this.fragment = function(){
      
      return $S(document.createDocumentFragment());
      
    };//end his.fragment


    /**
     * check the type of an object
     * @param obj
     * @param type
     */
    this.nodeType = function(obj,type){
      
      return ( obj.nodeName.toLowerCase() == type.toLowerCase() )?true:false;

    };

    /**
     * check the type of an object
     * @param obj
     */
    this.typeOf = function(obj){
      
      if ( typeof(obj) == 'object' ){
        
        if (obj.length) {

          return 'array';
        } 
        else {

          return 'object';
        }
      } 
      else {
        
        return typeof(obj);
      }
      
    };

    /**
     * check if a given variable is undefined
     * @param obj
     */
    this.undef = function(obj){

      if( typeof obj == 'undefined' )
        return true;
      else
        return false;
    };

    /**
     * check if a given variable is empty
     * @param obj
     */
    this.empty = function(obj){

      if( obj === undefined || obj === null || obj === '' )
        return true;
      else
        return false;

    };

    /**
     * add a default value to an object
     * @param obj
     * @param key
     * @param val
     */
    this.dval = function(obj,key,val){

      if(this.undef(obj[key]))
        obj[key] = val;

    };
    
    /**
     * @param string classText
     * @param string prefix
     * @param boolean justKey
     */
    this.getClassByPrefix = function( classText, prefix, justKey  ){

      if( justKey === undefined )
        justKey = true;
      
      if( !classText || typeof classText != 'string'  ){
        this.printStackTrace("Got empty classText");
        return null;
      }

      var classParts  = classText.split(' ');
      var tmpLenght   = classParts.length;
      var prFixL      = prefix.length;

      for (var index = 0; index < tmpLenght; ++index){

        var classKey = classParts[index];
        if( prefix == classKey.substring(0,prFixL) ) {
          return justKey
            ? classKey.substring(prFixL,classKey.length)
            : classKey;
        }
      }
      
      return null;

    };//end this.getClassByPrefix
    

    /**
     * 
     * @param string tplId
     */
    this.getTemplate = function( tplId  ){
      
      var tmp = $S( "#"+tplId ).clone();
      tmp.attr('id','');

      return tmp;

    };//end this.getTemplate
    
    /**
     * robuster JSON parser, fängt fehler ab und gibt null zurück
     * wenn das parsen fehlgeschlagen ist
     */
    this.robustParseJSON =  function( data ){
     
      var jsonData = {};

      try{
        jsonData = $S.parseJSON(data);
      }
      catch( err ){
        console.error( 'Failed to parse JSON : '+data);
        ///TODO some error handling here
      }
      
      /*
       jsonData = $S.parseJSON(data);
       */

      return jsonData;
    
    };//end this.robustParseJSON
    
    this.printStackTrace = function( message ) {
      
      var callstack = [];
      var isCallstackPopulated = false;
      
      try {
        i.dont.exist+=0; //doesn't exist- that's the point
      } catch(e) {
        if (e.stack) { //Firefox
          var lines = e.stack.split('\n');
          for (var i=0, len=lines.length; i<len; i++) {
            if (lines[i].match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
              callstack.push(lines[i]);
            }
          }
          //Remove call to printStackTrace()
          callstack.shift();
          isCallstackPopulated = true;
        }
        else if (window.opera && e.message) { //Opera
          var lines = e.message.split('\n');
          for (var i=0, len=lines.length; i<len; i++) {
            if (lines[i].match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
              var entry = lines[i];
              //Append next line also since it has the file info
              if (lines[i+1]) {
                entry += ' at ' + lines[i+1];
                i++;
              }
              callstack.push(entry);
            }
          }
          //Remove call to printStackTrace()
          callstack.shift();
          isCallstackPopulated = true;
        }
      }
      if (!isCallstackPopulated) { //IE and Safari
        var currentFunction = arguments.callee.caller;
        while (currentFunction) {
          var fn = currentFunction.toString();
          var fname = fn.substring(fn.indexOf("function") + 8, fn.indexOf('')) || 'anonymous';
          callstack.push(fname);
          currentFunction = currentFunction.caller;
        }
      }
      
      console.log( message+" call: "+callstack );
    };
    
    /**
     * den aktuell höchsten z-index auslesen und +1 zurückgeben
     * @return int
     */
    this.getNextHighestZindex = function(){
      
      var highestIndex = 0;
      var currentIndex = 0;
      var elArray = Array();
      elArray = document.getElementsByTagName('*');
      
      for(var i=0; i < elArray.length; i++){
        if (elArray[i].style){
          currentIndex = parseInt(elArray[i].style['zIndex']);
        }
        else if(window.getComputedStyle){
          currentIndex = parseInt(document.defaultView.getComputedStyle(elArray[i],null).getPropertyValue('z-index'));
        }
        if(!isNaN(currentIndex) && currentIndex > highestIndex){ 
          highestIndex = currentIndex; 
        }
      }
      return(highestIndex+1);
    };

  }//end function Wgt  */

// Expose Wgt to the global object
window.$B = window.wgt = window.$WGT = new Wgt;

})(window);

/* 
 * Error Handling 
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error 
 */

/**
 * Exception für technische fehler, wird nur geworfen wenn ein fehler vom system
 * erkannt wurde.
 * Pi mal Schnauze, wenn der Benutzer egal was er macht den Fehler nicht vermeiden kann.
 * 
 * @param message
 * @param debugInfo
 * @returns {WgtException}
 */
function WgtException( message, debugInfo ) {  
  this.name = "Internal Error";  
  this.message = message || "Sorry the system detected an error. Try to reload the browser. If this message persists please send a bug report.";  
  this.debugInfo = debugInfo;
}  
WgtException.prototype = new Error();  
WgtException.prototype.constructor = WgtException;  

/**
 * Exception die geworfen wird, wenn ein Benutzer einen fehler gemacht hat
 * der Angefangen werden musste.
 * Das heißt der Benutzer kann durch einen Korrektur seinens Verhaltens den
 * Fehler beheben.
 * 
 * @param message
 * @param debugInfo
 * @returns {WgtUserException}
 */
function WgtUserException( message, debugInfo ) {  
  this.name = "Ups, that was the wrong way...";  
  this.message = message || "Sorry the system detected an error. Try to reload the browser. If this message persists please send a bug report.";  
  this.debugInfo = debugInfo;
}  
WgtUserException.prototype = new Error();  
WgtUserException.prototype.constructor = WgtUserException;  

/**
 * Exception die geworfen wird, wenn der verwendete Browser nicht kompatibel
 * zu dem ist was eigentlich gerade passieren sollte
 * 
 * @param message
 * @param debugInfo
 * @returns {WgtClientException}
 */
function WgtClientException( message, debugInfo ) {  
  this.name = "Invalid Client";  
  this.message = message || "Your client / browser is to old or ignores common internet standards."
    +" Please try Mozilla Firefox, or Google Chrome. This browsers provide a high performance and support "
    +" all common internet standards as it is required for this application.";  
  this.debugInfo = debugInfo;
}  
WgtClientException.prototype = new Error();  
WgtClientException.prototype.constructor = WgtUserException;  

// Initialize the system

$S(document).ready(function(){
  $WGT.eventInit();
});

/* Licence see: /LICENCES/wgt/licence.txt */

;(function(window){
  
  /**
   * @author dominik alexander bonsch <db@webfrap.net>
   */
  function WgtI18n( ){
    this.fn = WgtI18n.prototype;
  }//end function WgtI18n

window.WgtI18n = window.$I18N = new WgtI18n();

})(window);
/* Licence see: /LICENCES/wgt/licence.txt */

$I18N.fn.Close = 'Schliesen';
$I18N.fn.setNewTime = 'Neue Zeit setzen';
$I18N.fn.requestFailed = 'Der Zugriff auf den Server ist fehlgeschlagen';




/*!
 * JSizes - JQuery plugin v0.32
 *
 * Licensed under the revised BSD License.
 * Copyright 2008, Bram Stein
 * All rights reserved.
 */
/*global jQuery*/
(function ($) {
	var num = function (value) {
		return parseInt(value, 10) || 0;
	};

	/**
	 * Sets or gets the values for min-width, min-height, max-width
	 * and max-height.
	 */
	$.each(['min', 'max'], function (i, name) {
		$.fn[name + 'Size'] = function (value) {
			var width, height;
			if (value) {
				if (value.width) {
					this.css(name + '-width', value.width);
				}
				if (value.height) {
					this.css(name + '-height', value.height);
				}
				return this;
			}
			else {
				width = this.css(name + '-width');
				height = this.css(name + '-height');
				// Apparently:
				//  * Opera returns -1px instead of none
				//  * IE6 returns undefined instead of none
				return {'width': (name === 'max' && (width === undefined || width === 'none' || num(width) === -1) && Number.MAX_VALUE) || num(width), 
						'height': (name === 'max' && (height === undefined || height === 'none' || num(height) === -1) && Number.MAX_VALUE) || num(height)};
			}
		};
	});

	/**
	 * Returns whether or not an element is visible.
	 */
	$.fn.isVisible = function () {
		return this.css('visibility') !== 'hidden' && this.css('display') !== 'none';
	};

	/**
	 * Sets or gets the values for border, margin and padding.
	 */
	$.each(['border', 'margin', 'padding'], function (i, name) {
		$.fn[name] = function (value) {
			if (value) {
				if (value.top) {
					this.css(name + '-top' + (name === 'border' ? '-width' : ''), value.top);
				}
				if (value.bottom) {
					this.css(name + '-bottom' + (name === 'border' ? '-width' : ''), value.bottom);
				}
				if (value.left) {
					this.css(name + '-left' + (name === 'border' ? '-width' : ''), value.left);
				}
				if (value.right) {
					this.css(name + '-right' + (name === 'border' ? '-width' : ''), value.right);
				}
				return this;
			}
			else {
				return {top: num(this.css(name + '-top' + (name === 'border' ? '-width' : ''))),
						bottom: num(this.css(name + '-bottom' + (name === 'border' ? '-width' : ''))),
						left: num(this.css(name + '-left' + (name === 'border' ? '-width' : ''))),
						right: num(this.css(name + '-right' + (name === 'border' ? '-width' : '')))};
			}
		};
	});
})(jQuery);

jQuery.toasterSetting = {
  timeout : 3000, // timeout to close the toast
  title : '', // title of the toast
  text : '', // text of the toast
  animationSpeed : 500, // animationSpeed to popup a toast
  position : 'br', // br, bl, tr, tl
  cssclass : '', // additional class for the toast
  onlyone : false, // only one of this toast can appear at the same time
  base : 'body', // base of the toaster area
  closable : false, // is the toast cloasable
  onclose : false, // callback function when the toast cloases:
                    // callback(cssIdOfTheToast)
  oncreate : false
// callback that is called after creation of the toast:
// callback(cssIdOfTheToast)
};

if(!Array.indexOf) {
  Array.prototype.indexOf = function( el ){

    for( var i = 0; i < this.length; i++ )
      if(el == this[i])
        return i;
  }
}

/**
 * @author holzhauer
 */
jQuery.toaster = function( settings ){

  settings = jQuery.extend(jQuery.toasterSetting, settings);

  if(settings.timeout == 0) {
    settings.closable = true;
  }

  var msgId = 'toast' + Math.floor(Math.random() * 1000000);

  this.toasterMsgCounter = this.toasterMsgCounter || new Array();
  this.toasterMsgCounter[settings.base] = this.toasterMsgCounter[settings.base]
      || new Array();
  this.toasterMsgCounter[settings.base][settings.position] = this.toasterMsgCounter[settings.base][settings.position]
      || new Array();

  this.toasterMsgCounter[settings.base][settings.position].push(msgId);

  if(jQuery(settings.base + ' > .ui-toaster-area-' + settings.position).length == 0) {
    var toasterArea = '<div class="ui-toaster-area-' + settings.position
        + '"></div>';
    jQuery(settings.base).append(toasterArea);
  }

  if(settings.onlyone == false
      || (settings.onlyone == true && jQuery(settings.base
          + ' > div.ui-toaster-area-' + settings.position + ' div.ui-toaster').length == 0)) {
    var html = '<div class="ui-toaster ' + settings.cssclass + '" id="' + msgId
        + '">';

    if(settings.closable == true) {
      html += '<span title="Close" class="ui-toaster-close">X</span>';
    }

    if(!!settings.title) {
      html += '<h4 class="ui-toaster-title">' + settings.title + '</h4>';
    }

    html += '<p class="ui-toaster-content">' + settings.text + '</p>';
    html = jQuery(html);

    if(settings.position == 'bl' || settings.position == 'br') {
      jQuery(settings.base + ' > .ui-toaster-area-' + settings.position)
          .prepend(html);
    }
    else
      if(settings.position == 'tl' || settings.position == 'tr') {
        jQuery(settings.base + ' > .ui-toaster-area-' + settings.position)
            .append(html);
      }

    html.slideDown(settings.animationSpeed);

    // call onCreate callback
    if(typeof settings.oncreate == 'function') {
      settings.oncreate(msgId);
    }

    // create the close function
    var closeFunction = function(){

      jQuery('#' + msgId).slideUp(settings.animationSpeed, function(){

        jQuery('#' + msgId).remove();
      });
      if(typeof settings.onclose == 'function') {
        settings.onclose(msgId);
      }
    }

    // add close function to the "X"
    if(settings.closable == true) {
      jQuery('#' + msgId + ' span.ui-toaster-close').click(function(){

        closeFunction();
      });
    }

    // add the timeout to the toast
    if(settings.timeout > 0) {
      var beforeId = this.toasterMsgCounter[settings.base][settings.position]
          .indexOf(msgId);
      var before = this.toasterMsgCounter[settings.base][settings.position][(beforeId - 1)];

      var timedCloseFunction = function(){

        if(before == undefined || jQuery('#' + before).length == 0) {
          closeFunction();
        }
        else {
          window.setTimeout(timedCloseFunction, settings.timeout);
        }
      }

      window.setTimeout(timedCloseFunction, settings.timeout);
    }
  }
};

(function($,$C){

  $.monthpicker={}
  
  $.monthpicker.defaults={ buttonImage:'calendar.png'};
  $.monthpicker.options={};
  
  // container erstellen
  $.monthpicker.createContainer = function(pos)
  {
    var container=jQuery('<div id="ui-monthpicker-div" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all ui-helper-hidden-accessible" style="position: absolute; top:'+pos.top+'px; left: '+pos.left+'px; display: none; text-align:center; z-index:10"></div>');
    $('body').append(container);
    $(document).mousedown($.monthpicker.doCheckMouseClick);
  };

  // controll element erstellen
  $.monthpicker.createControl = function( selectedmonth, selectedyear, input )
  {
		
    var container = $("#ui-monthpicker-div");
    var t = input.offset().top + input.outerHeight();
    var l = input.offset().left;
    container.css({'top':t,'left':l});
    container.html('');
    
    var head=$('<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix ui-corner-all"></div>');

    var in_val = $.trim(input.val());
    var actualDate = null;
     
    if( in_val != '' )
    {
      //in_val = in_val.split($C.dateSep || '-');
      try
      {
        actualDate = $.datepicker.parseDate( $C.formatDate, in_val+'-01' );
  	  
        selectedmonth    = actualDate.getMonth()+1;
        selectedyear     = actualDate.getFullYear();
      }
      catch( e )
      {
        //$D.errorWindow( "UI Error", e );
      }
		
	 /*
	  if( in_val[1] != '' ) 
	    selectedmonth = parseFloat( in_val[1] );
	  
	  if( in_val[0] != '' ) 
	    selectedyear = parseFloat( in_val[0] );
	 */
    }
    
    // implementierung eines start und endes
    var name = input.attr('name');
    var start_input = input.parent().find('[name=start_'+name+']');
    var end_input = input.parent().find('[name=end_'+name+']');
    
    if( start_input.length == 0 )
    {
      var start_y = selectedyear-10;
      var start_m = 1;
    }
    else
    {   
      var start = start_input.val();
      start=start.split('_');
      var start_y = parseFloat(start[0]);
      var start_m = parseFloat(start[1]);
    }
    
    if( end_input.length == 0 )
    {
      var end_y = selectedyear+10;
      var end_m = 1;
    }
    else
    {
      var end = end_input.val();
      end = end.split('_');
      var end_y = parseFloat(end[0]);
      var end_m = parseFloat(end[1]);
    }
                 
    var year_select=$('<select class="ui-datepicker-year" onclick="" onchange=""></style>');
	
    year_select.bind('change',function()
    {
      $.monthpicker.refreshMonths( container, input );
    });
    
    var x=start_y;
    var opt=null;
    var tr=null;
    var td=null;
    var a=null;
	
    while( x <= end_y )
    {  
      opt=$("<option value="+x+">"+x+"</option>");
      
      if(x==selectedyear)
        opt.attr("selected","selected");
	 
      year_select.append(opt);
	 x++;
    }
	
    head.append(year_select);
	
    var month_select = $( '<table class="ui-datepicker-calendar" style="margin-top:0.2em"><tbody></tbody></table>' );
    var months = new Array( "","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec" );
    var r = 1;
    var c = 1;
    var m = 1;
	
    while(r<=3)
    {
      tr=$("<tr></tr>");
      c=1;
      while(c<=4)
      {
			
        td=$('<td class="month'+m+'" onclick=""></td>');
        if((selectedyear == start_y && m < start_m)||(selectedyear == end_y && m > end_m))
        {
          a=$('<a class="ui-state-disable" href="#">'+months[m]+'</a>');
        }
        else
        {
  
          a=$('<a class="ui-state-default" href="#">'+months[m]+'</a>');
          a.bind('mouseout', function()
          {
            $(this).removeClass('ui-state-hover');	
          })
          .bind('mouseover', function()
          {
            $(this).addClass('ui-state-hover');
          })
          .bind('click',function()
          {
            var month=$(this).parent().prop('class');
            month = month.replace('month','');
            
            var year = $('.ui-datepicker-year').val();
            input.val( $.datepicker.formatDate( $C.formatDateMonth, new Date(year,(month-1),1)  ));
            $.monthpicker.deleteControl();
					      
          });
        }
			
        if( m==selectedmonth ) 
          a.addClass("ui-state-active"); 
			
        tr.append(td.append(a));
        c++;
        m++;
      }
      
      month_select.append(tr);
      r++;
    }
    
    container.append(head);
    container.append(month_select);

	
  };

  $.monthpicker.deleteControl=function()
  {
    $('#ui-monthpicker-div').hide();
  };

  $.monthpicker.doCheckMouseClick = function(e) 
  {
    if (!$('#ui-monthpicker-div:visible').length) 
    {
      return;
    }
    if (!$(e.target).closest('#ui-monthpicker-div').length)
    {
      $.monthpicker.deleteControl();
    }
  };

  $.monthpicker.refreshMonths = function( container, input )
  {
    //var container=$("#ui-monthpicker-div");
    var selectedyear = container.find('.ui-datepicker-year').val();

    
    var actualDate = null;
    var selectedmonth = null;
    var in_val = input.val();
     
    if( in_val != '' )
    {
      actualDate    = $.datepicker.parseDate( $C.formatDate, in_val+'-01' );
      selectedmonth = actualDate.getMonth()+1; 
      
    }
	
    var name = input.attr( 'name' );
    var start_input = input.parent().find( '[name=start_'+name+']' );
    var end_input = input.parent().find( '[name=end_'+name+']' );
    
      if( start_input.length == 0 )
      {
        var start_y = selectedyear-10;
        var start_m = 1;
      }
      else
      {   
         var start = start_input.val();
      	start = start.split( '_' );
      	var start_y = parseFloat( start[0] );
         var start_m = parseFloat( start[1] );
      }
      
      if( end_input.length == 0 )
      {
        var end_y = selectedyear+10;
        var end_m = 1;
      }
      else
      {
         var end = end_input.val();
         end = end.split( '_' );
         var end_y = parseFloat( end[0] );
         var end_m = parseFloat( end[1] );
      }
    
	var month_select = container.find('.ui-datepicker-calendar');
	month_select.html('');
	var months= new Array("","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec");
	var r=1;
	var c=1;
	var m=1;
	
	while(r<=3)
	{
		tr=$("<tr></tr>");
		c=1;
		while(c<=4)
		{
			
			td=$('<td class="month'+m+'" onclick=""></td>');
			if((selectedyear == start_y && m < start_m)||(selectedyear == end_y && m > end_m))
			{
				a=$('<a class="ui-state-disable" href="#">'+months[m]+'</a>');
			}
			else
			{
		    
				a=$('<a class="ui-state-default" href="#">'+months[m]+'</a>');
				a.bind('mouseout', function(){
					$(this).removeClass('ui-state-hover');	
				})
				.bind('mouseover', function()
						{
						$(this).addClass('ui-state-hover');
				})
		          .bind('click',function()
		          {
		            var month=$(this).parent().prop('class');
		            month = month.replace('month','');
		                
		            var year = $('.ui-datepicker-year').val();
		            input.val( $.datepicker.formatDate( $C.formatDateMonth, new Date(year,(month-1),1)  ));
		            $.monthpicker.deleteControl();
		                                   
		          });
			}
			
			if( m==selectedmonth ) 
			  a.addClass("ui-state-active"); 
			
			tr.append(td.append(a));
			c++;
			m++;
		}
		
		month_select.append(tr);
		r++;
	}
     //container.find('table').html(month_select);

  };
  
  // die eigentliche funtion
  $.fn.monthpicker = function( opt )
  {
    
    $.monthpicker.options = $.extend({}, $.monthpicker.defaults, opt);
    var myDate = new Date();
    var month = myDate.getMonth() + 1;
    var year =  myDate.getFullYear();
  	
    return this.each(function()  {
      	
      var input = $(this);
      
      var inpVal = $.trim(input.val());
      
      if( '' != inpVal )
      {
        try
        {
          input.val( $.datepicker.formatDate( $C.formatDateMonth, $.datepicker.parseDate(  $C.formatDate, inpVal+'-01'  ) ) );
        }
        catch( e )
        {
          $D.errorWindow( "Failed to set Monthpicker value", e );
        }
      }
      
      var t = input.offset().top + input.outerHeight();
      var l = input.offset().left;
    /*  var button_image=$('<img class="ui-month-picker-trigger" src="'+$.monthpicker.options.buttonImage+'" ></img>');
      
      button_image.bind( 'click', function()
      { 
        $.monthpicker.createControl( month, year, input ); 
        $('#ui-monthpicker-div').animate({width:'show',height:'show'},'fast'); 
      });
      
      input.after(button_image); */
      
      if( !$('#ui-monthpicker-div').length )
        $.monthpicker.createContainer({'top':t,'left':l});	
      
    });
    
  };


})(jQuery,$C);

/*
jQuery(document).ready(function(){



    jQuery('.inputmonth').monthpicker().removeClass('.inputmonth');
 
    

    
/*
    jQuery('#ui-monthpicker-div .ui-datepicker-year option')
    			.each(function()
    	    		{
    	    		if($(this).val()==year)
        	    		$(this).attr("selected","selected");
        			});

	jQuery('#ui-monthpicker-div .ui-datepicker-calendar .month'+month+' a').addClass("ui-state-highlight");
				
    	*/		
    
	
/*		
});
*/
/*
 * jQuery.appear
 * http://code.google.com/p/jquery-appear/
 * 
 * @version 1.1.1
 *
 * Copyright (c) 2009 Michael Hixson
 * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
*/
(function($) {
  
  $.fn.appear = function(fn, options) {
    
    var settings = $.extend({

      //arbitrary data to pass to fn
      data: undefined,

      //call fn only on the first appear?
      one: true 
      
    }, options);
    
    return this.each(function() {
    
      var t = $(this);
      
      //whether the element is currently visible
      t.appeared = false;
      
      if (!fn) {

        //trigger the custom event
        t.trigger('appear', settings.data);
        return;
      }
      
      var w = $(window);
      
      //fires the appear event when appropriate
      var check = function() {

        //is the element hidden?
        if (!t.is(':visible')) {
          
          //it became hidden
          t.appeared = false;
          return;
        }

        //is the element inside the visible window?
        var a = w.scrollLeft();
        var b = w.scrollTop();
        var o = t.offset();
        var x = o.left;
        var y = o.top;
        
        if (y + t.height() >= b && 
            y <= b + w.height() &&
            x + t.width() >= a && 
            x <= a + w.width()) {

          //trigger the custom event
          if (!t.appeared) t.trigger('appear', settings.data);
          
        } else {

          //it scrolled out of view
          t.appeared = false;
        }
      };

      //create a modified fn with some additional logic
      var modifiedFn = function() {
        
        //mark the element as visible
        t.appeared = true;

        //is this supposed to happen only once?
        if (settings.one) {

          //remove the check
          w.unbind('scroll', check);
          var i = $.inArray(check, $.fn.appear.checks);
          if (i >= 0) $.fn.appear.checks.splice(i, 1);
        }

        //trigger the original fn
        fn.apply(this, arguments);
      };
      
      //bind the modified fn to the element
      if (settings.one) t.one('appear', settings.data, modifiedFn);
      else t.bind('appear', settings.data, modifiedFn);
      
      //check whenever the window scrolls
      w.scroll(check);
      
      //check whenever the dom changes
      $.fn.appear.checks.push(check);
      
      //check now
      (check)();
    });
  };
  
  //keep a queue of appearance checks
  $.extend($.fn.appear, {
    
    checks: [],
    timeout: null,

    //process the queue
    checkAll: function() {
      var length = $.fn.appear.checks.length;
      if (length > 0) while (length--) ($.fn.appear.checks[length])();
    },

    //check the queue asynchronously
    run: function() {
      if ($.fn.appear.timeout) clearTimeout($.fn.appear.timeout);
      $.fn.appear.timeout = setTimeout($.fn.appear.checkAll, 20);
    }
  });
  
  //run checks when these methods are called
  $.each(['append', 'prepend', 'after', 'before', 'attr', 
          'removeAttr', 'addClass', 'removeClass', 'toggleClass', 
          'remove', 'css', 'show', 'hide'], function(i, n) {
    var old = $.fn[n];
    if (old) {
      $.fn[n] = function() {
        var r = old.apply(this, arguments);
        $.fn.appear.run();
        return r;
      }
    }
  });
  
})(jQuery);
/**
 * @preserve
 * FullCalendar v1.5.2
 * http://arshaw.com/fullcalendar/
 *
 * Use fullcalendar.css for basic styling.
 * For event drag & drop, requires jQuery UI draggable.
 * For event resizing, requires jQuery UI resizable.
 *
 * Copyright (c) 2011 Adam Shaw
 * Dual licensed under the MIT and GPL licenses, located in
 * MIT-LICENSE.txt and GPL-LICENSE.txt respectively.
 *
 * Date: Sun Aug 21 22:06:09 2011 -0700
 *
 */
 
(function($, undefined) {


var defaults = {

	// display
	defaultView: 'month',
	aspectRatio: 1.35,
	header: {
		left: 'title',
		center: '',
		right: 'today prev,next'
	},
	weekends: true,
	
	// editing
	//editable: false,
	//disableDragging: false,
	//disableResizing: false,
	
	allDayDefault: true,
	ignoreTimezone: true,
	
	// event ajax
	lazyFetching: true,
	startParam: 'start',
	endParam: 'end',
	
	// time formats
	titleFormat: {
		month: 'MMMM yyyy',
		week: "MMM d[ yyyy]{ '&#8212;'[ MMM] d yyyy}",
		day: 'dddd, MMM d, yyyy'
	},
	columnFormat: {
		month: 'ddd',
		week: 'ddd M/d',
		day: 'dddd M/d'
	},
	timeFormat: { // for event elements
		'': 'h(:mm)t' // default
	},
	
	// locale
	isRTL: false,
	firstDay: 0,
	monthNames: ['January','February','March','April','May','June','July','August','September','October','November','December'],
	monthNamesShort: ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
	dayNames: ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
	dayNamesShort: ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
	buttonText: {
		prev: '&nbsp;&#9668;&nbsp;',
		next: '&nbsp;&#9658;&nbsp;',
		prevYear: '&nbsp;&lt;&lt;&nbsp;',
		nextYear: '&nbsp;&gt;&gt;&nbsp;',
		today: 'today',
		month: 'month',
		week: 'week',
		day: 'day'
	},
	
	// jquery-ui theming
	theme: false,
	buttonIcons: {
		prev: 'circle-triangle-w',
		next: 'circle-triangle-e'
	},
	
	//selectable: false,
	unselectAuto: true,
	
	dropAccept: '*'
	
};

// right-to-left defaults
var rtlDefaults = {
	header: {
		left: 'next,prev today',
		center: '',
		right: 'title'
	},
	buttonText: {
		prev: '&nbsp;&#9658;&nbsp;',
		next: '&nbsp;&#9668;&nbsp;',
		prevYear: '&nbsp;&gt;&gt;&nbsp;',
		nextYear: '&nbsp;&lt;&lt;&nbsp;'
	},
	buttonIcons: {
		prev: 'circle-triangle-e',
		next: 'circle-triangle-w'
	}
};



var fc = $.fullCalendar = { version: "1.5.2" };
var fcViews = fc.views = {};


$.fn.fullCalendar = function(options) {


	// method calling
	if (typeof options == 'string') {
		var args = Array.prototype.slice.call(arguments, 1);
		var res;
		this.each(function() {
			var calendar = $.data(this, 'fullCalendar');
			if (calendar && $.isFunction(calendar[options])) {
				var r = calendar[options].apply(calendar, args);
				if (res === undefined) {
					res = r;
				}
				if (options == 'destroy') {
					$.removeData(this, 'fullCalendar');
				}
			}
		});
		if (res !== undefined) {
			return res;
		}
		return this;
	}
	
	
	// would like to have this logic in EventManager, but needs to happen before options are recursively extended
	var eventSources = options.eventSources || [];
	delete options.eventSources;
	if (options.events) {
		eventSources.push(options.events);
		delete options.events;
	}
	

	options = $.extend(true, {},
		defaults,
		(options.isRTL || options.isRTL===undefined && defaults.isRTL) ? rtlDefaults : {},
		options
	);
	
	
	this.each(function(i, _element) {
		var element = $(_element);
		var calendar = new Calendar(element, options, eventSources);
		element.data('fullCalendar', calendar); // TODO: look into memory leak implications
		calendar.render();
	});
	
	
	return this;
	
};


// function for adding/overriding defaults
function setDefaults(d) {
	$.extend(true, defaults, d);
}



 
function Calendar(element, options, eventSources) {
	var t = this;
	
	
	// exports
	t.options = options;
	t.render = render;
	t.destroy = destroy;
	t.refetchEvents = refetchEvents;
	t.reportEvents = reportEvents;
	t.reportEventChange = reportEventChange;
	t.rerenderEvents = rerenderEvents;
	t.changeView = changeView;
	t.select = select;
	t.unselect = unselect;
	t.prev = prev;
	t.next = next;
	t.prevYear = prevYear;
	t.nextYear = nextYear;
	t.today = today;
	t.gotoDate = gotoDate;
	t.incrementDate = incrementDate;
	t.formatDate = function(format, date) { return formatDate(format, date, options) };
	t.formatDates = function(format, date1, date2) { return formatDates(format, date1, date2, options) };
	t.getDate = getDate;
	t.getView = getView;
	t.option = option;
	t.trigger = trigger;
	
	
	// imports
	EventManager.call(t, options, eventSources);
	var isFetchNeeded = t.isFetchNeeded;
	var fetchEvents = t.fetchEvents;
	
	
	// locals
	var _element = element[0];
	var header;
	var headerElement;
	var content;
	var tm; // for making theme classes
	var currentView;
	var viewInstances = {};
	var elementOuterWidth;
	var suggestedViewHeight;
	var absoluteViewElement;
	var resizeUID = 0;
	var ignoreWindowResize = 0;
	var date = new Date();
	var events = [];
	var _dragElement;
	
	
	
	/* Main Rendering
	-----------------------------------------------------------------------------*/
	
	
	setYMD(date, options.year, options.month, options.date);
	
	
	function render(inc) {
		if (!content) {
			initialRender();
		}else{
			calcSize();
			markSizesDirty();
			markEventsDirty();
			renderView(inc);
		}
	}
	
	
	function initialRender() {
		tm = options.theme ? 'ui' : 'fc';
		element.addClass('fc');
		if (options.isRTL) {
			element.addClass('fc-rtl');
		}
		if (options.theme) {
			element.addClass('ui-widget');
		}
		content = $("<div class='fc-content' style='position:relative'/>")
			.prependTo(element);
		header = new Header(t, options);
		headerElement = header.render();
		if (headerElement) {
			element.prepend(headerElement);
		}
		changeView(options.defaultView);
		$(window).resize(windowResize);
		// needed for IE in a 0x0 iframe, b/c when it is resized, never triggers a windowResize
		if (!bodyVisible()) {
			lateRender();
		}
	}
	
	
	// called when we know the calendar couldn't be rendered when it was initialized,
	// but we think it's ready now
	function lateRender() {
		setTimeout(function() { // IE7 needs this so dimensions are calculated correctly
			if (!currentView.start && bodyVisible()) { // !currentView.start makes sure this never happens more than once
				renderView();
			}
		},0);
	}
	
	
	function destroy() {
		$(window).unbind('resize', windowResize);
		header.destroy();
		content.remove();
		element.removeClass('fc fc-rtl ui-widget');
	}
	
	
	
	function elementVisible() {
		return _element.offsetWidth !== 0;
	}
	
	
	function bodyVisible() {
		return $('body')[0].offsetWidth !== 0;
	}
	
	
	
	/* View Rendering
	-----------------------------------------------------------------------------*/
	
	// TODO: improve view switching (still weird transition in IE, and FF has whiteout problem)
	
	function changeView(newViewName) {
		if (!currentView || newViewName != currentView.name) {
			ignoreWindowResize++; // because setMinHeight might change the height before render (and subsequently setSize) is reached

			unselect();
			
			var oldView = currentView;
			var newViewElement;
				
			if (oldView) {
				(oldView.beforeHide || noop)(); // called before changing min-height. if called after, scroll state is reset (in Opera)
				setMinHeight(content, content.height());
				oldView.element.hide();
			}else{
				setMinHeight(content, 1); // needs to be 1 (not 0) for IE7, or else view dimensions miscalculated
			}
			content.css('overflow', 'hidden');
			
			currentView = viewInstances[newViewName];
			if (currentView) {
				currentView.element.show();
			}else{
				currentView = viewInstances[newViewName] = new fcViews[newViewName](
					newViewElement = absoluteViewElement =
						$("<div class='fc-view fc-view-" + newViewName + "' style='position:absolute'/>")
							.appendTo(content),
					t // the calendar object
				);
			}
			
			if (oldView) {
				header.deactivateButton(oldView.name);
			}
			header.activateButton(newViewName);
			
			renderView(); // after height has been set, will make absoluteViewElement's position=relative, then set to null
			
			content.css('overflow', '');
			if (oldView) {
				setMinHeight(content, 1);
			}
			
			if (!newViewElement) {
				(currentView.afterShow || noop)(); // called after setting min-height/overflow, so in final scroll state (for Opera)
			}
			
			ignoreWindowResize--;
		}
	}
	
	
	
	function renderView(inc) {
		if (elementVisible()) {
			ignoreWindowResize++; // because renderEvents might temporarily change the height before setSize is reached

			unselect();
			
			if (suggestedViewHeight === undefined) {
				calcSize();
			}
			
			var forceEventRender = false;
			if (!currentView.start || inc || date < currentView.start || date >= currentView.end) {
				// view must render an entire new date range (and refetch/render events)
				currentView.render(date, inc || 0); // responsible for clearing events
				setSize(true);
				forceEventRender = true;
			}
			else if (currentView.sizeDirty) {
				// view must resize (and rerender events)
				currentView.clearEvents();
				setSize();
				forceEventRender = true;
			}
			else if (currentView.eventsDirty) {
				currentView.clearEvents();
				forceEventRender = true;
			}
			currentView.sizeDirty = false;
			currentView.eventsDirty = false;
			updateEvents(forceEventRender);
			
			elementOuterWidth = element.outerWidth();
			
			header.updateTitle(currentView.title);
			var today = new Date();
			if (today >= currentView.start && today < currentView.end) {
				header.disableButton('today');
			}else{
				header.enableButton('today');
			}
			
			ignoreWindowResize--;
			currentView.trigger('viewDisplay', _element);
		}
	}
	
	
	
	/* Resizing
	-----------------------------------------------------------------------------*/
	
	
	function updateSize() {
		markSizesDirty();
		if (elementVisible()) {
			calcSize();
			setSize();
			unselect();
			currentView.clearEvents();
			currentView.renderEvents(events);
			currentView.sizeDirty = false;
		}
	}
	
	
	function markSizesDirty() {
		$.each(viewInstances, function(i, inst) {
			inst.sizeDirty = true;
		});
	}
	
	
	function calcSize() {
		if (options.contentHeight) {
			suggestedViewHeight = options.contentHeight;
		}
		else if (options.height) {
			suggestedViewHeight = options.height - (headerElement ? headerElement.height() : 0) - vsides(content);
		}
		else {
			suggestedViewHeight = Math.round(content.width() / Math.max(options.aspectRatio, .5));
		}
	}
	
	
	function setSize(dateChanged) { // todo: dateChanged?
		ignoreWindowResize++;
		currentView.setHeight(suggestedViewHeight, dateChanged);
		if (absoluteViewElement) {
			absoluteViewElement.css('position', 'relative');
			absoluteViewElement = null;
		}
		currentView.setWidth(content.width(), dateChanged);
		ignoreWindowResize--;
	}
	
	
	function windowResize() {
		if (!ignoreWindowResize) {
			if (currentView.start) { // view has already been rendered
				var uid = ++resizeUID;
				setTimeout(function() { // add a delay
					if (uid == resizeUID && !ignoreWindowResize && elementVisible()) {
						if (elementOuterWidth != (elementOuterWidth = element.outerWidth())) {
							ignoreWindowResize++; // in case the windowResize callback changes the height
							updateSize();
							currentView.trigger('windowResize', _element);
							ignoreWindowResize--;
						}
					}
				}, 200);
			}else{
				// calendar must have been initialized in a 0x0 iframe that has just been resized
				lateRender();
			}
		}
	}
	
	
	
	/* Event Fetching/Rendering
	-----------------------------------------------------------------------------*/
	
	
	// fetches events if necessary, rerenders events if necessary (or if forced)
	function updateEvents(forceRender) {
		if (!options.lazyFetching || isFetchNeeded(currentView.visStart, currentView.visEnd)) {
			refetchEvents();
		}
		else if (forceRender) {
			rerenderEvents();
		}
	}
	
	
	function refetchEvents() {
		fetchEvents(currentView.visStart, currentView.visEnd); // will call reportEvents
	}
	
	
	// called when event data arrives
	function reportEvents(_events) {
		events = _events;
		rerenderEvents();
	}
	
	
	// called when a single event's data has been changed
	function reportEventChange(eventID) {
		rerenderEvents(eventID);
	}
	
	
	// attempts to rerenderEvents
	function rerenderEvents(modifiedEventID) {
		markEventsDirty();
		if (elementVisible()) {
			currentView.clearEvents();
			currentView.renderEvents(events, modifiedEventID);
			currentView.eventsDirty = false;
		}
	}
	
	
	function markEventsDirty() {
		$.each(viewInstances, function(i, inst) {
			inst.eventsDirty = true;
		});
	}
	


	/* Selection
	-----------------------------------------------------------------------------*/
	

	function select(start, end, allDay) {
		currentView.select(start, end, allDay===undefined ? true : allDay);
	}
	

	function unselect() { // safe to be called before renderView
		if (currentView) {
			currentView.unselect();
		}
	}
	
	
	
	/* Date
	-----------------------------------------------------------------------------*/
	
	
	function prev() {
		renderView(-1);
	}
	
	
	function next() {
		renderView(1);
	}
	
	
	function prevYear() {
		addYears(date, -1);
		renderView();
	}
	
	
	function nextYear() {
		addYears(date, 1);
		renderView();
	}
	
	
	function today() {
		date = new Date();
		renderView();
	}
	
	
	function gotoDate(year, month, dateOfMonth) {
		if (year instanceof Date) {
			date = cloneDate(year); // provided 1 argument, a Date
		}else{
			setYMD(date, year, month, dateOfMonth);
		}
		renderView();
	}
	
	
	function incrementDate(years, months, days) {
		if (years !== undefined) {
			addYears(date, years);
		}
		if (months !== undefined) {
			addMonths(date, months);
		}
		if (days !== undefined) {
			addDays(date, days);
		}
		renderView();
	}
	
	
	function getDate() {
		return cloneDate(date);
	}
	
	
	
	/* Misc
	-----------------------------------------------------------------------------*/
	
	
	function getView() {
		return currentView;
	}
	
	
	function option(name, value) {
		if (value === undefined) {
			return options[name];
		}
		if (name == 'height' || name == 'contentHeight' || name == 'aspectRatio') {
			options[name] = value;
			updateSize();
		}
	}
	
	
	function trigger(name, thisObj) {
		if (options[name]) {
			return options[name].apply(
				thisObj || _element,
				Array.prototype.slice.call(arguments, 2)
			);
		}
	}
	
	
	
	/* External Dragging
	------------------------------------------------------------------------*/
	
	if (options.droppable) {
		$(document)
			.bind('dragstart', function(ev, ui) {
				var _e = ev.target;
				var e = $(_e);
				if (!e.parents('.fc').length) { // not already inside a calendar
					var accept = options.dropAccept;
					if ($.isFunction(accept) ? accept.call(_e, e) : e.is(accept)) {
						_dragElement = _e;
						currentView.dragStart(_dragElement, ev, ui);
					}
				}
			})
			.bind('dragstop', function(ev, ui) {
				if (_dragElement) {
					currentView.dragStop(_dragElement, ev, ui);
					_dragElement = null;
				}
			});
	}
	

}

function Header(calendar, options) {
	var t = this;
	
	
	// exports
	t.render = render;
	t.destroy = destroy;
	t.updateTitle = updateTitle;
	t.activateButton = activateButton;
	t.deactivateButton = deactivateButton;
	t.disableButton = disableButton;
	t.enableButton = enableButton;
	
	
	// locals
	var element = $([]);
	var tm;
	


	function render() {
		tm = options.theme ? 'ui' : 'fc';
		var sections = options.header;
		if (sections) {
			element = $("<table class='fc-header' style='width:100%'/>")
				.append(
					$("<tr/>")
						.append(renderSection('left'))
						.append(renderSection('center'))
						.append(renderSection('right'))
				);
			return element;
		}
	}
	
	
	function destroy() {
		element.remove();
	}
	
	
	function renderSection(position) {
		var e = $("<td class='fc-header-" + position + "'/>");
		var buttonStr = options.header[position];
		if (buttonStr) {
			$.each(buttonStr.split(' '), function(i) {
				if (i > 0) {
					e.append("<span class='fc-header-space'/>");
				}
				var prevButton;
				$.each(this.split(','), function(j, buttonName) {
					if (buttonName == 'title') {
						e.append("<span class='fc-header-title'><h2>&nbsp;</h2></span>");
						if (prevButton) {
							prevButton.addClass(tm + '-corner-right');
						}
						prevButton = null;
					}else{
						var buttonClick;
						if (calendar[buttonName]) {
							buttonClick = calendar[buttonName]; // calendar method
						}
						else if (fcViews[buttonName]) {
							buttonClick = function() {
								button.removeClass(tm + '-state-hover'); // forget why
								calendar.changeView(buttonName);
							};
						}
						if (buttonClick) {
							var icon = options.theme ? smartProperty(options.buttonIcons, buttonName) : null; // why are we using smartProperty here?
							var text = smartProperty(options.buttonText, buttonName); // why are we using smartProperty here?
							var button = $(
								"<span class='fc-button fc-button-" + buttonName + " " + tm + "-state-default'>" +
									"<span class='fc-button-inner'>" +
										"<span class='fc-button-content'>" +
											(icon ?
												"<span class='fc-icon-wrap'>" +
													"<span class='ui-icon ui-icon-" + icon + "'/>" +
												"</span>" :
												text
												) +
										"</span>" +
										"<span class='fc-button-effect'><span></span></span>" +
									"</span>" +
								"</span>"
							);
							if (button) {
								button
									.click(function() {
										if (!button.hasClass(tm + '-state-disabled')) {
											buttonClick();
										}
									})
									.mousedown(function() {
										button
											.not('.' + tm + '-state-active')
											.not('.' + tm + '-state-disabled')
											.addClass(tm + '-state-down');
									})
									.mouseup(function() {
										button.removeClass(tm + '-state-down');
									})
									.hover(
										function() {
											button
												.not('.' + tm + '-state-active')
												.not('.' + tm + '-state-disabled')
												.addClass(tm + '-state-hover');
										},
										function() {
											button
												.removeClass(tm + '-state-hover')
												.removeClass(tm + '-state-down');
										}
									)
									.appendTo(e);
								if (!prevButton) {
									button.addClass(tm + '-corner-left');
								}
								prevButton = button;
							}
						}
					}
				});
				if (prevButton) {
					prevButton.addClass(tm + '-corner-right');
				}
			});
		}
		return e;
	}
	
	
	function updateTitle(html) {
		element.find('h2')
			.html(html);
	}
	
	
	function activateButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.addClass(tm + '-state-active');
	}
	
	
	function deactivateButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.removeClass(tm + '-state-active');
	}
	
	
	function disableButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.addClass(tm + '-state-disabled');
	}
	
	
	function enableButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.removeClass(tm + '-state-disabled');
	}


}

fc.sourceNormalizers = [];
fc.sourceFetchers = [];

var ajaxDefaults = {
	dataType: 'json',
	cache: false
};

var eventGUID = 1;


function EventManager(options, _sources) {
	var t = this;
	
	
	// exports
	t.isFetchNeeded = isFetchNeeded;
	t.fetchEvents = fetchEvents;
	t.addEventSource = addEventSource;
	t.removeEventSource = removeEventSource;
	t.updateEvent = updateEvent;
	t.renderEvent = renderEvent;
	t.removeEvents = removeEvents;
	t.clientEvents = clientEvents;
	t.normalizeEvent = normalizeEvent;
	
	
	// imports
	var trigger = t.trigger;
	var getView = t.getView;
	var reportEvents = t.reportEvents;
	
	
	// locals
	var stickySource = { events: [] };
	var sources = [ stickySource ];
	var rangeStart, rangeEnd;
	var currentFetchID = 0;
	var pendingSourceCnt = 0;
	var loadingLevel = 0;
	var cache = [];
	
	
	for (var i=0; i<_sources.length; i++) {
		_addEventSource(_sources[i]);
	}
	
	
	
	/* Fetching
	-----------------------------------------------------------------------------*/
	
	
	function isFetchNeeded(start, end) {
		return !rangeStart || start < rangeStart || end > rangeEnd;
	}
	
	
	function fetchEvents(start, end) {
		rangeStart = start;
		rangeEnd = end;
		cache = [];
		var fetchID = ++currentFetchID;
		var len = sources.length;
		pendingSourceCnt = len;
		for (var i=0; i<len; i++) {
			fetchEventSource(sources[i], fetchID);
		}
	}
	
	
	function fetchEventSource(source, fetchID) {
		_fetchEventSource(source, function(events) {
			if (fetchID == currentFetchID) {
				if (events) {
					for (var i=0; i<events.length; i++) {
						events[i].source = source;
						normalizeEvent(events[i]);
					}
					cache = cache.concat(events);
				}
				pendingSourceCnt--;
				if (!pendingSourceCnt) {
					reportEvents(cache);
				}
			}
		});
	}
	
	
	function _fetchEventSource(source, callback) {
		var i;
		var fetchers = fc.sourceFetchers;
		var res;
		for (i=0; i<fetchers.length; i++) {
			res = fetchers[i](source, rangeStart, rangeEnd, callback);
			if (res === true) {
				// the fetcher is in charge. made its own async request
				return;
			}
			else if (typeof res == 'object') {
				// the fetcher returned a new source. process it
				_fetchEventSource(res, callback);
				return;
			}
		}
		var events = source.events;
		if (events) {
			if ($.isFunction(events)) {
				pushLoading();
				events(cloneDate(rangeStart), cloneDate(rangeEnd), function(events) {
					callback(events);
					popLoading();
				});
			}
			else if ($.isArray(events)) {
				callback(events);
			}
			else {
				callback();
			}
		}else{
			var url = source.url;
			if (url) {
				var success = source.success;
				var error = source.error;
				var complete = source.complete;
				var data = $.extend({}, source.data || {});
				var startParam = firstDefined(source.startParam, options.startParam);
				var endParam = firstDefined(source.endParam, options.endParam);
				if (startParam) {
					data[startParam] = Math.round(+rangeStart / 1000);
				}
				if (endParam) {
					data[endParam] = Math.round(+rangeEnd / 1000);
				}
				pushLoading();
				$.ajax($.extend({}, ajaxDefaults, source, {
					data: data,
					success: function(events) {
						events = events || [];
						var res = applyAll(success, this, arguments);
						if ($.isArray(res)) {
							events = res;
						}
						callback(events);
					},
					error: function() {
						applyAll(error, this, arguments);
						callback();
					},
					complete: function() {
						applyAll(complete, this, arguments);
						popLoading();
					}
				}));
			}else{
				callback();
			}
		}
	}
	
	
	
	/* Sources
	-----------------------------------------------------------------------------*/
	

	function addEventSource(source) {
		source = _addEventSource(source);
		if (source) {
			pendingSourceCnt++;
			fetchEventSource(source, currentFetchID); // will eventually call reportEvents
		}
	}
	
	
	function _addEventSource(source) {
		if ($.isFunction(source) || $.isArray(source)) {
			source = { events: source };
		}
		else if (typeof source == 'string') {
			source = { url: source };
		}
		if (typeof source == 'object') {
			normalizeSource(source);
			sources.push(source);
			return source;
		}
	}
	

	function removeEventSource(source) {
		sources = $.grep(sources, function(src) {
			return !isSourcesEqual(src, source);
		});
		// remove all client events from that source
		cache = $.grep(cache, function(e) {
			return !isSourcesEqual(e.source, source);
		});
		reportEvents(cache);
	}
	
	
	
	/* Manipulation
	-----------------------------------------------------------------------------*/
	
	
	function updateEvent(event) { // update an existing event
		var i, len = cache.length, e,
			defaultEventEnd = getView().defaultEventEnd, // getView???
			startDelta = event.start - event._start,
			endDelta = event.end ?
				(event.end - (event._end || defaultEventEnd(event))) // event._end would be null if event.end
				: 0;                                                      // was null and event was just resized
		for (i=0; i<len; i++) {
			e = cache[i];
			if (e._id == event._id && e != event) {
				e.start = new Date(+e.start + startDelta);
				if (event.end) {
					if (e.end) {
						e.end = new Date(+e.end + endDelta);
					}else{
						e.end = new Date(+defaultEventEnd(e) + endDelta);
					}
				}else{
					e.end = null;
				}
				e.title = event.title;
				e.url = event.url;
				e.allDay = event.allDay;
				e.className = event.className;
				e.editable = event.editable;
				e.color = event.color;
				e.backgroudColor = event.backgroudColor;
				e.borderColor = event.borderColor;
				e.textColor = event.textColor;
				normalizeEvent(e);
			}
		}
		normalizeEvent(event);
		reportEvents(cache);
	}
	
	
	function renderEvent(event, stick) {
		normalizeEvent(event);
		if (!event.source) {
			if (stick) {
				stickySource.events.push(event);
				event.source = stickySource;
			}
			cache.push(event);
		}
		reportEvents(cache);
	}
	
	
	function removeEvents(filter) {
		if (!filter) { // remove all
			cache = [];
			// clear all array sources
			for (var i=0; i<sources.length; i++) {
				if ($.isArray(sources[i].events)) {
					sources[i].events = [];
				}
			}
		}else{
			if (!$.isFunction(filter)) { // an event ID
				var id = filter + '';
				filter = function(e) {
					return e._id == id;
				};
			}
			cache = $.grep(cache, filter, true);
			// remove events from array sources
			for (var i=0; i<sources.length; i++) {
				if ($.isArray(sources[i].events)) {
					sources[i].events = $.grep(sources[i].events, filter, true);
				}
			}
		}
		reportEvents(cache);
	}
	
	
	function clientEvents(filter) {
		if ($.isFunction(filter)) {
			return $.grep(cache, filter);
		}
		else if (filter) { // an event ID
			filter += '';
			return $.grep(cache, function(e) {
				return e._id == filter;
			});
		}
		return cache; // else, return all
	}
	
	
	
	/* Loading State
	-----------------------------------------------------------------------------*/
	
	
	function pushLoading() {
		if (!loadingLevel++) {
			trigger('loading', null, true);
		}
	}
	
	
	function popLoading() {
		if (!--loadingLevel) {
			trigger('loading', null, false);
		}
	}
	
	
	
	/* Event Normalization
	-----------------------------------------------------------------------------*/
	
	
	function normalizeEvent(event) {
		var source = event.source || {};
		var ignoreTimezone = firstDefined(source.ignoreTimezone, options.ignoreTimezone);
		event._id = event._id || (event.id === undefined ? '_fc' + eventGUID++ : event.id + '');
		if (event.date) {
			if (!event.start) {
				event.start = event.date;
			}
			delete event.date;
		}
		event._start = cloneDate(event.start = parseDate(event.start, ignoreTimezone));
		event.end = parseDate(event.end, ignoreTimezone);
		if (event.end && event.end <= event.start) {
			event.end = null;
		}
		event._end = event.end ? cloneDate(event.end) : null;
		if (event.allDay === undefined) {
			event.allDay = firstDefined(source.allDayDefault, options.allDayDefault);
		}
		if (event.className) {
			if (typeof event.className == 'string') {
				event.className = event.className.split(/\s+/);
			}
		}else{
			event.className = [];
		}
		// TODO: if there is no start date, return false to indicate an invalid event
	}
	
	
	
	/* Utils
	------------------------------------------------------------------------------*/
	
	
	function normalizeSource(source) {
		if (source.className) {
			// TODO: repeat code, same code for event classNames
			if (typeof source.className == 'string') {
				source.className = source.className.split(/\s+/);
			}
		}else{
			source.className = [];
		}
		var normalizers = fc.sourceNormalizers;
		for (var i=0; i<normalizers.length; i++) {
			normalizers[i](source);
		}
	}
	
	
	function isSourcesEqual(source1, source2) {
		return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
	}
	
	
	function getSourcePrimitive(source) {
		return ((typeof source == 'object') ? (source.events || source.url) : '') || source;
	}


}


fc.addDays = addDays;
fc.cloneDate = cloneDate;
fc.parseDate = parseDate;
fc.parseISO8601 = parseISO8601;
fc.parseTime = parseTime;
fc.formatDate = formatDate;
fc.formatDates = formatDates;



/* Date Math
-----------------------------------------------------------------------------*/

var dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'],
	DAY_MS = 86400000,
	HOUR_MS = 3600000,
	MINUTE_MS = 60000;
	

function addYears(d, n, keepTime) {
	d.setFullYear(d.getFullYear() + n);
	if (!keepTime) {
		clearTime(d);
	}
	return d;
}


function addMonths(d, n, keepTime) { // prevents day overflow/underflow
	if (+d) { // prevent infinite looping on invalid dates
		var m = d.getMonth() + n,
			check = cloneDate(d);
		check.setDate(1);
		check.setMonth(m);
		d.setMonth(m);
		if (!keepTime) {
			clearTime(d);
		}
		while (d.getMonth() != check.getMonth()) {
			d.setDate(d.getDate() + (d < check ? 1 : -1));
		}
	}
	return d;
}


function addDays(d, n, keepTime) { // deals with daylight savings
	if (+d) {
		var dd = d.getDate() + n,
			check = cloneDate(d);
		check.setHours(9); // set to middle of day
		check.setDate(dd);
		d.setDate(dd);
		if (!keepTime) {
			clearTime(d);
		}
		fixDate(d, check);
	}
	return d;
}


function fixDate(d, check) { // force d to be on check's YMD, for daylight savings purposes
	if (+d) { // prevent infinite looping on invalid dates
		while (d.getDate() != check.getDate()) {
			d.setTime(+d + (d < check ? 1 : -1) * HOUR_MS);
		}
	}
}


function addMinutes(d, n) {
	d.setMinutes(d.getMinutes() + n);
	return d;
}


function clearTime(d) {
	d.setHours(0);
	d.setMinutes(0);
	d.setSeconds(0); 
	d.setMilliseconds(0);
	return d;
}


function cloneDate(d, dontKeepTime) {
	if (dontKeepTime) {
		return clearTime(new Date(+d));
	}
	return new Date(+d);
}


function zeroDate() { // returns a Date with time 00:00:00 and dateOfMonth=1
	var i=0, d;
	do {
		d = new Date(1970, i++, 1);
	} while (d.getHours()); // != 0
	return d;
}


function skipWeekend(date, inc, excl) {
	inc = inc || 1;
	while (!date.getDay() || (excl && date.getDay()==1 || !excl && date.getDay()==6)) {
		addDays(date, inc);
	}
	return date;
}


function dayDiff(d1, d2) { // d1 - d2
	return Math.round((cloneDate(d1, true) - cloneDate(d2, true)) / DAY_MS);
}


function setYMD(date, y, m, d) {
	if (y !== undefined && y != date.getFullYear()) {
		date.setDate(1);
		date.setMonth(0);
		date.setFullYear(y);
	}
	if (m !== undefined && m != date.getMonth()) {
		date.setDate(1);
		date.setMonth(m);
	}
	if (d !== undefined) {
		date.setDate(d);
	}
}



/* Date Parsing
-----------------------------------------------------------------------------*/


function parseDate(s, ignoreTimezone) { // ignoreTimezone defaults to true
	if (typeof s == 'object') { // already a Date object
		return s;
	}
	if (typeof s == 'number') { // a UNIX timestamp
		return new Date(s * 1000);
	}
	if (typeof s == 'string') {
		if (s.match(/^\d+(\.\d+)?$/)) { // a UNIX timestamp
			return new Date(parseFloat(s) * 1000);
		}
		if (ignoreTimezone === undefined) {
			ignoreTimezone = true;
		}
		return parseISO8601(s, ignoreTimezone) || (s ? new Date(s) : null);
	}
	// TODO: never return invalid dates (like from new Date(<string>)), return null instead
	return null;
}


function parseISO8601(s, ignoreTimezone) { // ignoreTimezone defaults to false
	// derived from http://delete.me.uk/2005/03/iso8601.html
	// TODO: for a know glitch/feature, read tests/issue_206_parseDate_dst.html
	var m = s.match(/^([0-9]{4})(-([0-9]{2})(-([0-9]{2})([T ]([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?(Z|(([-+])([0-9]{2})(:?([0-9]{2}))?))?)?)?)?$/);
	if (!m) {
		return null;
	}
	var date = new Date(m[1], 0, 1);
	if (ignoreTimezone || !m[13]) {
		var check = new Date(m[1], 0, 1, 9, 0);
		if (m[3]) {
			date.setMonth(m[3] - 1);
			check.setMonth(m[3] - 1);
		}
		if (m[5]) {
			date.setDate(m[5]);
			check.setDate(m[5]);
		}
		fixDate(date, check);
		if (m[7]) {
			date.setHours(m[7]);
		}
		if (m[8]) {
			date.setMinutes(m[8]);
		}
		if (m[10]) {
			date.setSeconds(m[10]);
		}
		if (m[12]) {
			date.setMilliseconds(Number("0." + m[12]) * 1000);
		}
		fixDate(date, check);
	}else{
		date.setUTCFullYear(
			m[1],
			m[3] ? m[3] - 1 : 0,
			m[5] || 1
		);
		date.setUTCHours(
			m[7] || 0,
			m[8] || 0,
			m[10] || 0,
			m[12] ? Number("0." + m[12]) * 1000 : 0
		);
		if (m[14]) {
			var offset = Number(m[16]) * 60 + (m[18] ? Number(m[18]) : 0);
			offset *= m[15] == '-' ? 1 : -1;
			date = new Date(+date + (offset * 60 * 1000));
		}
	}
	return date;
}


function parseTime(s) { // returns minutes since start of day
	if (typeof s == 'number') { // an hour
		return s * 60;
	}
	if (typeof s == 'object') { // a Date object
		return s.getHours() * 60 + s.getMinutes();
	}
	var m = s.match(/(\d+)(?::(\d+))?\s*(\w+)?/);
	if (m) {
		var h = parseInt(m[1], 10);
		if (m[3]) {
			h %= 12;
			if (m[3].toLowerCase().charAt(0) == 'p') {
				h += 12;
			}
		}
		return h * 60 + (m[2] ? parseInt(m[2], 10) : 0);
	}
}



/* Date Formatting
-----------------------------------------------------------------------------*/
// TODO: use same function formatDate(date, [date2], format, [options])


function formatDate(date, format, options) {
	return formatDates(date, null, format, options);
}


function formatDates(date1, date2, format, options) {
	options = options || defaults;
	var date = date1,
		otherDate = date2,
		i, len = format.length, c,
		i2, formatter,
		res = '';
	for (i=0; i<len; i++) {
		c = format.charAt(i);
		if (c == "'") {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == "'") {
					if (date) {
						if (i2 == i+1) {
							res += "'";
						}else{
							res += format.substring(i+1, i2);
						}
						i = i2;
					}
					break;
				}
			}
		}
		else if (c == '(') {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == ')') {
					var subres = formatDate(date, format.substring(i+1, i2), options);
					if (parseInt(subres.replace(/\D/, ''), 10)) {
						res += subres;
					}
					i = i2;
					break;
				}
			}
		}
		else if (c == '[') {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == ']') {
					var subformat = format.substring(i+1, i2);
					var subres = formatDate(date, subformat, options);
					if (subres != formatDate(otherDate, subformat, options)) {
						res += subres;
					}
					i = i2;
					break;
				}
			}
		}
		else if (c == '{') {
			date = date2;
			otherDate = date1;
		}
		else if (c == '}') {
			date = date1;
			otherDate = date2;
		}
		else {
			for (i2=len; i2>i; i2--) {
				if (formatter = dateFormatters[format.substring(i, i2)]) {
					if (date) {
						res += formatter(date, options);
					}
					i = i2 - 1;
					break;
				}
			}
			if (i2 == i) {
				if (date) {
					res += c;
				}
			}
		}
	}
	return res;
};


var dateFormatters = {
	s	: function(d)	{ return d.getSeconds() },
	ss	: function(d)	{ return zeroPad(d.getSeconds()) },
	m	: function(d)	{ return d.getMinutes() },
	mm	: function(d)	{ return zeroPad(d.getMinutes()) },
	h	: function(d)	{ return d.getHours() % 12 || 12 },
	hh	: function(d)	{ return zeroPad(d.getHours() % 12 || 12) },
	H	: function(d)	{ return d.getHours() },
	HH	: function(d)	{ return zeroPad(d.getHours()) },
	d	: function(d)	{ return d.getDate() },
	dd	: function(d)	{ return zeroPad(d.getDate()) },
	ddd	: function(d,o)	{ return o.dayNamesShort[d.getDay()] },
	dddd: function(d,o)	{ return o.dayNames[d.getDay()] },
	M	: function(d)	{ return d.getMonth() + 1 },
	MM	: function(d)	{ return zeroPad(d.getMonth() + 1) },
	MMM	: function(d,o)	{ return o.monthNamesShort[d.getMonth()] },
	MMMM: function(d,o)	{ return o.monthNames[d.getMonth()] },
	yy	: function(d)	{ return (d.getFullYear()+'').substring(2) },
	yyyy: function(d)	{ return d.getFullYear() },
	t	: function(d)	{ return d.getHours() < 12 ? 'a' : 'p' },
	tt	: function(d)	{ return d.getHours() < 12 ? 'am' : 'pm' },
	T	: function(d)	{ return d.getHours() < 12 ? 'A' : 'P' },
	TT	: function(d)	{ return d.getHours() < 12 ? 'AM' : 'PM' },
	u	: function(d)	{ return formatDate(d, "yyyy-MM-dd'T'HH:mm:ss'Z'") },
	S	: function(d)	{
		var date = d.getDate();
		if (date > 10 && date < 20) {
			return 'th';
		}
		return ['st', 'nd', 'rd'][date%10-1] || 'th';
	}
};



fc.applyAll = applyAll;


/* Event Date Math
-----------------------------------------------------------------------------*/


function exclEndDay(event) {
	if (event.end) {
		return _exclEndDay(event.end, event.allDay);
	}else{
		return addDays(cloneDate(event.start), 1);
	}
}


function _exclEndDay(end, allDay) {
	end = cloneDate(end);
	return allDay || end.getHours() || end.getMinutes() ? addDays(end, 1) : clearTime(end);
}


function segCmp(a, b) {
	return (b.msLength - a.msLength) * 100 + (a.event.start - b.event.start);
}


function segsCollide(seg1, seg2) {
	return seg1.end > seg2.start && seg1.start < seg2.end;
}



/* Event Sorting
-----------------------------------------------------------------------------*/


// event rendering utilities
function sliceSegs(events, visEventEnds, start, end) {
	var segs = [],
		i, len=events.length, event,
		eventStart, eventEnd,
		segStart, segEnd,
		isStart, isEnd;
	for (i=0; i<len; i++) {
		event = events[i];
		eventStart = event.start;
		eventEnd = visEventEnds[i];
		if (eventEnd > start && eventStart < end) {
			if (eventStart < start) {
				segStart = cloneDate(start);
				isStart = false;
			}else{
				segStart = eventStart;
				isStart = true;
			}
			if (eventEnd > end) {
				segEnd = cloneDate(end);
				isEnd = false;
			}else{
				segEnd = eventEnd;
				isEnd = true;
			}
			segs.push({
				event: event,
				start: segStart,
				end: segEnd,
				isStart: isStart,
				isEnd: isEnd,
				msLength: segEnd - segStart
			});
		}
	} 
	return segs.sort(segCmp);
}


// event rendering calculation utilities
function stackSegs(segs) {
	var levels = [],
		i, len = segs.length, seg,
		j, collide, k;
	for (i=0; i<len; i++) {
		seg = segs[i];
		j = 0; // the level index where seg should belong
		while (true) {
			collide = false;
			if (levels[j]) {
				for (k=0; k<levels[j].length; k++) {
					if (segsCollide(levels[j][k], seg)) {
						collide = true;
						break;
					}
				}
			}
			if (collide) {
				j++;
			}else{
				break;
			}
		}
		if (levels[j]) {
			levels[j].push(seg);
		}else{
			levels[j] = [seg];
		}
	}
	return levels;
}



/* Event Element Binding
-----------------------------------------------------------------------------*/


function lazySegBind(container, segs, bindHandlers) {
	container.unbind('mouseover').mouseover(function(ev) {
		var parent=ev.target, e,
			i, seg;
		while (parent != this) {
			e = parent;
			parent = parent.parentNode;
		}
		if ((i = e._fci) !== undefined) {
			e._fci = undefined;
			seg = segs[i];
			bindHandlers(seg.event, seg.element, seg);
			$(ev.target).trigger(ev);
		}
		ev.stopPropagation();
	});
}



/* Element Dimensions
-----------------------------------------------------------------------------*/


function setOuterWidth(element, width, includeMargins) {
	for (var i=0, e; i<element.length; i++) {
		e = $(element[i]);
		e.width(Math.max(0, width - hsides(e, includeMargins)));
	}
}


function setOuterHeight(element, height, includeMargins) {
	for (var i=0, e; i<element.length; i++) {
		e = $(element[i]);
		e.height(Math.max(0, height - vsides(e, includeMargins)));
	}
}


// TODO: curCSS has been deprecated (jQuery 1.4.3 - 10/16/2010)


function hsides(element, includeMargins) {
	return hpadding(element) + hborders(element) + (includeMargins ? hmargins(element) : 0);
}


function hpadding(element) {
	return (parseFloat($.curCSS(element[0], 'paddingLeft', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'paddingRight', true)) || 0);
}


function hmargins(element) {
	return (parseFloat($.curCSS(element[0], 'marginLeft', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'marginRight', true)) || 0);
}


function hborders(element) {
	return (parseFloat($.curCSS(element[0], 'borderLeftWidth', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'borderRightWidth', true)) || 0);
}


function vsides(element, includeMargins) {
	return vpadding(element) +  vborders(element) + (includeMargins ? vmargins(element) : 0);
}


function vpadding(element) {
	return (parseFloat($.curCSS(element[0], 'paddingTop', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'paddingBottom', true)) || 0);
}


function vmargins(element) {
	return (parseFloat($.curCSS(element[0], 'marginTop', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'marginBottom', true)) || 0);
}


function vborders(element) {
	return (parseFloat($.curCSS(element[0], 'borderTopWidth', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'borderBottomWidth', true)) || 0);
}


function setMinHeight(element, height) {
	height = (typeof height == 'number' ? height + 'px' : height);
	element.each(function(i, _element) {
		_element.style.cssText += ';min-height:' + height + ';_height:' + height;
		// why can't we just use .css() ? i forget
	});
}



/* Misc Utils
-----------------------------------------------------------------------------*/


//TODO: arraySlice
//TODO: isFunction, grep ?


function noop() { }


function cmp(a, b) {
	return a - b;
}


function arrayMax(a) {
	return Math.max.apply(Math, a);
}


function zeroPad(n) {
	return (n < 10 ? '0' : '') + n;
}


function smartProperty(obj, name) { // get a camel-cased/namespaced property of an object
	if (obj[name] !== undefined) {
		return obj[name];
	}
	var parts = name.split(/(?=[A-Z])/),
		i=parts.length-1, res;
	for (; i>=0; i--) {
		res = obj[parts[i].toLowerCase()];
		if (res !== undefined) {
			return res;
		}
	}
	return obj[''];
}


function htmlEscape(s) {
	return s.replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/'/g, '&#039;')
		.replace(/"/g, '&quot;')
		.replace(/\n/g, '<br />');
}


function cssKey(_element) {
	return _element.id + '/' + _element.className + '/' + _element.style.cssText.replace(/(^|;)\s*(top|left|width|height)\s*:[^;]*/ig, '');
}


function disableTextSelection(element) {
	element
		.attr('unselectable', 'on')
		.css('MozUserSelect', 'none')
		.bind('selectstart.ui', function() { return false; });
}


/*
function enableTextSelection(element) {
	element
		.attr('unselectable', 'off')
		.css('MozUserSelect', '')
		.unbind('selectstart.ui');
}
*/


function markFirstLast(e) {
	e.children()
		.removeClass('fc-first fc-last')
		.filter(':first-child')
			.addClass('fc-first')
		.end()
		.filter(':last-child')
			.addClass('fc-last');
}


function setDayID(cell, date) {
	cell.each(function(i, _cell) {
		_cell.className = _cell.className.replace(/^fc-\w*/, 'fc-' + dayIDs[date.getDay()]);
		// TODO: make a way that doesn't rely on order of classes
	});
}


function getSkinCss(event, opt) {
	var source = event.source || {};
	var eventColor = event.color;
	var sourceColor = source.color;
	var optionColor = opt('eventColor');
	var backgroundColor =
		event.backgroundColor ||
		eventColor ||
		source.backgroundColor ||
		sourceColor ||
		opt('eventBackgroundColor') ||
		optionColor;
	var borderColor =
		event.borderColor ||
		eventColor ||
		source.borderColor ||
		sourceColor ||
		opt('eventBorderColor') ||
		optionColor;
	var textColor =
		event.textColor ||
		source.textColor ||
		opt('eventTextColor');
	var statements = [];
	if (backgroundColor) {
		statements.push('background-color:' + backgroundColor);
	}
	if (borderColor) {
		statements.push('border-color:' + borderColor);
	}
	if (textColor) {
		statements.push('color:' + textColor);
	}
	return statements.join(';');
}


function applyAll(functions, thisObj, args) {
	if ($.isFunction(functions)) {
		functions = [ functions ];
	}
	if (functions) {
		var i;
		var ret;
		for (i=0; i<functions.length; i++) {
			ret = functions[i].apply(thisObj, args) || ret;
		}
		return ret;
	}
}


function firstDefined() {
	for (var i=0; i<arguments.length; i++) {
		if (arguments[i] !== undefined) {
			return arguments[i];
		}
	}
}



fcViews.month = MonthView;

function MonthView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	BasicView.call(t, element, calendar, 'month');
	var opt = t.opt;
	var renderBasic = t.renderBasic;
	var formatDate = calendar.formatDate;
	
	
	
	function render(date, delta) {
		if (delta) {
			addMonths(date, delta);
			date.setDate(1);
		}
		var start = cloneDate(date, true);
		start.setDate(1);
		var end = addMonths(cloneDate(start), 1);
		var visStart = cloneDate(start);
		var visEnd = cloneDate(end);
		var firstDay = opt('firstDay');
		var nwe = opt('weekends') ? 0 : 1;
		if (nwe) {
			skipWeekend(visStart);
			skipWeekend(visEnd, -1, true);
		}
		addDays(visStart, -((visStart.getDay() - Math.max(firstDay, nwe) + 7) % 7));
		addDays(visEnd, (7 - visEnd.getDay() + Math.max(firstDay, nwe)) % 7);
		var rowCnt = Math.round((visEnd - visStart) / (DAY_MS * 7));
		if (opt('weekMode') == 'fixed') {
			addDays(visEnd, (6 - rowCnt) * 7);
			rowCnt = 6;
		}
		t.title = formatDate(start, opt('titleFormat'));
		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;
		renderBasic(6, rowCnt, nwe ? 5 : 7, true);
	}
	
	
}

fcViews.basicWeek = BasicWeekView;

function BasicWeekView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	BasicView.call(t, element, calendar, 'basicWeek');
	var opt = t.opt;
	var renderBasic = t.renderBasic;
	var formatDates = calendar.formatDates;
	
	
	
	function render(date, delta) {
		if (delta) {
			addDays(date, delta * 7);
		}
		var start = addDays(cloneDate(date), -((date.getDay() - opt('firstDay') + 7) % 7));
		var end = addDays(cloneDate(start), 7);
		var visStart = cloneDate(start);
		var visEnd = cloneDate(end);
		var weekends = opt('weekends');
		if (!weekends) {
			skipWeekend(visStart);
			skipWeekend(visEnd, -1, true);
		}
		t.title = formatDates(
			visStart,
			addDays(cloneDate(visEnd), -1),
			opt('titleFormat')
		);
		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;
		renderBasic(1, 1, weekends ? 7 : 5, false);
	}
	
	
}

fcViews.basicDay = BasicDayView;

//TODO: when calendar's date starts out on a weekend, shouldn't happen


function BasicDayView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	BasicView.call(t, element, calendar, 'basicDay');
	var opt = t.opt;
	var renderBasic = t.renderBasic;
	var formatDate = calendar.formatDate;
	
	
	
	function render(date, delta) {
		if (delta) {
			addDays(date, delta);
			if (!opt('weekends')) {
				skipWeekend(date, delta < 0 ? -1 : 1);
			}
		}
		t.title = formatDate(date, opt('titleFormat'));
		t.start = t.visStart = cloneDate(date, true);
		t.end = t.visEnd = addDays(cloneDate(t.start), 1);
		renderBasic(1, 1, 1, false);
	}
	
	
}

setDefaults({
	weekMode: 'fixed'
});


function BasicView(element, calendar, viewName) {
	var t = this;
	
	
	// exports
	t.renderBasic = renderBasic;
	t.setHeight = setHeight;
	t.setWidth = setWidth;
	t.renderDayOverlay = renderDayOverlay;
	t.defaultSelectionEnd = defaultSelectionEnd;
	t.renderSelection = renderSelection;
	t.clearSelection = clearSelection;
	t.reportDayClick = reportDayClick; // for selection (kinda hacky)
	t.dragStart = dragStart;
	t.dragStop = dragStop;
	t.defaultEventEnd = defaultEventEnd;
	t.getHoverListener = function() { return hoverListener };
	t.colContentLeft = colContentLeft;
	t.colContentRight = colContentRight;
	t.dayOfWeekCol = dayOfWeekCol;
	t.dateCell = dateCell;
	t.cellDate = cellDate;
	t.cellIsAllDay = function() { return true };
	t.allDayRow = allDayRow;
	t.allDayBounds = allDayBounds;
	t.getRowCnt = function() { return rowCnt };
	t.getColCnt = function() { return colCnt };
	t.getColWidth = function() { return colWidth };
	t.getDaySegmentContainer = function() { return daySegmentContainer };
	
	
	// imports
	View.call(t, element, calendar, viewName);
	OverlayManager.call(t);
	SelectionManager.call(t);
	BasicEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	var clearEvents = t.clearEvents;
	var renderOverlay = t.renderOverlay;
	var clearOverlays = t.clearOverlays;
	var daySelectionMousedown = t.daySelectionMousedown;
	var formatDate = calendar.formatDate;
	
	
	// locals
	
	var head;
	var headCells;
	var body;
	var bodyRows;
	var bodyCells;
	var bodyFirstCells;
	var bodyCellTopInners;
	var daySegmentContainer;
	
	var viewWidth;
	var viewHeight;
	var colWidth;
	
	var rowCnt, colCnt;
	var coordinateGrid;
	var hoverListener;
	var colContentPositions;
	
	var rtl, dis, dit;
	var firstDay;
	var nwe;
	var tm;
	var colFormat;
	
	
	
	/* Rendering
	------------------------------------------------------------*/
	
	
	disableTextSelection(element.addClass('fc-grid'));
	
	
	function renderBasic(maxr, r, c, showNumbers) {
		rowCnt = r;
		colCnt = c;
		updateOptions();
		var firstTime = !body;
		if (firstTime) {
			buildSkeleton(maxr, showNumbers);
		}else{
			clearEvents();
		}
		updateCells(firstTime);
	}
	
	
	
	function updateOptions() {
		rtl = opt('isRTL');
		if (rtl) {
			dis = -1;
			dit = colCnt - 1;
		}else{
			dis = 1;
			dit = 0;
		}
		firstDay = opt('firstDay');
		nwe = opt('weekends') ? 0 : 1;
		tm = opt('theme') ? 'ui' : 'fc';
		colFormat = opt('columnFormat');
	}
	
	
	
	function buildSkeleton(maxRowCnt, showNumbers) {
		var s;
		var headerClass = tm + "-widget-header";
		var contentClass = tm + "-widget-content";
		var i, j;
		var table;
		
		s =
			"<table class='fc-border-separate' style='width:100%' cellspacing='0'>" +
			"<thead>" +
			"<tr>";
		for (i=0; i<colCnt; i++) {
			s +=
				"<th class='fc- " + headerClass + "'/>"; // need fc- for setDayID
		}
		s +=
			"</tr>" +
			"</thead>" +
			"<tbody>";
		for (i=0; i<maxRowCnt; i++) {
			s +=
				"<tr class='fc-week" + i + "'>";
			for (j=0; j<colCnt; j++) {
				s +=
					"<td class='fc- " + contentClass + " fc-day" + (i*colCnt+j) + "'>" + // need fc- for setDayID
					"<div>" +
					(showNumbers ?
						"<div class='fc-day-number'/>" :
						''
						) +
					"<div class='fc-day-content'>" +
					"<div style='position:relative'>&nbsp;</div>" +
					"</div>" +
					"</div>" +
					"</td>";
			}
			s +=
				"</tr>";
		}
		s +=
			"</tbody>" +
			"</table>";
		table = $(s).appendTo(element);
		
		head = table.find('thead');
		headCells = head.find('th');
		body = table.find('tbody');
		bodyRows = body.find('tr');
		bodyCells = body.find('td');
		bodyFirstCells = bodyCells.filter(':first-child');
		bodyCellTopInners = bodyRows.eq(0).find('div.fc-day-content div');
		
		markFirstLast(head.add(head.find('tr'))); // marks first+last tr/th's
		markFirstLast(bodyRows); // marks first+last td's
		bodyRows.eq(0).addClass('fc-first'); // fc-last is done in updateCells
		
		dayBind(bodyCells);
		
		daySegmentContainer =
			$("<div style='position:absolute;z-index:8;top:0;left:0'/>")
				.appendTo(element);
	}
	
	
	
	function updateCells(firstTime) {
		var dowDirty = firstTime || rowCnt == 1; // could the cells' day-of-weeks need updating?
		var month = t.start.getMonth();
		var today = clearTime(new Date());
		var cell;
		var date;
		var row;
	
		if (dowDirty) {
			headCells.each(function(i, _cell) {
				cell = $(_cell);
				date = indexDate(i);
				cell.html(formatDate(date, colFormat));
				setDayID(cell, date);
			});
		}
		
		bodyCells.each(function(i, _cell) {
			cell = $(_cell);
			date = indexDate(i);
			if (date.getMonth() == month) {
				cell.removeClass('fc-other-month');
			}else{
				cell.addClass('fc-other-month');
			}
			if (+date == +today) {
				cell.addClass(tm + '-state-highlight fc-today');
			}else{
				cell.removeClass(tm + '-state-highlight fc-today');
			}
			cell.find('div.fc-day-number').text(date.getDate());
			if (dowDirty) {
				setDayID(cell, date);
			}
		});
		
		bodyRows.each(function(i, _row) {
			row = $(_row);
			if (i < rowCnt) {
				row.show();
				if (i == rowCnt-1) {
					row.addClass('fc-last');
				}else{
					row.removeClass('fc-last');
				}
			}else{
				row.hide();
			}
		});
	}
	
	
	
	function setHeight(height) {
		viewHeight = height;
		
		var bodyHeight = viewHeight - head.height();
		var rowHeight;
		var rowHeightLast;
		var cell;
			
		if (opt('weekMode') == 'variable') {
			rowHeight = rowHeightLast = Math.floor(bodyHeight / (rowCnt==1 ? 2 : 6));
		}else{
			rowHeight = Math.floor(bodyHeight / rowCnt);
			rowHeightLast = bodyHeight - rowHeight * (rowCnt-1);
		}
		
		bodyFirstCells.each(function(i, _cell) {
			if (i < rowCnt) {
				cell = $(_cell);
				setMinHeight(
					cell.find('> div'),
					(i==rowCnt-1 ? rowHeightLast : rowHeight) - vsides(cell)
				);
			}
		});
		
	}
	
	
	function setWidth(width) {
		viewWidth = width;
		colContentPositions.clear();
		colWidth = Math.floor(viewWidth / colCnt);
		setOuterWidth(headCells.slice(0, -1), colWidth);
	}
	
	
	
	/* Day clicking and binding
	-----------------------------------------------------------*/
	
	
	function dayBind(days) {
		days.click(dayClick)
			.mousedown(daySelectionMousedown);
	}
	
	
	function dayClick(ev) {
		if (!opt('selectable')) { // if selectable, SelectionManager will worry about dayClick
			var index = parseInt(this.className.match(/fc\-day(\d+)/)[1]); // TODO: maybe use .data
			var date = indexDate(index);
			trigger('dayClick', this, date, true, ev);
		}
	}
	
	
	
	/* Semi-transparent Overlay Helpers
	------------------------------------------------------*/
	
	
	function renderDayOverlay(overlayStart, overlayEnd, refreshCoordinateGrid) { // overlayEnd is exclusive
		if (refreshCoordinateGrid) {
			coordinateGrid.build();
		}
		var rowStart = cloneDate(t.visStart);
		var rowEnd = addDays(cloneDate(rowStart), colCnt);
		for (var i=0; i<rowCnt; i++) {
			var stretchStart = new Date(Math.max(rowStart, overlayStart));
			var stretchEnd = new Date(Math.min(rowEnd, overlayEnd));
			if (stretchStart < stretchEnd) {
				var colStart, colEnd;
				if (rtl) {
					colStart = dayDiff(stretchEnd, rowStart)*dis+dit+1;
					colEnd = dayDiff(stretchStart, rowStart)*dis+dit+1;
				}else{
					colStart = dayDiff(stretchStart, rowStart);
					colEnd = dayDiff(stretchEnd, rowStart);
				}
				dayBind(
					renderCellOverlay(i, colStart, i, colEnd-1)
				);
			}
			addDays(rowStart, 7);
			addDays(rowEnd, 7);
		}
	}
	
	
	function renderCellOverlay(row0, col0, row1, col1) { // row1,col1 is inclusive
		var rect = coordinateGrid.rect(row0, col0, row1, col1, element);
		return renderOverlay(rect, element);
	}
	
	
	
	/* Selection
	-----------------------------------------------------------------------*/
	
	
	function defaultSelectionEnd(startDate, allDay) {
		return cloneDate(startDate);
	}
	
	
	function renderSelection(startDate, endDate, allDay) {
		renderDayOverlay(startDate, addDays(cloneDate(endDate), 1), true); // rebuild every time???
	}
	
	
	function clearSelection() {
		clearOverlays();
	}
	
	
	function reportDayClick(date, allDay, ev) {
		var cell = dateCell(date);
		var _element = bodyCells[cell.row*colCnt + cell.col];
		trigger('dayClick', _element, date, allDay, ev);
	}
	
	
	
	/* External Dragging
	-----------------------------------------------------------------------*/
	
	
	function dragStart(_dragElement, ev, ui) {
		hoverListener.start(function(cell) {
			clearOverlays();
			if (cell) {
				renderCellOverlay(cell.row, cell.col, cell.row, cell.col);
			}
		}, ev);
	}
	
	
	function dragStop(_dragElement, ev, ui) {
		var cell = hoverListener.stop();
		clearOverlays();
		if (cell) {
			var d = cellDate(cell);
			trigger('drop', _dragElement, d, true, ev, ui);
		}
	}
	
	
	
	/* Utilities
	--------------------------------------------------------*/
	
	
	function defaultEventEnd(event) {
		return cloneDate(event.start);
	}
	
	
	coordinateGrid = new CoordinateGrid(function(rows, cols) {
		var e, n, p;
		headCells.each(function(i, _e) {
			e = $(_e);
			n = e.offset().left;
			if (i) {
				p[1] = n;
			}
			p = [n];
			cols[i] = p;
		});
		p[1] = n + e.outerWidth();
		bodyRows.each(function(i, _e) {
			if (i < rowCnt) {
				e = $(_e);
				n = e.offset().top;
				if (i) {
					p[1] = n;
				}
				p = [n];
				rows[i] = p;
			}
		});
		p[1] = n + e.outerHeight();
	});
	
	
	hoverListener = new HoverListener(coordinateGrid);
	
	
	colContentPositions = new HorizontalPositionCache(function(col) {
		return bodyCellTopInners.eq(col);
	});
	
	
	function colContentLeft(col) {
		return colContentPositions.left(col);
	}
	
	
	function colContentRight(col) {
		return colContentPositions.right(col);
	}
	
	
	
	
	function dateCell(date) {
		return {
			row: Math.floor(dayDiff(date, t.visStart) / 7),
			col: dayOfWeekCol(date.getDay())
		};
	}
	
	
	function cellDate(cell) {
		return _cellDate(cell.row, cell.col);
	}
	
	
	function _cellDate(row, col) {
		return addDays(cloneDate(t.visStart), row*7 + col*dis+dit);
		// what about weekends in middle of week?
	}
	
	
	function indexDate(index) {
		return _cellDate(Math.floor(index/colCnt), index%colCnt);
	}
	
	
	function dayOfWeekCol(dayOfWeek) {
		return ((dayOfWeek - Math.max(firstDay, nwe) + colCnt) % colCnt) * dis + dit;
	}
	
	
	
	
	function allDayRow(i) {
		return bodyRows.eq(i);
	}
	
	
	function allDayBounds(i) {
		return {
			left: 0,
			right: viewWidth
		};
	}
	
	
}

function BasicEventRenderer() {
	var t = this;
	
	
	// exports
	t.renderEvents = renderEvents;
	t.compileDaySegs = compileSegs; // for DayEventRenderer
	t.clearEvents = clearEvents;
	t.bindDaySeg = bindDaySeg;
	
	
	// imports
	DayEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	//var setOverflowHidden = t.setOverflowHidden;
	var isEventDraggable = t.isEventDraggable;
	var isEventResizable = t.isEventResizable;
	var reportEvents = t.reportEvents;
	var reportEventClear = t.reportEventClear;
	var eventElementHandlers = t.eventElementHandlers;
	var showEvents = t.showEvents;
	var hideEvents = t.hideEvents;
	var eventDrop = t.eventDrop;
	var getDaySegmentContainer = t.getDaySegmentContainer;
	var getHoverListener = t.getHoverListener;
	var renderDayOverlay = t.renderDayOverlay;
	var clearOverlays = t.clearOverlays;
	var getRowCnt = t.getRowCnt;
	var getColCnt = t.getColCnt;
	var renderDaySegs = t.renderDaySegs;
	var resizableDayEvent = t.resizableDayEvent;
	
	
	
	/* Rendering
	--------------------------------------------------------------------*/
	
	
	function renderEvents(events, modifiedEventId) {
		reportEvents(events);
		renderDaySegs(compileSegs(events), modifiedEventId);
	}
	
	
	function clearEvents() {
		reportEventClear();
		getDaySegmentContainer().empty();
	}
	
	
	function compileSegs(events) {
		var rowCnt = getRowCnt(),
			colCnt = getColCnt(),
			d1 = cloneDate(t.visStart),
			d2 = addDays(cloneDate(d1), colCnt),
			visEventsEnds = $.map(events, exclEndDay),
			i, row,
			j, level,
			k, seg,
			segs=[];
		for (i=0; i<rowCnt; i++) {
			row = stackSegs(sliceSegs(events, visEventsEnds, d1, d2));
			for (j=0; j<row.length; j++) {
				level = row[j];
				for (k=0; k<level.length; k++) {
					seg = level[k];
					seg.row = i;
					seg.level = j; // not needed anymore
					segs.push(seg);
				}
			}
			addDays(d1, 7);
			addDays(d2, 7);
		}
		return segs;
	}
	
	
	function bindDaySeg(event, eventElement, seg) {
		if (isEventDraggable(event)) {
			draggableDayEvent(event, eventElement);
		}
		if (seg.isEnd && isEventResizable(event)) {
			resizableDayEvent(event, eventElement, seg);
		}
		eventElementHandlers(event, eventElement);
			// needs to be after, because resizableDayEvent might stopImmediatePropagation on click
	}
	
	
	
	/* Dragging
	----------------------------------------------------------------------------*/
	
	
	function draggableDayEvent(event, eventElement) {
		var hoverListener = getHoverListener();
		var dayDelta;
		eventElement.draggable({
			zIndex: 9,
			delay: 50,
			opacity: opt('dragOpacity'),
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {
				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);
				hoverListener.start(function(cell, origCell, rowDelta, colDelta) {
					eventElement.draggable('option', 'revert', !cell || !rowDelta && !colDelta);
					clearOverlays();
					if (cell) {
						//setOverflowHidden(true);
						dayDelta = rowDelta*7 + colDelta * (opt('isRTL') ? -1 : 1);
						renderDayOverlay(
							addDays(cloneDate(event.start), dayDelta),
							addDays(exclEndDay(event), dayDelta)
						);
					}else{
						//setOverflowHidden(false);
						dayDelta = 0;
					}
				}, ev, 'drag');
			},
			stop: function(ev, ui) {
				hoverListener.stop();
				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);
				if (dayDelta) {
					eventDrop(this, event, dayDelta, 0, event.allDay, ev, ui);
				}else{
					eventElement.css('filter', ''); // clear IE opacity side-effects
					showEvents(event, eventElement);
				}
				//setOverflowHidden(false);
			}
		});
	}


}

fcViews.agendaWeek = AgendaWeekView;

function AgendaWeekView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	AgendaView.call(t, element, calendar, 'agendaWeek');
	var opt = t.opt;
	var renderAgenda = t.renderAgenda;
	var formatDates = calendar.formatDates;
	
	
	
	function render(date, delta) {
		if (delta) {
			addDays(date, delta * 7);
		}
		var start = addDays(cloneDate(date), -((date.getDay() - opt('firstDay') + 7) % 7));
		var end = addDays(cloneDate(start), 7);
		var visStart = cloneDate(start);
		var visEnd = cloneDate(end);
		var weekends = opt('weekends');
		if (!weekends) {
			skipWeekend(visStart);
			skipWeekend(visEnd, -1, true);
		}
		t.title = formatDates(
			visStart,
			addDays(cloneDate(visEnd), -1),
			opt('titleFormat')
		);
		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;
		renderAgenda(weekends ? 7 : 5);
	}
	

}

fcViews.agendaDay = AgendaDayView;

function AgendaDayView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	AgendaView.call(t, element, calendar, 'agendaDay');
	var opt = t.opt;
	var renderAgenda = t.renderAgenda;
	var formatDate = calendar.formatDate;
	
	
	
	function render(date, delta) {
		if (delta) {
			addDays(date, delta);
			if (!opt('weekends')) {
				skipWeekend(date, delta < 0 ? -1 : 1);
			}
		}
		var start = cloneDate(date, true);
		var end = addDays(cloneDate(start), 1);
		t.title = formatDate(date, opt('titleFormat'));
		t.start = t.visStart = start;
		t.end = t.visEnd = end;
		renderAgenda(1);
	}
	

}

setDefaults({
	allDaySlot: true,
	allDayText: 'all-day',
	firstHour: 6,
	slotMinutes: 30,
	defaultEventMinutes: 120,
	axisFormat: 'h(:mm)tt',
	timeFormat: {
		agenda: 'h:mm{ - h:mm}'
	},
	dragOpacity: {
		agenda: .5
	},
	minTime: 0,
	maxTime: 24
});


// TODO: make it work in quirks mode (event corners, all-day height)
// TODO: test liquid width, especially in IE6


function AgendaView(element, calendar, viewName) {
	var t = this;
	
	
	// exports
	t.renderAgenda = renderAgenda;
	t.setWidth = setWidth;
	t.setHeight = setHeight;
	t.beforeHide = beforeHide;
	t.afterShow = afterShow;
	t.defaultEventEnd = defaultEventEnd;
	t.timePosition = timePosition;
	t.dayOfWeekCol = dayOfWeekCol;
	t.dateCell = dateCell;
	t.cellDate = cellDate;
	t.cellIsAllDay = cellIsAllDay;
	t.allDayRow = getAllDayRow;
	t.allDayBounds = allDayBounds;
	t.getHoverListener = function() { return hoverListener };
	t.colContentLeft = colContentLeft;
	t.colContentRight = colContentRight;
	t.getDaySegmentContainer = function() { return daySegmentContainer };
	t.getSlotSegmentContainer = function() { return slotSegmentContainer };
	t.getMinMinute = function() { return minMinute };
	t.getMaxMinute = function() { return maxMinute };
	t.getBodyContent = function() { return slotContent }; // !!??
	t.getRowCnt = function() { return 1 };
	t.getColCnt = function() { return colCnt };
	t.getColWidth = function() { return colWidth };
	t.getSlotHeight = function() { return slotHeight };
	t.defaultSelectionEnd = defaultSelectionEnd;
	t.renderDayOverlay = renderDayOverlay;
	t.renderSelection = renderSelection;
	t.clearSelection = clearSelection;
	t.reportDayClick = reportDayClick; // selection mousedown hack
	t.dragStart = dragStart;
	t.dragStop = dragStop;
	
	
	// imports
	View.call(t, element, calendar, viewName);
	OverlayManager.call(t);
	SelectionManager.call(t);
	AgendaEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	var clearEvents = t.clearEvents;
	var renderOverlay = t.renderOverlay;
	var clearOverlays = t.clearOverlays;
	var reportSelection = t.reportSelection;
	var unselect = t.unselect;
	var daySelectionMousedown = t.daySelectionMousedown;
	var slotSegHtml = t.slotSegHtml;
	var formatDate = calendar.formatDate;
	
	
	// locals
	
	var dayTable;
	var dayHead;
	var dayHeadCells;
	var dayBody;
	var dayBodyCells;
	var dayBodyCellInners;
	var dayBodyFirstCell;
	var dayBodyFirstCellStretcher;
	var slotLayer;
	var daySegmentContainer;
	var allDayTable;
	var allDayRow;
	var slotScroller;
	var slotContent;
	var slotSegmentContainer;
	var slotTable;
	var slotTableFirstInner;
	var axisFirstCells;
	var gutterCells;
	var selectionHelper;
	
	var viewWidth;
	var viewHeight;
	var axisWidth;
	var colWidth;
	var gutterWidth;
	var slotHeight; // TODO: what if slotHeight changes? (see issue 650)
	var savedScrollTop;
	
	var colCnt;
	var slotCnt;
	var coordinateGrid;
	var hoverListener;
	var colContentPositions;
	var slotTopCache = {};
	
	var tm;
	var firstDay;
	var nwe;            // no weekends (int)
	var rtl, dis, dit;  // day index sign / translate
	var minMinute, maxMinute;
	var colFormat;
	

	
	/* Rendering
	-----------------------------------------------------------------------------*/
	
	
	disableTextSelection(element.addClass('fc-agenda'));
	
	
	function renderAgenda(c) {
		colCnt = c;
		updateOptions();
		if (!dayTable) {
			buildSkeleton();
		}else{
			clearEvents();
		}
		updateCells();
	}
	
	
	
	function updateOptions() {
		tm = opt('theme') ? 'ui' : 'fc';
		nwe = opt('weekends') ? 0 : 1;
		firstDay = opt('firstDay');
		if (rtl = opt('isRTL')) {
			dis = -1;
			dit = colCnt - 1;
		}else{
			dis = 1;
			dit = 0;
		}
		minMinute = parseTime(opt('minTime'));
		maxMinute = parseTime(opt('maxTime'));
		colFormat = opt('columnFormat');
	}
	
	
	
	function buildSkeleton() {
		var headerClass = tm + "-widget-header";
		var contentClass = tm + "-widget-content";
		var s;
		var i;
		var d;
		var maxd;
		var minutes;
		var slotNormal = opt('slotMinutes') % 15 == 0;
		
		s =
			"<table style='width:100%' class='fc-agenda-days fc-border-separate' cellspacing='0'>" +
			"<thead>" +
			"<tr>" +
			"<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";
		for (i=0; i<colCnt; i++) {
			s +=
				"<th class='fc- fc-col" + i + ' ' + headerClass + "'/>"; // fc- needed for setDayID
		}
		s +=
			"<th class='fc-agenda-gutter " + headerClass + "'>&nbsp;</th>" +
			"</tr>" +
			"</thead>" +
			"<tbody>" +
			"<tr>" +
			"<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";
		for (i=0; i<colCnt; i++) {
			s +=
				"<td class='fc- fc-col" + i + ' ' + contentClass + "'>" + // fc- needed for setDayID
				"<div>" +
				"<div class='fc-day-content'>" +
				"<div style='position:relative'>&nbsp;</div>" +
				"</div>" +
				"</div>" +
				"</td>";
		}
		s +=
			"<td class='fc-agenda-gutter " + contentClass + "'>&nbsp;</td>" +
			"</tr>" +
			"</tbody>" +
			"</table>";
		dayTable = $(s).appendTo(element);
		dayHead = dayTable.find('thead');
		dayHeadCells = dayHead.find('th').slice(1, -1);
		dayBody = dayTable.find('tbody');
		dayBodyCells = dayBody.find('td').slice(0, -1);
		dayBodyCellInners = dayBodyCells.find('div.fc-day-content div');
		dayBodyFirstCell = dayBodyCells.eq(0);
		dayBodyFirstCellStretcher = dayBodyFirstCell.find('> div');
		
		markFirstLast(dayHead.add(dayHead.find('tr')));
		markFirstLast(dayBody.add(dayBody.find('tr')));
		
		axisFirstCells = dayHead.find('th:first');
		gutterCells = dayTable.find('.fc-agenda-gutter');
		
		slotLayer =
			$("<div style='position:absolute;z-index:2;left:0;width:100%'/>")
				.appendTo(element);
				
		if (opt('allDaySlot')) {
		
			daySegmentContainer =
				$("<div style='position:absolute;z-index:8;top:0;left:0'/>")
					.appendTo(slotLayer);
		
			s =
				"<table style='width:100%' class='fc-agenda-allday' cellspacing='0'>" +
				"<tr>" +
				"<th class='" + headerClass + " fc-agenda-axis'>" + opt('allDayText') + "</th>" +
				"<td>" +
				"<div class='fc-day-content'><div style='position:relative'/></div>" +
				"</td>" +
				"<th class='" + headerClass + " fc-agenda-gutter'>&nbsp;</th>" +
				"</tr>" +
				"</table>";
			allDayTable = $(s).appendTo(slotLayer);
			allDayRow = allDayTable.find('tr');
			
			dayBind(allDayRow.find('td'));
			
			axisFirstCells = axisFirstCells.add(allDayTable.find('th:first'));
			gutterCells = gutterCells.add(allDayTable.find('th.fc-agenda-gutter'));
			
			slotLayer.append(
				"<div class='fc-agenda-divider " + headerClass + "'>" +
				"<div class='fc-agenda-divider-inner'/>" +
				"</div>"
			);
			
		}else{
		
			daySegmentContainer = $([]); // in jQuery 1.4, we can just do $()
		
		}
		
		slotScroller =
			$("<div style='position:absolute;width:100%;overflow-x:hidden;overflow-y:auto'/>")
				.appendTo(slotLayer);
				
		slotContent =
			$("<div style='position:relative;width:100%;overflow:hidden'/>")
				.appendTo(slotScroller);
				
		slotSegmentContainer =
			$("<div style='position:absolute;z-index:8;top:0;left:0'/>")
				.appendTo(slotContent);
		
		s =
			"<table class='fc-agenda-slots' style='width:100%' cellspacing='0'>" +
			"<tbody>";
		d = zeroDate();
		maxd = addMinutes(cloneDate(d), maxMinute);
		addMinutes(d, minMinute);
		slotCnt = 0;
		for (i=0; d < maxd; i++) {
			minutes = d.getMinutes();
			s +=
				"<tr class='fc-slot" + i + ' ' + (!minutes ? '' : 'fc-minor') + "'>" +
				"<th class='fc-agenda-axis " + headerClass + "'>" +
				((!slotNormal || !minutes) ? formatDate(d, opt('axisFormat')) : '&nbsp;') +
				"</th>" +
				"<td class='" + contentClass + "'>" +
				"<div style='position:relative'>&nbsp;</div>" +
				"</td>" +
				"</tr>";
			addMinutes(d, opt('slotMinutes'));
			slotCnt++;
		}
		s +=
			"</tbody>" +
			"</table>";
		slotTable = $(s).appendTo(slotContent);
		slotTableFirstInner = slotTable.find('div:first');
		
		slotBind(slotTable.find('td'));
		
		axisFirstCells = axisFirstCells.add(slotTable.find('th:first'));
	}
	
	
	
	function updateCells() {
		var i;
		var headCell;
		var bodyCell;
		var date;
		var today = clearTime(new Date());
		for (i=0; i<colCnt; i++) {
			date = colDate(i);
			headCell = dayHeadCells.eq(i);
			headCell.html(formatDate(date, colFormat));
			bodyCell = dayBodyCells.eq(i);
			if (+date == +today) {
				bodyCell.addClass(tm + '-state-highlight fc-today');
			}else{
				bodyCell.removeClass(tm + '-state-highlight fc-today');
			}
			setDayID(headCell.add(bodyCell), date);
		}
	}
	
	
	
	function setHeight(height, dateChanged) {
		if (height === undefined) {
			height = viewHeight;
		}
		viewHeight = height;
		slotTopCache = {};
	
		var headHeight = dayBody.position().top;
		var allDayHeight = slotScroller.position().top; // including divider
		var bodyHeight = Math.min( // total body height, including borders
			height - headHeight,   // when scrollbars
			slotTable.height() + allDayHeight + 1 // when no scrollbars. +1 for bottom border
		);
		
		dayBodyFirstCellStretcher
			.height(bodyHeight - vsides(dayBodyFirstCell));
		
		slotLayer.css('top', headHeight);
		
		slotScroller.height(bodyHeight - allDayHeight - 1);
		
		slotHeight = slotTableFirstInner.height() + 1; // +1 for border
		
		if (dateChanged) {
			resetScroll();
		}
	}
	
	
	
	function setWidth(width) {
		viewWidth = width;
		colContentPositions.clear();
		
		axisWidth = 0;
		setOuterWidth(
			axisFirstCells
				.width('')
				.each(function(i, _cell) {
					axisWidth = Math.max(axisWidth, $(_cell).outerWidth());
				}),
			axisWidth
		);
		
		var slotTableWidth = slotScroller[0].clientWidth; // needs to be done after axisWidth (for IE7)
		//slotTable.width(slotTableWidth);
		
		gutterWidth = slotScroller.width() - slotTableWidth;
		if (gutterWidth) {
			setOuterWidth(gutterCells, gutterWidth);
			gutterCells
				.show()
				.prev()
				.removeClass('fc-last');
		}else{
			gutterCells
				.hide()
				.prev()
				.addClass('fc-last');
		}
		
		colWidth = Math.floor((slotTableWidth - axisWidth) / colCnt);
		setOuterWidth(dayHeadCells.slice(0, -1), colWidth);
	}
	


	function resetScroll() {
		var d0 = zeroDate();
		var scrollDate = cloneDate(d0);
		scrollDate.setHours(opt('firstHour'));
		var top = timePosition(d0, scrollDate) + 1; // +1 for the border
		function scroll() {
			slotScroller.scrollTop(top);
		}
		scroll();
		setTimeout(scroll, 0); // overrides any previous scroll state made by the browser
	}
	
	
	function beforeHide() {
		savedScrollTop = slotScroller.scrollTop();
	}
	
	
	function afterShow() {
		slotScroller.scrollTop(savedScrollTop);
	}
	
	
	
	/* Slot/Day clicking and binding
	-----------------------------------------------------------------------*/
	

	function dayBind(cells) {
		cells.click(slotClick)
			.mousedown(daySelectionMousedown);
	}


	function slotBind(cells) {
		cells.click(slotClick)
			.mousedown(slotSelectionMousedown);
	}
	
	
	function slotClick(ev) {
		if (!opt('selectable')) { // if selectable, SelectionManager will worry about dayClick
			var col = Math.min(colCnt-1, Math.floor((ev.pageX - dayTable.offset().left - axisWidth) / colWidth));
			var date = colDate(col);
			var rowMatch = this.parentNode.className.match(/fc-slot(\d+)/); // TODO: maybe use data
			if (rowMatch) {
				var mins = parseInt(rowMatch[1]) * opt('slotMinutes');
				var hours = Math.floor(mins/60);
				date.setHours(hours);
				date.setMinutes(mins%60 + minMinute);
				trigger('dayClick', dayBodyCells[col], date, false, ev);
			}else{
				trigger('dayClick', dayBodyCells[col], date, true, ev);
			}
		}
	}
	
	
	
	/* Semi-transparent Overlay Helpers
	-----------------------------------------------------*/
	

	function renderDayOverlay(startDate, endDate, refreshCoordinateGrid) { // endDate is exclusive
		if (refreshCoordinateGrid) {
			coordinateGrid.build();
		}
		var visStart = cloneDate(t.visStart);
		var startCol, endCol;
		if (rtl) {
			startCol = dayDiff(endDate, visStart)*dis+dit+1;
			endCol = dayDiff(startDate, visStart)*dis+dit+1;
		}else{
			startCol = dayDiff(startDate, visStart);
			endCol = dayDiff(endDate, visStart);
		}
		startCol = Math.max(0, startCol);
		endCol = Math.min(colCnt, endCol);
		if (startCol < endCol) {
			dayBind(
				renderCellOverlay(0, startCol, 0, endCol-1)
			);
		}
	}
	
	
	function renderCellOverlay(row0, col0, row1, col1) { // only for all-day?
		var rect = coordinateGrid.rect(row0, col0, row1, col1, slotLayer);
		return renderOverlay(rect, slotLayer);
	}
	

	function renderSlotOverlay(overlayStart, overlayEnd) {
		var dayStart = cloneDate(t.visStart);
		var dayEnd = addDays(cloneDate(dayStart), 1);
		for (var i=0; i<colCnt; i++) {
			var stretchStart = new Date(Math.max(dayStart, overlayStart));
			var stretchEnd = new Date(Math.min(dayEnd, overlayEnd));
			if (stretchStart < stretchEnd) {
				var col = i*dis+dit;
				var rect = coordinateGrid.rect(0, col, 0, col, slotContent); // only use it for horizontal coords
				var top = timePosition(dayStart, stretchStart);
				var bottom = timePosition(dayStart, stretchEnd);
				rect.top = top;
				rect.height = bottom - top;
				slotBind(
					renderOverlay(rect, slotContent)
				);
			}
			addDays(dayStart, 1);
			addDays(dayEnd, 1);
		}
	}
	
	
	
	/* Coordinate Utilities
	-----------------------------------------------------------------------------*/
	
	
	coordinateGrid = new CoordinateGrid(function(rows, cols) {
		var e, n, p;
		dayHeadCells.each(function(i, _e) {
			e = $(_e);
			n = e.offset().left;
			if (i) {
				p[1] = n;
			}
			p = [n];
			cols[i] = p;
		});
		p[1] = n + e.outerWidth();
		if (opt('allDaySlot')) {
			e = allDayRow;
			n = e.offset().top;
			rows[0] = [n, n+e.outerHeight()];
		}
		var slotTableTop = slotContent.offset().top;
		var slotScrollerTop = slotScroller.offset().top;
		var slotScrollerBottom = slotScrollerTop + slotScroller.outerHeight();
		function constrain(n) {
			return Math.max(slotScrollerTop, Math.min(slotScrollerBottom, n));
		}
		for (var i=0; i<slotCnt; i++) {
			rows.push([
				constrain(slotTableTop + slotHeight*i),
				constrain(slotTableTop + slotHeight*(i+1))
			]);
		}
	});
	
	
	hoverListener = new HoverListener(coordinateGrid);
	
	
	colContentPositions = new HorizontalPositionCache(function(col) {
		return dayBodyCellInners.eq(col);
	});
	
	
	function colContentLeft(col) {
		return colContentPositions.left(col);
	}
	
	
	function colContentRight(col) {
		return colContentPositions.right(col);
	}
	
	
	
	
	function dateCell(date) { // "cell" terminology is now confusing
		return {
			row: Math.floor(dayDiff(date, t.visStart) / 7),
			col: dayOfWeekCol(date.getDay())
		};
	}
	
	
	function cellDate(cell) {
		var d = colDate(cell.col);
		var slotIndex = cell.row;
		if (opt('allDaySlot')) {
			slotIndex--;
		}
		if (slotIndex >= 0) {
			addMinutes(d, minMinute + slotIndex * opt('slotMinutes'));
		}
		return d;
	}
	
	
	function colDate(col) { // returns dates with 00:00:00
		return addDays(cloneDate(t.visStart), col*dis+dit);
	}
	
	
	function cellIsAllDay(cell) {
		return opt('allDaySlot') && !cell.row;
	}
	
	
	function dayOfWeekCol(dayOfWeek) {
		return ((dayOfWeek - Math.max(firstDay, nwe) + colCnt) % colCnt)*dis+dit;
	}
	
	
	
	
	// get the Y coordinate of the given time on the given day (both Date objects)
	function timePosition(day, time) { // both date objects. day holds 00:00 of current day
		day = cloneDate(day, true);
		if (time < addMinutes(cloneDate(day), minMinute)) {
			return 0;
		}
		if (time >= addMinutes(cloneDate(day), maxMinute)) {
			return slotTable.height();
		}
		var slotMinutes = opt('slotMinutes'),
			minutes = time.getHours()*60 + time.getMinutes() - minMinute,
			slotI = Math.floor(minutes / slotMinutes),
			slotTop = slotTopCache[slotI];
		if (slotTop === undefined) {
			slotTop = slotTopCache[slotI] = slotTable.find('tr:eq(' + slotI + ') td div')[0].offsetTop; //.position().top; // need this optimization???
		}
		return Math.max(0, Math.round(
			slotTop - 1 + slotHeight * ((minutes % slotMinutes) / slotMinutes)
		));
	}
	
	
	function allDayBounds() {
		return {
			left: axisWidth,
			right: viewWidth - gutterWidth
		}
	}
	
	
	function getAllDayRow(index) {
		return allDayRow;
	}
	
	
	function defaultEventEnd(event) {
		var start = cloneDate(event.start);
		if (event.allDay) {
			return start;
		}
		return addMinutes(start, opt('defaultEventMinutes'));
	}
	
	
	
	/* Selection
	---------------------------------------------------------------------------------*/
	
	
	function defaultSelectionEnd(startDate, allDay) {
		if (allDay) {
			return cloneDate(startDate);
		}
		return addMinutes(cloneDate(startDate), opt('slotMinutes'));
	}
	
	
	function renderSelection(startDate, endDate, allDay) { // only for all-day
		if (allDay) {
			if (opt('allDaySlot')) {
				renderDayOverlay(startDate, addDays(cloneDate(endDate), 1), true);
			}
		}else{
			renderSlotSelection(startDate, endDate);
		}
	}
	
	
	function renderSlotSelection(startDate, endDate) {
		var helperOption = opt('selectHelper');
		coordinateGrid.build();
		if (helperOption) {
			var col = dayDiff(startDate, t.visStart) * dis + dit;
			if (col >= 0 && col < colCnt) { // only works when times are on same day
				var rect = coordinateGrid.rect(0, col, 0, col, slotContent); // only for horizontal coords
				var top = timePosition(startDate, startDate);
				var bottom = timePosition(startDate, endDate);
				if (bottom > top) { // protect against selections that are entirely before or after visible range
					rect.top = top;
					rect.height = bottom - top;
					rect.left += 2;
					rect.width -= 5;
					if ($.isFunction(helperOption)) {
						var helperRes = helperOption(startDate, endDate);
						if (helperRes) {
							rect.position = 'absolute';
							rect.zIndex = 8;
							selectionHelper = $(helperRes)
								.css(rect)
								.appendTo(slotContent);
						}
					}else{
						rect.isStart = true; // conside rect a "seg" now
						rect.isEnd = true;   //
						selectionHelper = $(slotSegHtml(
							{
								title: '',
								start: startDate,
								end: endDate,
								className: ['fc-select-helper'],
								editable: false
							},
							rect
						));
						selectionHelper.css('opacity', opt('dragOpacity'));
					}
					if (selectionHelper) {
						slotBind(selectionHelper);
						slotContent.append(selectionHelper);
						setOuterWidth(selectionHelper, rect.width, true); // needs to be after appended
						setOuterHeight(selectionHelper, rect.height, true);
					}
				}
			}
		}else{
			renderSlotOverlay(startDate, endDate);
		}
	}
	
	
	function clearSelection() {
		clearOverlays();
		if (selectionHelper) {
			selectionHelper.remove();
			selectionHelper = null;
		}
	}
	
	
	function slotSelectionMousedown(ev) {
		if (ev.which == 1 && opt('selectable')) { // ev.which==1 means left mouse button
			unselect(ev);
			var dates;
			hoverListener.start(function(cell, origCell) {
				clearSelection();
				if (cell && cell.col == origCell.col && !cellIsAllDay(cell)) {
					var d1 = cellDate(origCell);
					var d2 = cellDate(cell);
					dates = [
						d1,
						addMinutes(cloneDate(d1), opt('slotMinutes')),
						d2,
						addMinutes(cloneDate(d2), opt('slotMinutes'))
					].sort(cmp);
					renderSlotSelection(dates[0], dates[3]);
				}else{
					dates = null;
				}
			}, ev);
			$(document).one('mouseup', function(ev) {
				hoverListener.stop();
				if (dates) {
					if (+dates[0] == +dates[1]) {
						reportDayClick(dates[0], false, ev);
					}
					reportSelection(dates[0], dates[3], false, ev);
				}
			});
		}
	}
	
	
	function reportDayClick(date, allDay, ev) {
		trigger('dayClick', dayBodyCells[dayOfWeekCol(date.getDay())], date, allDay, ev);
	}
	
	
	
	/* External Dragging
	--------------------------------------------------------------------------------*/
	
	
	function dragStart(_dragElement, ev, ui) {
		hoverListener.start(function(cell) {
			clearOverlays();
			if (cell) {
				if (cellIsAllDay(cell)) {
					renderCellOverlay(cell.row, cell.col, cell.row, cell.col);
				}else{
					var d1 = cellDate(cell);
					var d2 = addMinutes(cloneDate(d1), opt('defaultEventMinutes'));
					renderSlotOverlay(d1, d2);
				}
			}
		}, ev);
	}
	
	
	function dragStop(_dragElement, ev, ui) {
		var cell = hoverListener.stop();
		clearOverlays();
		if (cell) {
			trigger('drop', _dragElement, cellDate(cell), cellIsAllDay(cell), ev, ui);
		}
	}


}

function AgendaEventRenderer() {
	var t = this;
	
	
	// exports
	t.renderEvents = renderEvents;
	t.compileDaySegs = compileDaySegs; // for DayEventRenderer
	t.clearEvents = clearEvents;
	t.slotSegHtml = slotSegHtml;
	t.bindDaySeg = bindDaySeg;
	
	
	// imports
	DayEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	//var setOverflowHidden = t.setOverflowHidden;
	var isEventDraggable = t.isEventDraggable;
	var isEventResizable = t.isEventResizable;
	var eventEnd = t.eventEnd;
	var reportEvents = t.reportEvents;
	var reportEventClear = t.reportEventClear;
	var eventElementHandlers = t.eventElementHandlers;
	var setHeight = t.setHeight;
	var getDaySegmentContainer = t.getDaySegmentContainer;
	var getSlotSegmentContainer = t.getSlotSegmentContainer;
	var getHoverListener = t.getHoverListener;
	var getMaxMinute = t.getMaxMinute;
	var getMinMinute = t.getMinMinute;
	var timePosition = t.timePosition;
	var colContentLeft = t.colContentLeft;
	var colContentRight = t.colContentRight;
	var renderDaySegs = t.renderDaySegs;
	var resizableDayEvent = t.resizableDayEvent; // TODO: streamline binding architecture
	var getColCnt = t.getColCnt;
	var getColWidth = t.getColWidth;
	var getSlotHeight = t.getSlotHeight;
	var getBodyContent = t.getBodyContent;
	var reportEventElement = t.reportEventElement;
	var showEvents = t.showEvents;
	var hideEvents = t.hideEvents;
	var eventDrop = t.eventDrop;
	var eventResize = t.eventResize;
	var renderDayOverlay = t.renderDayOverlay;
	var clearOverlays = t.clearOverlays;
	var calendar = t.calendar;
	var formatDate = calendar.formatDate;
	var formatDates = calendar.formatDates;
	
	
	
	/* Rendering
	----------------------------------------------------------------------------*/
	

	function renderEvents(events, modifiedEventId) {
		reportEvents(events);
		var i, len=events.length,
			dayEvents=[],
			slotEvents=[];
		for (i=0; i<len; i++) {
			if (events[i].allDay) {
				dayEvents.push(events[i]);
			}else{
				slotEvents.push(events[i]);
			}
		}
		if (opt('allDaySlot')) {
			renderDaySegs(compileDaySegs(dayEvents), modifiedEventId);
			setHeight(); // no params means set to viewHeight
		}
		renderSlotSegs(compileSlotSegs(slotEvents), modifiedEventId);
	}
	
	
	function clearEvents() {
		reportEventClear();
		getDaySegmentContainer().empty();
		getSlotSegmentContainer().empty();
	}
	
	
	function compileDaySegs(events) {
		var levels = stackSegs(sliceSegs(events, $.map(events, exclEndDay), t.visStart, t.visEnd)),
			i, levelCnt=levels.length, level,
			j, seg,
			segs=[];
		for (i=0; i<levelCnt; i++) {
			level = levels[i];
			for (j=0; j<level.length; j++) {
				seg = level[j];
				seg.row = 0;
				seg.level = i; // not needed anymore
				segs.push(seg);
			}
		}
		return segs;
	}
	
	
	function compileSlotSegs(events) {
		var colCnt = getColCnt(),
			minMinute = getMinMinute(),
			maxMinute = getMaxMinute(),
			d = addMinutes(cloneDate(t.visStart), minMinute),
			visEventEnds = $.map(events, slotEventEnd),
			i, col,
			j, level,
			k, seg,
			segs=[];
		for (i=0; i<colCnt; i++) {
			col = stackSegs(sliceSegs(events, visEventEnds, d, addMinutes(cloneDate(d), maxMinute-minMinute)));
			countForwardSegs(col);
			for (j=0; j<col.length; j++) {
				level = col[j];
				for (k=0; k<level.length; k++) {
					seg = level[k];
					seg.col = i;
					seg.level = j;
					segs.push(seg);
				}
			}
			addDays(d, 1, true);
		}
		return segs;
	}
	
	
	function slotEventEnd(event) {
		if (event.end) {
			return cloneDate(event.end);
		}else{
			return addMinutes(cloneDate(event.start), opt('defaultEventMinutes'));
		}
	}
	
	
	// renders events in the 'time slots' at the bottom
	
	function renderSlotSegs(segs, modifiedEventId) {
	
		var i, segCnt=segs.length, seg,
			event,
			classes,
			top, bottom,
			colI, levelI, forward,
			leftmost,
			availWidth,
			outerWidth,
			left,
			html='',
			eventElements,
			eventElement,
			triggerRes,
			vsideCache={},
			hsideCache={},
			key, val,
			contentElement,
			height,
			slotSegmentContainer = getSlotSegmentContainer(),
			rtl, dis, dit,
			colCnt = getColCnt();
			
		if (rtl = opt('isRTL')) {
			dis = -1;
			dit = colCnt - 1;
		}else{
			dis = 1;
			dit = 0;
		}
			
		// calculate position/dimensions, create html
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			top = timePosition(seg.start, seg.start);
			bottom = timePosition(seg.start, seg.end);
			colI = seg.col;
			levelI = seg.level;
			forward = seg.forward || 0;
			leftmost = colContentLeft(colI*dis + dit);
			availWidth = colContentRight(colI*dis + dit) - leftmost;
			availWidth = Math.min(availWidth-6, availWidth*.95); // TODO: move this to CSS
			if (levelI) {
				// indented and thin
				outerWidth = availWidth / (levelI + forward + 1);
			}else{
				if (forward) {
					// moderately wide, aligned left still
					outerWidth = ((availWidth / (forward + 1)) - (12/2)) * 2; // 12 is the predicted width of resizer =
				}else{
					// can be entire width, aligned left
					outerWidth = availWidth;
				}
			}
			left = leftmost +                                  // leftmost possible
				(availWidth / (levelI + forward + 1) * levelI) // indentation
				* dis + (rtl ? availWidth - outerWidth : 0);   // rtl
			seg.top = top;
			seg.left = left;
			seg.outerWidth = outerWidth;
			seg.outerHeight = bottom - top;
			html += slotSegHtml(event, seg);
		}
		slotSegmentContainer[0].innerHTML = html; // faster than html()
		eventElements = slotSegmentContainer.children();
		
		// retrieve elements, run through eventRender callback, bind event handlers
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			eventElement = $(eventElements[i]); // faster than eq()
			triggerRes = trigger('eventRender', event, event, eventElement);
			if (triggerRes === false) {
				eventElement.remove();
			}else{
				if (triggerRes && triggerRes !== true) {
					eventElement.remove();
					eventElement = $(triggerRes)
						.css({
							position: 'absolute',
							top: seg.top,
							left: seg.left
						})
						.appendTo(slotSegmentContainer);
				}
				seg.element = eventElement;
				if (event._id === modifiedEventId) {
					bindSlotSeg(event, eventElement, seg);
				}else{
					eventElement[0]._fci = i; // for lazySegBind
				}
				reportEventElement(event, eventElement);
			}
		}
		
		lazySegBind(slotSegmentContainer, segs, bindSlotSeg);
		
		// record event sides and title positions
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			if (eventElement = seg.element) {
				val = vsideCache[key = seg.key = cssKey(eventElement[0])];
				seg.vsides = val === undefined ? (vsideCache[key] = vsides(eventElement, true)) : val;
				val = hsideCache[key];
				seg.hsides = val === undefined ? (hsideCache[key] = hsides(eventElement, true)) : val;
				contentElement = eventElement.find('div.fc-event-content');
				if (contentElement.length) {
					seg.contentTop = contentElement[0].offsetTop;
				}
			}
		}
		
		// set all positions/dimensions at once
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			if (eventElement = seg.element) {
				eventElement[0].style.width = Math.max(0, seg.outerWidth - seg.hsides) + 'px';
				height = Math.max(0, seg.outerHeight - seg.vsides);
				eventElement[0].style.height = height + 'px';
				event = seg.event;
				if (seg.contentTop !== undefined && height - seg.contentTop < 10) {
					// not enough room for title, put it in the time header
					eventElement.find('div.fc-event-time')
						.text(formatDate(event.start, opt('timeFormat')) + ' - ' + event.title);
					eventElement.find('div.fc-event-title')
						.remove();
				}
				trigger('eventAfterRender', event, event, eventElement);
			}
		}
					
	}
	
	
	function slotSegHtml(event, seg) {
		var html = "<";
		var url = event.url;
		var skinCss = getSkinCss(event, opt);
		var skinCssAttr = (skinCss ? " style='" + skinCss + "'" : '');
		var classes = ['fc-event', 'fc-event-skin', 'fc-event-vert'];
		if (isEventDraggable(event)) {
			classes.push('fc-event-draggable');
		}
		if (seg.isStart) {
			classes.push('fc-corner-top');
		}
		if (seg.isEnd) {
			classes.push('fc-corner-bottom');
		}
		classes = classes.concat(event.className);
		if (event.source) {
			classes = classes.concat(event.source.className || []);
		}
		if (url) {
			html += "a href='" + htmlEscape(event.url) + "'";
		}else{
			html += "div";
		}
		html +=
			" class='" + classes.join(' ') + "'" +
			" style='position:absolute;z-index:8;top:" + seg.top + "px;left:" + seg.left + "px;" + skinCss + "'" +
			">" +
			"<div class='fc-event-inner fc-event-skin'" + skinCssAttr + ">" +
			"<div class='fc-event-head fc-event-skin'" + skinCssAttr + ">" +
			"<div class='fc-event-time'>" +
			htmlEscape(formatDates(event.start, event.end, opt('timeFormat'))) +
			"</div>" +
			"</div>" +
			"<div class='fc-event-content'>" +
			"<div class='fc-event-title'>" +
			htmlEscape(event.title) +
			"</div>" +
			"</div>" +
			"<div class='fc-event-bg'></div>" +
			"</div>"; // close inner
		if (seg.isEnd && isEventResizable(event)) {
			html +=
				"<div class='ui-resizable-handle ui-resizable-s'>=</div>";
		}
		html +=
			"</" + (url ? "a" : "div") + ">";
		return html;
	}
	
	
	function bindDaySeg(event, eventElement, seg) {
		if (isEventDraggable(event)) {
			draggableDayEvent(event, eventElement, seg.isStart);
		}
		if (seg.isEnd && isEventResizable(event)) {
			resizableDayEvent(event, eventElement, seg);
		}
		eventElementHandlers(event, eventElement);
			// needs to be after, because resizableDayEvent might stopImmediatePropagation on click
	}
	
	
	function bindSlotSeg(event, eventElement, seg) {
		var timeElement = eventElement.find('div.fc-event-time');
		if (isEventDraggable(event)) {
			draggableSlotEvent(event, eventElement, timeElement);
		}
		if (seg.isEnd && isEventResizable(event)) {
			resizableSlotEvent(event, eventElement, timeElement);
		}
		eventElementHandlers(event, eventElement);
	}
	
	
	
	/* Dragging
	-----------------------------------------------------------------------------------*/
	
	
	// when event starts out FULL-DAY
	
	function draggableDayEvent(event, eventElement, isStart) {
		var origWidth;
		var revert;
		var allDay=true;
		var dayDelta;
		var dis = opt('isRTL') ? -1 : 1;
		var hoverListener = getHoverListener();
		var colWidth = getColWidth();
		var slotHeight = getSlotHeight();
		var minMinute = getMinMinute();
		eventElement.draggable({
			zIndex: 9,
			opacity: opt('dragOpacity', 'month'), // use whatever the month view was using
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {
				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);
				origWidth = eventElement.width();
				hoverListener.start(function(cell, origCell, rowDelta, colDelta) {
					clearOverlays();
					if (cell) {
						//setOverflowHidden(true);
						revert = false;
						dayDelta = colDelta * dis;
						if (!cell.row) {
							// on full-days
							renderDayOverlay(
								addDays(cloneDate(event.start), dayDelta),
								addDays(exclEndDay(event), dayDelta)
							);
							resetElement();
						}else{
							// mouse is over bottom slots
							if (isStart) {
								if (allDay) {
									// convert event to temporary slot-event
									eventElement.width(colWidth - 10); // don't use entire width
									setOuterHeight(
										eventElement,
										slotHeight * Math.round(
											(event.end ? ((event.end - event.start) / MINUTE_MS) : opt('defaultEventMinutes'))
											/ opt('slotMinutes')
										)
									);
									eventElement.draggable('option', 'grid', [colWidth, 1]);
									allDay = false;
								}
							}else{
								revert = true;
							}
						}
						revert = revert || (allDay && !dayDelta);
					}else{
						resetElement();
						//setOverflowHidden(false);
						revert = true;
					}
					eventElement.draggable('option', 'revert', revert);
				}, ev, 'drag');
			},
			stop: function(ev, ui) {
				hoverListener.stop();
				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);
				if (revert) {
					// hasn't moved or is out of bounds (draggable has already reverted)
					resetElement();
					eventElement.css('filter', ''); // clear IE opacity side-effects
					showEvents(event, eventElement);
				}else{
					// changed!
					var minuteDelta = 0;
					if (!allDay) {
						minuteDelta = Math.round((eventElement.offset().top - getBodyContent().offset().top) / slotHeight)
							* opt('slotMinutes')
							+ minMinute
							- (event.start.getHours() * 60 + event.start.getMinutes());
					}
					eventDrop(this, event, dayDelta, minuteDelta, allDay, ev, ui);
				}
				//setOverflowHidden(false);
			}
		});
		function resetElement() {
			if (!allDay) {
				eventElement
					.width(origWidth)
					.height('')
					.draggable('option', 'grid', null);
				allDay = true;
			}
		}
	}
	
	
	// when event starts out IN TIMESLOTS
	
	function draggableSlotEvent(event, eventElement, timeElement) {
		var origPosition;
		var allDay=false;
		var dayDelta;
		var minuteDelta;
		var prevMinuteDelta;
		var dis = opt('isRTL') ? -1 : 1;
		var hoverListener = getHoverListener();
		var colCnt = getColCnt();
		var colWidth = getColWidth();
		var slotHeight = getSlotHeight();
		eventElement.draggable({
			zIndex: 9,
			scroll: false,
			grid: [colWidth, slotHeight],
			axis: colCnt==1 ? 'y' : false,
			opacity: opt('dragOpacity'),
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {
				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);
				origPosition = eventElement.position();
				minuteDelta = prevMinuteDelta = 0;
				hoverListener.start(function(cell, origCell, rowDelta, colDelta) {
					eventElement.draggable('option', 'revert', !cell);
					clearOverlays();
					if (cell) {
						dayDelta = colDelta * dis;
						if (opt('allDaySlot') && !cell.row) {
							// over full days
							if (!allDay) {
								// convert to temporary all-day event
								allDay = true;
								timeElement.hide();
								eventElement.draggable('option', 'grid', null);
							}
							renderDayOverlay(
								addDays(cloneDate(event.start), dayDelta),
								addDays(exclEndDay(event), dayDelta)
							);
						}else{
							// on slots
							resetElement();
						}
					}
				}, ev, 'drag');
			},
			drag: function(ev, ui) {
				minuteDelta = Math.round((ui.position.top - origPosition.top) / slotHeight) * opt('slotMinutes');
				if (minuteDelta != prevMinuteDelta) {
					if (!allDay) {
						updateTimeText(minuteDelta);
					}
					prevMinuteDelta = minuteDelta;
				}
			},
			stop: function(ev, ui) {
				var cell = hoverListener.stop();
				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);
				if (cell && (dayDelta || minuteDelta || allDay)) {
					// changed!
					eventDrop(this, event, dayDelta, allDay ? 0 : minuteDelta, allDay, ev, ui);
				}else{
					// either no change or out-of-bounds (draggable has already reverted)
					resetElement();
					eventElement.css('filter', ''); // clear IE opacity side-effects
					eventElement.css(origPosition); // sometimes fast drags make event revert to wrong position
					updateTimeText(0);
					showEvents(event, eventElement);
				}
			}
		});
		function updateTimeText(minuteDelta) {
			var newStart = addMinutes(cloneDate(event.start), minuteDelta);
			var newEnd;
			if (event.end) {
				newEnd = addMinutes(cloneDate(event.end), minuteDelta);
			}
			timeElement.text(formatDates(newStart, newEnd, opt('timeFormat')));
		}
		function resetElement() {
			// convert back to original slot-event
			if (allDay) {
				timeElement.css('display', ''); // show() was causing display=inline
				eventElement.draggable('option', 'grid', [colWidth, slotHeight]);
				allDay = false;
			}
		}
	}
	
	
	
	/* Resizing
	--------------------------------------------------------------------------------------*/
	
	
	function resizableSlotEvent(event, eventElement, timeElement) {
		var slotDelta, prevSlotDelta;
		var slotHeight = getSlotHeight();
		eventElement.resizable({
			handles: {
				s: 'div.ui-resizable-s'
			},
			grid: slotHeight,
			start: function(ev, ui) {
				slotDelta = prevSlotDelta = 0;
				hideEvents(event, eventElement);
				eventElement.css('z-index', 9);
				trigger('eventResizeStart', this, event, ev, ui);
			},
			resize: function(ev, ui) {
				// don't rely on ui.size.height, doesn't take grid into account
				slotDelta = Math.round((Math.max(slotHeight, eventElement.height()) - ui.originalSize.height) / slotHeight);
				if (slotDelta != prevSlotDelta) {
					timeElement.text(
						formatDates(
							event.start,
							(!slotDelta && !event.end) ? null : // no change, so don't display time range
								addMinutes(eventEnd(event), opt('slotMinutes')*slotDelta),
							opt('timeFormat')
						)
					);
					prevSlotDelta = slotDelta;
				}
			},
			stop: function(ev, ui) {
				trigger('eventResizeStop', this, event, ev, ui);
				if (slotDelta) {
					eventResize(this, event, 0, opt('slotMinutes')*slotDelta, ev, ui);
				}else{
					eventElement.css('z-index', 8);
					showEvents(event, eventElement);
					// BUG: if event was really short, need to put title back in span
				}
			}
		});
	}
	

}


function countForwardSegs(levels) {
	var i, j, k, level, segForward, segBack;
	for (i=levels.length-1; i>0; i--) {
		level = levels[i];
		for (j=0; j<level.length; j++) {
			segForward = level[j];
			for (k=0; k<levels[i-1].length; k++) {
				segBack = levels[i-1][k];
				if (segsCollide(segForward, segBack)) {
					segBack.forward = Math.max(segBack.forward||0, (segForward.forward||0)+1);
				}
			}
		}
	}
}




function View(element, calendar, viewName) {
	var t = this;
	
	
	// exports
	t.element = element;
	t.calendar = calendar;
	t.name = viewName;
	t.opt = opt;
	t.trigger = trigger;
	//t.setOverflowHidden = setOverflowHidden;
	t.isEventDraggable = isEventDraggable;
	t.isEventResizable = isEventResizable;
	t.reportEvents = reportEvents;
	t.eventEnd = eventEnd;
	t.reportEventElement = reportEventElement;
	t.reportEventClear = reportEventClear;
	t.eventElementHandlers = eventElementHandlers;
	t.showEvents = showEvents;
	t.hideEvents = hideEvents;
	t.eventDrop = eventDrop;
	t.eventResize = eventResize;
	// t.title
	// t.start, t.end
	// t.visStart, t.visEnd
	
	
	// imports
	var defaultEventEnd = t.defaultEventEnd;
	var normalizeEvent = calendar.normalizeEvent; // in EventManager
	var reportEventChange = calendar.reportEventChange;
	
	
	// locals
	var eventsByID = {};
	var eventElements = [];
	var eventElementsByID = {};
	var options = calendar.options;
	
	
	
	function opt(name, viewNameOverride) {
		var v = options[name];
		if (typeof v == 'object') {
			return smartProperty(v, viewNameOverride || viewName);
		}
		return v;
	}

	
	function trigger(name, thisObj) {
		return calendar.trigger.apply(
			calendar,
			[name, thisObj || t].concat(Array.prototype.slice.call(arguments, 2), [t])
		);
	}
	
	
	/*
	function setOverflowHidden(bool) {
		element.css('overflow', bool ? 'hidden' : '');
	}
	*/
	
	
	function isEventDraggable(event) {
		return isEventEditable(event) && !opt('disableDragging');
	}
	
	
	function isEventResizable(event) { // but also need to make sure the seg.isEnd == true
		return isEventEditable(event) && !opt('disableResizing');
	}
	
	
	function isEventEditable(event) {
		return firstDefined(event.editable, (event.source || {}).editable, opt('editable'));
	}
	
	
	
	/* Event Data
	------------------------------------------------------------------------------*/
	
	
	// report when view receives new events
	function reportEvents(events) { // events are already normalized at this point
		eventsByID = {};
		var i, len=events.length, event;
		for (i=0; i<len; i++) {
			event = events[i];
			if (eventsByID[event._id]) {
				eventsByID[event._id].push(event);
			}else{
				eventsByID[event._id] = [event];
			}
		}
	}
	
	
	// returns a Date object for an event's end
	function eventEnd(event) {
		return event.end ? cloneDate(event.end) : defaultEventEnd(event);
	}
	
	
	
	/* Event Elements
	------------------------------------------------------------------------------*/
	
	
	// report when view creates an element for an event
	function reportEventElement(event, element) {
		eventElements.push(element);
		if (eventElementsByID[event._id]) {
			eventElementsByID[event._id].push(element);
		}else{
			eventElementsByID[event._id] = [element];
		}
	}
	
	
	function reportEventClear() {
		eventElements = [];
		eventElementsByID = {};
	}
	
	
	// attaches eventClick, eventMouseover, eventMouseout
	function eventElementHandlers(event, eventElement) {
		eventElement
			.click(function(ev) {
				if (!eventElement.hasClass('ui-draggable-dragging') &&
					!eventElement.hasClass('ui-resizable-resizing')) {
						return trigger('eventClick', this, event, ev);
					}
			})
			.hover(
				function(ev) {
					trigger('eventMouseover', this, event, ev);
				},
				function(ev) {
					trigger('eventMouseout', this, event, ev);
				}
			);
		// TODO: don't fire eventMouseover/eventMouseout *while* dragging is occuring (on subject element)
		// TODO: same for resizing
	}
	
	
	function showEvents(event, exceptElement) {
		eachEventElement(event, exceptElement, 'show');
	}
	
	
	function hideEvents(event, exceptElement) {
		eachEventElement(event, exceptElement, 'hide');
	}
	
	
	function eachEventElement(event, exceptElement, funcName) {
		var elements = eventElementsByID[event._id],
			i, len = elements.length;
		for (i=0; i<len; i++) {
			if (!exceptElement || elements[i][0] != exceptElement[0]) {
				elements[i][funcName]();
			}
		}
	}
	
	
	
	/* Event Modification Reporting
	---------------------------------------------------------------------------------*/
	
	
	function eventDrop(e, event, dayDelta, minuteDelta, allDay, ev, ui) {
		var oldAllDay = event.allDay;
		var eventId = event._id;
		moveEvents(eventsByID[eventId], dayDelta, minuteDelta, allDay);
		trigger(
			'eventDrop',
			e,
			event,
			dayDelta,
			minuteDelta,
			allDay,
			function() {
				// TODO: investigate cases where this inverse technique might not work
				moveEvents(eventsByID[eventId], -dayDelta, -minuteDelta, oldAllDay);
				reportEventChange(eventId);
			},
			ev,
			ui
		);
		reportEventChange(eventId);
	}
	
	
	function eventResize(e, event, dayDelta, minuteDelta, ev, ui) {
		var eventId = event._id;
		elongateEvents(eventsByID[eventId], dayDelta, minuteDelta);
		trigger(
			'eventResize',
			e,
			event,
			dayDelta,
			minuteDelta,
			function() {
				// TODO: investigate cases where this inverse technique might not work
				elongateEvents(eventsByID[eventId], -dayDelta, -minuteDelta);
				reportEventChange(eventId);
			},
			ev,
			ui
		);
		reportEventChange(eventId);
	}
	
	
	
	/* Event Modification Math
	---------------------------------------------------------------------------------*/
	
	
	function moveEvents(events, dayDelta, minuteDelta, allDay) {
		minuteDelta = minuteDelta || 0;
		for (var e, len=events.length, i=0; i<len; i++) {
			e = events[i];
			if (allDay !== undefined) {
				e.allDay = allDay;
			}
			addMinutes(addDays(e.start, dayDelta, true), minuteDelta);
			if (e.end) {
				e.end = addMinutes(addDays(e.end, dayDelta, true), minuteDelta);
			}
			normalizeEvent(e, options);
		}
	}
	
	
	function elongateEvents(events, dayDelta, minuteDelta) {
		minuteDelta = minuteDelta || 0;
		for (var e, len=events.length, i=0; i<len; i++) {
			e = events[i];
			e.end = addMinutes(addDays(eventEnd(e), dayDelta, true), minuteDelta);
			normalizeEvent(e, options);
		}
	}
	

}

function DayEventRenderer() {
	var t = this;

	
	// exports
	t.renderDaySegs = renderDaySegs;
	t.resizableDayEvent = resizableDayEvent;
	
	
	// imports
	var opt = t.opt;
	var trigger = t.trigger;
	var isEventDraggable = t.isEventDraggable;
	var isEventResizable = t.isEventResizable;
	var eventEnd = t.eventEnd;
	var reportEventElement = t.reportEventElement;
	var showEvents = t.showEvents;
	var hideEvents = t.hideEvents;
	var eventResize = t.eventResize;
	var getRowCnt = t.getRowCnt;
	var getColCnt = t.getColCnt;
	var getColWidth = t.getColWidth;
	var allDayRow = t.allDayRow;
	var allDayBounds = t.allDayBounds;
	var colContentLeft = t.colContentLeft;
	var colContentRight = t.colContentRight;
	var dayOfWeekCol = t.dayOfWeekCol;
	var dateCell = t.dateCell;
	var compileDaySegs = t.compileDaySegs;
	var getDaySegmentContainer = t.getDaySegmentContainer;
	var bindDaySeg = t.bindDaySeg; //TODO: streamline this
	var formatDates = t.calendar.formatDates;
	var renderDayOverlay = t.renderDayOverlay;
	var clearOverlays = t.clearOverlays;
	var clearSelection = t.clearSelection;
	
	
	
	/* Rendering
	-----------------------------------------------------------------------------*/
	
	
	function renderDaySegs(segs, modifiedEventId) {
		var segmentContainer = getDaySegmentContainer();
		var rowDivs;
		var rowCnt = getRowCnt();
		var colCnt = getColCnt();
		var i = 0;
		var rowI;
		var levelI;
		var colHeights;
		var j;
		var segCnt = segs.length;
		var seg;
		var top;
		var k;
		segmentContainer[0].innerHTML = daySegHTML(segs); // faster than .html()
		daySegElementResolve(segs, segmentContainer.children());
		daySegElementReport(segs);
		daySegHandlers(segs, segmentContainer, modifiedEventId);
		daySegCalcHSides(segs);
		daySegSetWidths(segs);
		daySegCalcHeights(segs);
		rowDivs = getRowDivs();
		// set row heights, calculate event tops (in relation to row top)
		for (rowI=0; rowI<rowCnt; rowI++) {
			levelI = 0;
			colHeights = [];
			for (j=0; j<colCnt; j++) {
				colHeights[j] = 0;
			}
			while (i<segCnt && (seg = segs[i]).row == rowI) {
				// loop through segs in a row
				top = arrayMax(colHeights.slice(seg.startCol, seg.endCol));
				seg.top = top;
				top += seg.outerHeight;
				for (k=seg.startCol; k<seg.endCol; k++) {
					colHeights[k] = top;
				}
				i++;
			}
			rowDivs[rowI].height(arrayMax(colHeights));
		}
		daySegSetTops(segs, getRowTops(rowDivs));
	}
	
	
	function renderTempDaySegs(segs, adjustRow, adjustTop) {
		var tempContainer = $("<div/>");
		var elements;
		var segmentContainer = getDaySegmentContainer();
		var i;
		var segCnt = segs.length;
		var element;
		tempContainer[0].innerHTML = daySegHTML(segs); // faster than .html()
		elements = tempContainer.children();
		segmentContainer.append(elements);
		daySegElementResolve(segs, elements);
		daySegCalcHSides(segs);
		daySegSetWidths(segs);
		daySegCalcHeights(segs);
		daySegSetTops(segs, getRowTops(getRowDivs()));
		elements = [];
		for (i=0; i<segCnt; i++) {
			element = segs[i].element;
			if (element) {
				if (segs[i].row === adjustRow) {
					element.css('top', adjustTop);
				}
				elements.push(element[0]);
			}
		}
		return $(elements);
	}
	
	
	function daySegHTML(segs) { // also sets seg.left and seg.outerWidth
		var rtl = opt('isRTL');
		var i;
		var segCnt=segs.length;
		var seg;
		var event;
		var url;
		var classes;
		var bounds = allDayBounds();
		var minLeft = bounds.left;
		var maxLeft = bounds.right;
		var leftCol;
		var rightCol;
		var left;
		var right;
		var skinCss;
		var html = '';
		// calculate desired position/dimensions, create html
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			classes = ['fc-event', 'fc-event-skin', 'fc-event-hori'];
			if (isEventDraggable(event)) {
				classes.push('fc-event-draggable');
			}
			if (rtl) {
				if (seg.isStart) {
					classes.push('fc-corner-right');
				}
				if (seg.isEnd) {
					classes.push('fc-corner-left');
				}
				leftCol = dayOfWeekCol(seg.end.getDay()-1);
				rightCol = dayOfWeekCol(seg.start.getDay());
				left = seg.isEnd ? colContentLeft(leftCol) : minLeft;
				right = seg.isStart ? colContentRight(rightCol) : maxLeft;
			}else{
				if (seg.isStart) {
					classes.push('fc-corner-left');
				}
				if (seg.isEnd) {
					classes.push('fc-corner-right');
				}
				leftCol = dayOfWeekCol(seg.start.getDay());
				rightCol = dayOfWeekCol(seg.end.getDay()-1);
				left = seg.isStart ? colContentLeft(leftCol) : minLeft;
				right = seg.isEnd ? colContentRight(rightCol) : maxLeft;
			}
			classes = classes.concat(event.className);
			if (event.source) {
				classes = classes.concat(event.source.className || []);
			}
			url = event.url;
			skinCss = getSkinCss(event, opt);
			if (url) {
				html += "<a href='" + htmlEscape(url) + "'";
			}else{
				html += "<div";
			}
			html +=
				" class='" + classes.join(' ') + "'" +
				" style='position:absolute;z-index:8;left:"+left+"px;" + skinCss + "'" +
				">" +
				"<div" +
				" class='fc-event-inner fc-event-skin'" +
				(skinCss ? " style='" + skinCss + "'" : '') +
				">";
			if (!event.allDay && seg.isStart) {
				html +=
					"<span class='fc-event-time'>" +
					htmlEscape(formatDates(event.start, event.end, opt('timeFormat'))) +
					"</span>";
			}
			html +=
				"<span class='fc-event-title'>" + htmlEscape(event.title) + "</span>" +
				"</div>";
			if (seg.isEnd && isEventResizable(event)) {
				html +=
					"<div class='ui-resizable-handle ui-resizable-" + (rtl ? 'w' : 'e') + "'>" +
					"&nbsp;&nbsp;&nbsp;" + // makes hit area a lot better for IE6/7
					"</div>";
			}
			html +=
				"</" + (url ? "a" : "div" ) + ">";
			seg.left = left;
			seg.outerWidth = right - left;
			seg.startCol = leftCol;
			seg.endCol = rightCol + 1; // needs to be exclusive
		}
		return html;
	}
	
	
	function daySegElementResolve(segs, elements) { // sets seg.element
		var i;
		var segCnt = segs.length;
		var seg;
		var event;
		var element;
		var triggerRes;
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			element = $(elements[i]); // faster than .eq()
			triggerRes = trigger('eventRender', event, event, element);
			if (triggerRes === false) {
				element.remove();
			}else{
				if (triggerRes && triggerRes !== true) {
					triggerRes = $(triggerRes)
						.css({
							position: 'absolute',
							left: seg.left
						});
					element.replaceWith(triggerRes);
					element = triggerRes;
				}
				seg.element = element;
			}
		}
	}
	
	
	function daySegElementReport(segs) {
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				reportEventElement(seg.event, element);
			}
		}
	}
	
	
	function daySegHandlers(segs, segmentContainer, modifiedEventId) {
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		var event;
		// retrieve elements, run through eventRender callback, bind handlers
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				event = seg.event;
				if (event._id === modifiedEventId) {
					bindDaySeg(event, element, seg);
				}else{
					element[0]._fci = i; // for lazySegBind
				}
			}
		}
		lazySegBind(segmentContainer, segs, bindDaySeg);
	}
	
	
	function daySegCalcHSides(segs) { // also sets seg.key
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		var key, val;
		var hsideCache = {};
		// record event horizontal sides
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				key = seg.key = cssKey(element[0]);
				val = hsideCache[key];
				if (val === undefined) {
					val = hsideCache[key] = hsides(element, true);
				}
				seg.hsides = val;
			}
		}
	}
	
	
	function daySegSetWidths(segs) {
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				element[0].style.width = Math.max(0, seg.outerWidth - seg.hsides) + 'px';
			}
		}
	}
	
	
	function daySegCalcHeights(segs) {
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		var key, val;
		var vmarginCache = {};
		// record event heights
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				key = seg.key; // created in daySegCalcHSides
				val = vmarginCache[key];
				if (val === undefined) {
					val = vmarginCache[key] = vmargins(element);
				}
				seg.outerHeight = element[0].offsetHeight + val;
			}
		}
	}
	
	
	function getRowDivs() {
		var i;
		var rowCnt = getRowCnt();
		var rowDivs = [];
		for (i=0; i<rowCnt; i++) {
			rowDivs[i] = allDayRow(i)
				.find('td:first div.fc-day-content > div'); // optimal selector?
		}
		return rowDivs;
	}
	
	
	function getRowTops(rowDivs) {
		var i;
		var rowCnt = rowDivs.length;
		var tops = [];
		for (i=0; i<rowCnt; i++) {
			tops[i] = rowDivs[i][0].offsetTop; // !!?? but this means the element needs position:relative if in a table cell!!!!
		}
		return tops;
	}
	
	
	function daySegSetTops(segs, rowTops) { // also triggers eventAfterRender
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		var event;
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				element[0].style.top = rowTops[seg.row] + (seg.top||0) + 'px';
				event = seg.event;
				trigger('eventAfterRender', event, event, element);
			}
		}
	}
	
	
	
	/* Resizing
	-----------------------------------------------------------------------------------*/
	
	
	function resizableDayEvent(event, element, seg) {
		var rtl = opt('isRTL');
		var direction = rtl ? 'w' : 'e';
		var handle = element.find('div.ui-resizable-' + direction);
		var isResizing = false;
		
		// TODO: look into using jquery-ui mouse widget for this stuff
		disableTextSelection(element); // prevent native <a> selection for IE
		element
			.mousedown(function(ev) { // prevent native <a> selection for others
				ev.preventDefault();
			})
			.click(function(ev) {
				if (isResizing) {
					ev.preventDefault(); // prevent link from being visited (only method that worked in IE6)
					ev.stopImmediatePropagation(); // prevent fullcalendar eventClick handler from being called
					                               // (eventElementHandlers needs to be bound after resizableDayEvent)
				}
			});
		
		handle.mousedown(function(ev) {
			if (ev.which != 1) {
				return; // needs to be left mouse button
			}
			isResizing = true;
			var hoverListener = t.getHoverListener();
			var rowCnt = getRowCnt();
			var colCnt = getColCnt();
			var dis = rtl ? -1 : 1;
			var dit = rtl ? colCnt-1 : 0;
			var elementTop = element.css('top');
			var dayDelta;
			var helpers;
			var eventCopy = $.extend({}, event);
			var minCell = dateCell(event.start);
			clearSelection();
			$('body')
				.css('cursor', direction + '-resize')
				.one('mouseup', mouseup);
			trigger('eventResizeStart', this, event, ev);
			hoverListener.start(function(cell, origCell) {
				if (cell) {
					var r = Math.max(minCell.row, cell.row);
					var c = cell.col;
					if (rowCnt == 1) {
						r = 0; // hack for all-day area in agenda views
					}
					if (r == minCell.row) {
						if (rtl) {
							c = Math.min(minCell.col, c);
						}else{
							c = Math.max(minCell.col, c);
						}
					}
					dayDelta = (r*7 + c*dis+dit) - (origCell.row*7 + origCell.col*dis+dit);
					var newEnd = addDays(eventEnd(event), dayDelta, true);
					if (dayDelta) {
						eventCopy.end = newEnd;
						var oldHelpers = helpers;
						helpers = renderTempDaySegs(compileDaySegs([eventCopy]), seg.row, elementTop);
						helpers.find('*').css('cursor', direction + '-resize');
						if (oldHelpers) {
							oldHelpers.remove();
						}
						hideEvents(event);
					}else{
						if (helpers) {
							showEvents(event);
							helpers.remove();
							helpers = null;
						}
					}
					clearOverlays();
					renderDayOverlay(event.start, addDays(cloneDate(newEnd), 1)); // coordinate grid already rebuild at hoverListener.start
				}
			}, ev);
			
			function mouseup(ev) {
				trigger('eventResizeStop', this, event, ev);
				$('body').css('cursor', '');
				hoverListener.stop();
				clearOverlays();
				if (dayDelta) {
					eventResize(this, event, dayDelta, 0, ev);
					// event redraw will clear helpers
				}
				// otherwise, the drag handler already restored the old events
				
				setTimeout(function() { // make this happen after the element's click event
					isResizing = false;
				},0);
			}
			
		});
	}
	

}

//BUG: unselect needs to be triggered when events are dragged+dropped

function SelectionManager() {
	var t = this;
	
	
	// exports
	t.select = select;
	t.unselect = unselect;
	t.reportSelection = reportSelection;
	t.daySelectionMousedown = daySelectionMousedown;
	
	
	// imports
	var opt = t.opt;
	var trigger = t.trigger;
	var defaultSelectionEnd = t.defaultSelectionEnd;
	var renderSelection = t.renderSelection;
	var clearSelection = t.clearSelection;
	
	
	// locals
	var selected = false;



	// unselectAuto
	if (opt('selectable') && opt('unselectAuto')) {
		$(document).mousedown(function(ev) {
			var ignore = opt('unselectCancel');
			if (ignore) {
				if ($(ev.target).parents(ignore).length) { // could be optimized to stop after first match
					return;
				}
			}
			unselect(ev);
		});
	}
	

	function select(startDate, endDate, allDay) {
		unselect();
		if (!endDate) {
			endDate = defaultSelectionEnd(startDate, allDay);
		}
		renderSelection(startDate, endDate, allDay);
		reportSelection(startDate, endDate, allDay);
	}
	
	
	function unselect(ev) {
		if (selected) {
			selected = false;
			clearSelection();
			trigger('unselect', null, ev);
		}
	}
	
	
	function reportSelection(startDate, endDate, allDay, ev) {
		selected = true;
		trigger('select', null, startDate, endDate, allDay, ev);
	}
	
	
	function daySelectionMousedown(ev) { // not really a generic manager method, oh well
		var cellDate = t.cellDate;
		var cellIsAllDay = t.cellIsAllDay;
		var hoverListener = t.getHoverListener();
		var reportDayClick = t.reportDayClick; // this is hacky and sort of weird
		if (ev.which == 1 && opt('selectable')) { // which==1 means left mouse button
			unselect(ev);
			var _mousedownElement = this;
			var dates;
			hoverListener.start(function(cell, origCell) { // TODO: maybe put cellDate/cellIsAllDay info in cell
				clearSelection();
				if (cell && cellIsAllDay(cell)) {
					dates = [ cellDate(origCell), cellDate(cell) ].sort(cmp);
					renderSelection(dates[0], dates[1], true);
				}else{
					dates = null;
				}
			}, ev);
			$(document).one('mouseup', function(ev) {
				hoverListener.stop();
				if (dates) {
					if (+dates[0] == +dates[1]) {
						reportDayClick(dates[0], true, ev);
					}
					reportSelection(dates[0], dates[1], true, ev);
				}
			});
		}
	}


}
 
function OverlayManager() {
	var t = this;
	
	
	// exports
	t.renderOverlay = renderOverlay;
	t.clearOverlays = clearOverlays;
	
	
	// locals
	var usedOverlays = [];
	var unusedOverlays = [];
	
	
	function renderOverlay(rect, parent) {
		var e = unusedOverlays.shift();
		if (!e) {
			e = $("<div class='fc-cell-overlay' style='position:absolute;z-index:3'/>");
		}
		if (e[0].parentNode != parent[0]) {
			e.appendTo(parent);
		}
		usedOverlays.push(e.css(rect).show());
		return e;
	}
	

	function clearOverlays() {
		var e;
		while (e = usedOverlays.shift()) {
			unusedOverlays.push(e.hide().unbind());
		}
	}


}

function CoordinateGrid(buildFunc) {

	var t = this;
	var rows;
	var cols;
	
	
	t.build = function() {
		rows = [];
		cols = [];
		buildFunc(rows, cols);
	};
	
	
	t.cell = function(x, y) {
		var rowCnt = rows.length;
		var colCnt = cols.length;
		var i, r=-1, c=-1;
		for (i=0; i<rowCnt; i++) {
			if (y >= rows[i][0] && y < rows[i][1]) {
				r = i;
				break;
			}
		}
		for (i=0; i<colCnt; i++) {
			if (x >= cols[i][0] && x < cols[i][1]) {
				c = i;
				break;
			}
		}
		return (r>=0 && c>=0) ? { row:r, col:c } : null;
	};
	
	
	t.rect = function(row0, col0, row1, col1, originElement) { // row1,col1 is inclusive
		var origin = originElement.offset();
		return {
			top: rows[row0][0] - origin.top,
			left: cols[col0][0] - origin.left,
			width: cols[col1][1] - cols[col0][0],
			height: rows[row1][1] - rows[row0][0]
		};
	};

}

function HoverListener(coordinateGrid) {


	var t = this;
	var bindType;
	var change;
	var firstCell;
	var cell;
	
	
	t.start = function(_change, ev, _bindType) {
		change = _change;
		firstCell = cell = null;
		coordinateGrid.build();
		mouse(ev);
		bindType = _bindType || 'mousemove';
		$(document).bind(bindType, mouse);
	};
	
	
	function mouse(ev) {
		var newCell = coordinateGrid.cell(ev.pageX, ev.pageY);
		if (!newCell != !cell || newCell && (newCell.row != cell.row || newCell.col != cell.col)) {
			if (newCell) {
				if (!firstCell) {
					firstCell = newCell;
				}
				change(newCell, firstCell, newCell.row-firstCell.row, newCell.col-firstCell.col);
			}else{
				change(newCell, firstCell);
			}
			cell = newCell;
		}
	}
	
	
	t.stop = function() {
		$(document).unbind(bindType, mouse);
		return cell;
	};
	
	
}

function HorizontalPositionCache(getElement) {

	var t = this,
		elements = {},
		lefts = {},
		rights = {};
		
	function e(i) {
		return elements[i] = elements[i] || getElement(i);
	}
	
	t.left = function(i) {
		return lefts[i] = lefts[i] === undefined ? e(i).position().left : lefts[i];
	};
	
	t.right = function(i) {
		return rights[i] = rights[i] === undefined ? t.left(i) + e(i).width() : rights[i];
	};
	
	t.clear = function() {
		elements = {};
		lefts = {};
		rights = {};
	};
	
}

})(jQuery);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.3.5
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the jsPlumb core code.
 *
 * Copyright (c) 2010 - 2012 Simon Porritt (simon.porritt@gmail.com)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */

;(function() {
	
	/**
	 * Class:jsPlumb
	 * The jsPlumb engine, registered as a static object in the window.  This object contains all of the methods you will use to
	 * create and maintain Connections and Endpoints.
	 */	
	
	var canvasAvailable = !!document.createElement('canvas').getContext,
		svgAvailable = !!window.SVGAngle || document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"),
	// TODO what is a good test for VML availability? aside from just assuming its there because nothing else is.
		vmlAvailable = !(canvasAvailable | svgAvailable);
	
	// finds the index of some value in an array, using a deep equals test.
	var _findIndex = function(a, v, b, s) {
		var _eq = function(o1, o2) {
			if (o1 === o2) return true;
			else if (typeof o1 == "object" && typeof o2 == "object") {
				var same = true;
				for ( var propertyName in o1) {
					if (!_eq(o1[propertyName], o2[propertyName])) {
						same = false;
						break;
					}
				}
				for ( var propertyName in o2) {
					if (!_eq(o2[propertyName], o1[propertyName])) {
						same = false;
						break;
					}
				}
				return same;
			}
			else{
			  return false;
			}
			  
		};

		for ( var i = +b || 0, l = a.length; i < l; i++) {
			if (_eq(a[i], v))
				return i;
		}
		return -1;
	},
    _findWithFunction = function(a, f) {
    	if (a)
  			for (var i = 0; i < a.length; i++) if (f(a[i])) return i;
		return -1;
	},
    _removeWithFunction = function(a, f) {
        var idx = _findWithFunction(a, f);
        if (idx > -1) a.splice(idx, 1);
        return idx != -1;
    },
    // TODO support insert index
    _addWithFunction = function(list, item, hashFunction) {
        if (_findWithFunction(list, hashFunction) == -1) list.push(item);
    };

	
	// for those browsers that dont have it.  they still don't have it! but at least they won't crash.
	if (!window.console)
		window.console = { time:function(){}, timeEnd:function(){}, group:function(){}, groupEnd:function(){}, log:function(){} };
	
	/**
		 * helper method to add an item to a list, creating the list if it does
		 * not yet exist.
		 */
		var _addToList = function(map, key, value) {
			var l = map[key];
			if (l == null) {
				l = [], map[key] = l;
			}
			l.push(value);
			return l;
		},
		_connectionBeingDragged = null,
		_getAttribute = function(el, attName) { return jsPlumb.CurrentLibrary.getAttribute(_getElementObject(el), attName); },
		_setAttribute = function(el, attName, attValue) { jsPlumb.CurrentLibrary.setAttribute(_getElementObject(el), attName, attValue); },
		_addClass = function(el, clazz) { jsPlumb.CurrentLibrary.addClass(_getElementObject(el), clazz); },
		_hasClass = function(el, clazz) { return jsPlumb.CurrentLibrary.hasClass(_getElementObject(el), clazz); },
		_removeClass = function(el, clazz) { jsPlumb.CurrentLibrary.removeClass(_getElementObject(el), clazz); },
		_getElementObject = function(el) { return jsPlumb.CurrentLibrary.getElementObject(el); },
		_getOffset = function(el) { return jsPlumb.CurrentLibrary.getOffset(_getElementObject(el)); },		
		_getSize = function(el) { return jsPlumb.CurrentLibrary.getSize(_getElementObject(el)); },
		_logEnabled = true,
		_log = function() {
		    if (_logEnabled && typeof console != "undefined") {
                try {
                    var msg = arguments[arguments.length - 1];
				    console.log(msg);
                }
                catch (e) {} 
            }
		},
		_group = function(g) {
			if (_logEnabled && typeof console != "undefined") console.group(g);
		},
		_groupEnd = function(g) {
			if (_logEnabled && typeof console != "undefined") console.groupEnd(g);
		},
		_time = function(t) {
			if (_logEnabled && typeof console != "undefined") console.time(t);
		},
		_timeEnd = function(t) {
			if (_logEnabled && typeof console != "undefined") console.timeEnd(t);
		};
		
		/**
		 * EventGenerator
		 * Superclass for objects that generate events - jsPlumb extends this, as does jsPlumbUIComponent, which all the UI elements extend.
		 */
		var EventGenerator = function() {
			var _listeners = {}, self = this;
			
			// this is a list of events that should re-throw any errors that occur during their dispatch. as of 1.3.0 this is private to
			// jsPlumb, but it seems feasible that people might want to manipulate this list.  the thinking is that we don't want event
			// listeners to bring down jsPlumb - or do we.  i can't make up my mind about this, but i know i want to hear about it if the "ready"
			// event fails, because then my page has most likely not initialised.  so i have this halfway-house solution.  it will be interesting
			// to hear what other people think.
			var eventsToDieOn = [ "ready" ];
								    
			/*
			 * Binds a listener to an event.  
			 * 
			 * Parameters:
			 * 	event		-	name of the event to bind to.
			 * 	listener	-	function to execute.
			 */
			this.bind = function(event, listener) {
				_addToList(_listeners, event, listener);				
			};
			/*
			 * Fires an update for the given event.
			 * 
			 * Parameters:
			 * 	event				-	event to fire
			 * 	value				-	value to pass to the event listener(s).
			 *  originalEvent	 	- 	the original event from the browser
			 */			
			this.fire = function(event, value, originalEvent) {
				if (_listeners[event]) {
					for ( var i = 0; i < _listeners[event].length; i++) {
						// doing it this way rather than catching and then possibly re-throwing means that an error propagated by this
						// method will have the whole call stack available in the debugger.
						if (_findIndex(eventsToDieOn, event) != -1)
							_listeners[event][i](value, originalEvent);
						else {
							// for events we don't want to die on, catch and log.
							try {
								_listeners[event][i](value, originalEvent);
							} catch (e) {
								_log("jsPlumb: fire failed for event " + event + " : " + e);
							}
						}
					}
				}
			};
			/*
			 * Clears either all listeners, or listeners for some specific event.
			 * 
			 * Parameters:
			 * 	event	-	optional. constrains the clear to just listeners for this event.
			 */
			this.clearListeners = function(event) {
				if (event)
					delete _listeners[event];
				else {
					delete _listeners;
					_listeners = {};
				}
			};
			
			this.getListener = function(forEvent) {
				return _listeners[forEvent];
			};		
		},
		
		/**
		 * creates a timestamp, using milliseconds since 1970, but as a string.
		 */
		_timestamp = function() { return "" + (new Date()).getTime(); },
		
		/*
		 * Class:jsPlumbUIComponent
		 * Abstract superclass for UI components Endpoint and Connection.  Provides the abstraction of paintStyle/hoverPaintStyle,
		 * and also extends EventGenerator to provide the bind and fire methods.
		 */
		jsPlumbUIComponent = function(params) {
			var self = this, a = arguments, _hover = false, parameters = params.parameters || {}, idPrefix = self.idPrefix,
			id = idPrefix + (new Date()).getTime();
			self._jsPlumb = params["_jsPlumb"];			
			self.getId = function() { return id; };
			self.tooltip = params.tooltip;
			self.hoverClass = params.hoverClass;				
			
			// all components can generate events
			EventGenerator.apply(this);
			// all components get this clone function.
			// TODO issue 116 showed a problem with this - it seems 'a' that is in
			// the clone function's scope is shared by all invocations of it, the classic
			// JS closure problem.  for now, jsPlumb does a version of this inline where 
			// it used to call clone.  but it would be nice to find some time to look
			// further at this.
			this.clone = function() {
				var o = new Object();
				self.constructor.apply(o, a);
				return o;
			};
			
			this.getParameter = function(name) { return parameters[name]; },
			this.getParameters = function() { return parameters; },
			this.setParameter = function(name, value) { parameters[name] = value; },
			this.setParameters = function(p) { parameters = p; },			
			this.overlayPlacements = [], 
			this.paintStyle = null, 
			this.hoverPaintStyle = null;
			
			// user can supply a beforeDetach callback, which will be executed before a detach
			// is performed; returning false prevents the detach.
			var beforeDetach = params.beforeDetach;
			this.isDetachAllowed = function(connection) {
				var r = true;
				if (beforeDetach) {
					try { 
						r = beforeDetach(connection); 
					}
					catch (e) { _log("jsPlumb: beforeDetach callback failed", e); }
				}
				return r;
			};
			
			// user can supply a beforeDrop callback, which will be executed before a dropped
			// connection is confirmed. user can return false to reject connection.
			var beforeDrop = params.beforeDrop;
			this.isDropAllowed = function(sourceId, targetId, scope) {
				var r = self._jsPlumb.checkCondition("beforeDrop", { sourceId:sourceId, targetId:targetId, scope:scope });
				if (beforeDrop) {
					try { 
						r = beforeDrop({ sourceId:sourceId, targetId:targetId, scope:scope }); 
					}
					catch (e) { _log("jsPlumb: beforeDrop callback failed", e); }
				}
				return r;
			};
			
			// helper method to update the hover style whenever it, or paintStyle, changes.
			// we use paintStyle as the foundation and merge hoverPaintStyle over the
			// top.
			var _updateHoverStyle = function() {
				if (self.paintStyle && self.hoverPaintStyle) {
					var mergedHoverStyle = {};
					jsPlumb.extend(mergedHoverStyle, self.paintStyle);
					jsPlumb.extend(mergedHoverStyle, self.hoverPaintStyle);
					delete self["hoverPaintStyle"];
					// we want the fillStyle of paintStyle to override a gradient, if possible.
					if (mergedHoverStyle.gradient && self.paintStyle.fillStyle)
						delete mergedHoverStyle["gradient"];
					self.hoverPaintStyle = mergedHoverStyle;
				}
			};
			
			/*
		     * Sets the paint style and then repaints the element.
		     * 
		     * Parameters:
		     * 	style - Style to use.
		     */
		    this.setPaintStyle = function(style, doNotRepaint) {
		    	self.paintStyle = style;
		    	self.paintStyleInUse = self.paintStyle;
		    	_updateHoverStyle();
		    	if (!doNotRepaint) self.repaint();
		    };
		    
		    /*
		     * Sets the paint style to use when the mouse is hovering over the element. This is null by default.
		     * The hover paint style is applied as extensions to the paintStyle; it does not entirely replace
		     * it.  This is because people will most likely want to change just one thing when hovering, say the
		     * color for example, but leave the rest of the appearance the same.
		     * 
		     * Parameters:
		     * 	style - Style to use when the mouse is hovering.
		     *  doNotRepaint - if true, the component will not be repainted.  useful when setting things up initially.
		     */
		    this.setHoverPaintStyle = function(style, doNotRepaint) {		    	
		    	self.hoverPaintStyle = style;
		    	_updateHoverStyle();
		    	if (!doNotRepaint) self.repaint();
		    };
		    
		    /*
		     * sets/unsets the hover state of this element.
		     * 
		     * Parameters:
		     * 	hover - hover state boolean
		     * 	ignoreAttachedElements - if true, does not notify any attached elements of the change in hover state.  used mostly to avoid infinite loops.
		     */
		    this.setHover = function(hover, ignoreAttachedElements, timestamp) {
		    	// while dragging, we ignore these events.  this keeps the UI from flashing and
		    	// swishing and whatevering.
				if (!self._jsPlumb.currentlyDragging && !self._jsPlumb.isHoverSuspended()) {
		    
			    	_hover = hover;
					if (self.hoverClass != null && self.canvas != null) {
						if (hover) 
							jpcl.addClass(self.canvas, self.hoverClass);						
						else
							jpcl.removeClass(self.canvas, self.hoverClass);
					}
		   		 	if (self.hoverPaintStyle != null) {
						self.paintStyleInUse = hover ? self.hoverPaintStyle : self.paintStyle;
						timestamp = timestamp || _timestamp();
						self.repaint({timestamp:timestamp, recalc:false});
					}
					// get the list of other affected elements, if supported by this component.
					// for a connection, its the endpoints.  for an endpoint, its the connections! surprise.
					if (self.getAttachedElements && !ignoreAttachedElements)
						_updateAttachedElements(hover, _timestamp(), self);
				}
		    };
		    
		    this.isHover = function() { return _hover; };

			var jpcl = jsPlumb.CurrentLibrary,
				events = [ "click", "dblclick", "mouseenter", "mouseout", "mousemove", "mousedown", "mouseup", "contextmenu" ],
				eventFilters = { "mouseout":"mouseexit" },
				bindOne = function(o, c, evt) {
					var filteredEvent = eventFilters[evt] || evt;
					jpcl.bind(o, evt, function(ee) {
						c.fire(filteredEvent, c, ee);
					});
				},
				unbindOne = function(o, evt) {
					var filteredEvent = eventFilters[evt] || evt;
					jpcl.unbind(o, evt);
				};
		    
		    this.attachListeners = function(o, c) {
				for (var i = 0; i < events.length; i++) {
					bindOne(o, c, events[i]); 			
				}
			};
		    
		    var _updateAttachedElements = function(state, timestamp, sourceElement) {
		    	var affectedElements = self.getAttachedElements();		// implemented in subclasses
		    	if (affectedElements) {
		    		for (var i = 0; i < affectedElements.length; i++) {
		    			if (!sourceElement || sourceElement != affectedElements[i])
		    				affectedElements[i].setHover(state, true, timestamp);			// tell the attached elements not to inform their own attached elements.
		    		}
		    	}
		    };
		    
		    this.reattachListenersForElement = function(o) {
			    if (arguments.length > 1) {
		    		for (var i = 0; i < events.length; i++)
		    			unbindOne(o, events[i]);
			    	for (var i = 1; i < arguments.length; i++)
		    			self.attachListeners(o, arguments[i]);
		    	}
		    };			
		},

		overlayCapableJsPlumbUIComponent = function(params) {
			jsPlumbUIComponent.apply(this, arguments);
			var self = this;
			/*
			 * Property: overlays
			 * List of Overlays for this component.
			 */
			this.overlays = [];

			var processOverlay = function(o) {
				var _newOverlay = null;
				if (o.constructor == Array) {	// this is for the shorthand ["Arrow", { width:50 }] syntax
					// there's also a three arg version:
					// ["Arrow", { width:50 }, {location:0.7}] 
					// which merges the 3rd arg into the 2nd.
					var type = o[0],
						// make a copy of the object so as not to mess up anyone else's reference...
						p = jsPlumb.extend({component:self, _jsPlumb:self._jsPlumb}, o[1]);
					if (o.length == 3) jsPlumb.extend(p, o[2]);
					_newOverlay = new jsPlumb.Overlays[self._jsPlumb.getRenderMode()][type](p);
					if (p.events) {
						for (var evt in p.events) {
							_newOverlay.bind(evt, p.events[evt]);
						}
					}
				} else if (o.constructor == String) {
					_newOverlay = new jsPlumb.Overlays[self._jsPlumb.getRenderMode()][o]({component:self, _jsPlumb:self._jsPlumb});
				} else {
					_newOverlay = o;
				}										
					
				self.overlays.push(_newOverlay);
			},
			calculateOverlaysToAdd = function(params) {
				var defaultKeys = self.defaultOverlayKeys || [],
					o = params.overlays,
					checkKey = function(k) {
						return self._jsPlumb.Defaults[k] || jsPlumb.Defaults[k] || [];
					};
				
				if (!o) o = [];

				for (var i = 0; i < defaultKeys.length; i++)
					o.unshift.apply(o, checkKey(defaultKeys[i]));
				
				return o;
			}

			var _overlays = calculateOverlaysToAdd(params);//params.overlays || self._jsPlumb.Defaults.Overlays;
			if (_overlays) {
				for (var i = 0; i < _overlays.length; i++) {
					processOverlay(_overlays[i]);
				}
			}

		    // overlay finder helper method
			var _getOverlayIndex = function(id) {
				var idx = -1;
				for (var i = 0; i < self.overlays.length; i++) {
					if (id === self.overlays[i].id) {
						idx = i;
						break;
					}
				}
				return idx;
			};
			
			/*
			 * Function: addOverlay
			 * Adds an Overlay to the Connection.
			 * 
			 * Parameters:
			 * 	overlay - Overlay to add.
			 */
			this.addOverlay = function(overlay) { 
				processOverlay(overlay); 
				self.repaint();
			};
			
			/*
			 * Function: getOverlay
			 * Gets an overlay, by ID. Note: by ID.  You would pass an 'id' parameter
			 * in to the Overlay's constructor arguments, and then use that to retrieve
			 * it via this method.
			 */
			this.getOverlay = function(id) {
				var idx = _getOverlayIndex(id);
				return idx >= 0 ? self.overlays[idx] : null;
			};
			
			/*
			 * Function: hideOverlay
			 * Hides the overlay specified by the given id.
			 */
			this.hideOverlay = function(id) {
				var o = self.getOverlay(id);
				if (o) o.hide();
			};
			
			/*
			 * Function: showOverlay
			 * Shows the overlay specified by the given id.
			 */
			this.showOverlay = function(id) {
				var o = self.getOverlay(id);
				if (o) o.show();
			};
			
			/**
			 * Function: removeAllOverlays
			 * Removes all overlays from the Connection, and then repaints.
			 */
			this.removeAllOverlays = function() {
				self.overlays.splice(0, self.overlays.length);
				self.repaint();
			};
			
			/**
			 * Function:removeOverlay
			 * Removes an overlay by ID.  Note: by ID.  this is a string you set in the overlay spec.
			 * Parameters:
			 * overlayId - id of the overlay to remove.
			 */
			this.removeOverlay = function(overlayId) {
				var idx = _getOverlayIndex(overlayId);
				if (idx != -1) {
					var o = self.overlays[idx];
					o.cleanup();
					self.overlays.splice(idx, 1);
				}
			};
			
			/**
			 * Function:removeOverlays
			 * Removes a set of overlays by ID.  Note: by ID.  this is a string you set in the overlay spec.
			 * Parameters:
			 * overlayIds - this function takes an arbitrary number of arguments, each of which is a single overlay id.
			 */
			this.removeOverlays = function() {
				for (var i = 0; i < arguments.length; i++)
					self.removeOverlay(arguments[i]);
			};

			// this is a shortcut helper method to let people add a label as
			// overlay.			
			var _internalLabelOverlayId = "__label",
			_makeLabelOverlay = function(params) {

				var _params = {
					cssClass:params.cssClass,
					labelStyle : this.labelStyle,					
					id:_internalLabelOverlayId,
					component:self,
					_jsPlumb:self._jsPlumb
				},
				mergedParams = jsPlumb.extend(_params, params);

				return new jsPlumb.Overlays[self._jsPlumb.getRenderMode()].Label( mergedParams );
			};
			if (params.label) {
				var loc = params.labelLocation || self.defaultLabelLocation || 0.5,
					labelStyle = params.labelStyle || self._jsPlumb.Defaults.LabelStyle || jsPlumb.Defaults.LabelStyle;			
				this.overlays.push(_makeLabelOverlay({
					label:params.label,
					location:loc,
					labelStyle:labelStyle
				}));
			}

			/*
			 * Function: setLabel
			 * Sets the Connection's label.  
			 * 
			 * Parameters:
			 * 	l	- label to set. May be a String, a Function that returns a String, or a params object containing { "label", "labelStyle", "location", "cssClass" }
			 */
			this.setLabel = function(l) {
				var lo = self.getOverlay(_internalLabelOverlayId);
				if (!lo) {
					var params = l.constructor == String || l.constructor == Function ? { label:l } : l;
					lo = _makeLabelOverlay(params);	
					this.overlays.push(lo);
				}
				else {
					if (l.constructor == String || l.constructor == Function) lo.setLabel(l);
					else {
						if (l.label) lo.setLabel(l.label);
						if (l.location) lo.setLocation(l.location);
					}
				}
				
				self.repaint();
			};

			/*
				Function:getLabel
				Returns the label text for this component (or a function if you are labelling with a function).
				This does not return the overlay itself; this is a convenience method which is a pair with
				setLabel; together they allow you to add and access a Label Overlay without having to create the
				Overlay object itself.  For access to the underlying label overlay that jsPlumb has created,
				use getLabelOverlay.
			*/
			this.getLabel = function() {
				var lo = self.getOverlay(_internalLabelOverlayId);
				return lo != null ? lo.getLabel() : null;
			};

			/*
				Function:getLabelOverlay
				Returns the underlying internal label overlay, which will exist if you specified a label on
				a connect or addEndpoint call, or have called setLabel at any stage.   
			*/
			this.getLabelOverlay = function() {
				return self.getOverlay(_internalLabelOverlayId);
			}
		},
		
		_bindListeners = function(obj, _self, _hoverFunction) {
        	obj.bind("click", function(ep, e) { _self.fire("click", _self, e); });
			obj.bind("dblclick", function(ep, e) { _self.fire("dblclick", _self, e); });
	        obj.bind("contextmenu", function(ep, e) { _self.fire("contextmenu", _self, e); });
			// this method is different; endpoint delegates hover to the first connection if there is one.
	        // that allows the connection to notify all its endpoint and avoids a circular loop
	        obj.bind("mouseenter", function(ep, e) {
				if (!_self.isHover()) {
	                _hoverFunction(true);
					_self.fire("mouseenter", _self, e);
				}
			});
	        // this method is different; endpoint delegates hover to the first connection if there is one.
	        // that allows the connection to notify all its endpoint and avoids a circular loop
			obj.bind("mouseexit", function(ep, e) {
				if (_self.isHover()) {
	                _hoverFunction(false);
					_self.fire("mouseexit", self, e);
				}
			});	
        };	
		
		var _jsPlumbInstanceIndex = 0,
			getInstanceIndex = function() {
				var i = _jsPlumbInstanceIndex + 1;
				_jsPlumbInstanceIndex++;
				return i;
			};

		var jsPlumbInstance = function(_defaults) {
		
		/*
		 * Property: Defaults 
		 * 
		 * These are the default settings for jsPlumb.  They are what will be used if you do not supply specific pieces of information 
		 * to the various API calls. A convenient way to implement your own look and feel can be to override these defaults 
		 * by including a script somewhere after the jsPlumb include, but before you make any calls to jsPlumb.
		 * 
		 * Properties:
		 * 	-	*Anchor*				    The default anchor to use for all connections (both source and target). Default is "BottomCenter".
		 * 	-	*Anchors*				    The default anchors to use ([source, target]) for all connections. Defaults are ["BottomCenter", "BottomCenter"].
		 * 	-	*Connector*				The default connector definition to use for all connections.  Default is "Bezier".
		 *  -   *Container*				Optional selector or element id that instructs jsPlumb to append elements it creates to a specific element.
		 * 	-	*DragOptions*			The default drag options to pass in to connect, makeTarget and addEndpoint calls. Default is empty.
		 * 	-	*DropOptions*			The default drop options to pass in to connect, makeTarget and addEndpoint calls. Default is empty.
		 * 	-	*Endpoint*				The default endpoint definition to use for all connections (both source and target).  Default is "Dot".
		 * 	-	*Endpoints*				The default endpoint definitions ([ source, target ]) to use for all connections.  Defaults are ["Dot", "Dot"].
		 * 	-	*EndpointStyle*			The default style definition to use for all endpoints. Default is fillStyle:"#456".
		 * 	-	*EndpointStyles*		The default style definitions ([ source, target ]) to use for all endpoints.  Defaults are empty.
		 * 	-	*EndpointHoverStyle*	The default hover style definition to use for all endpoints. Default is null.
		 * 	-	*EndpointHoverStyles*	The default hover style definitions ([ source, target ]) to use for all endpoints. Defaults are null.
		 * 	-	*HoverPaintStyle*		The default hover style definition to use for all connections. Defaults are null.
		 * 	-	*LabelStyle*			The default style to use for label overlays on connections.
		 * 	-	*LogEnabled*			Whether or not the jsPlumb log is enabled. defaults to false.
		 * 	-	*Overlays*				The default overlay definitions. Defaults to an empty list.
		 * 	-	*MaxConnections*		The default maximum number of connections for an Endpoint.  Defaults to 1.
		 * 	-	*MouseEventsEnabled*	Whether or not mouse events are enabled when using the canvas renderer.  Defaults to true.  
		 * 							The idea of this is just to give people a way to prevent all the mouse listeners from activating if they know they won't need mouse events.
		 * 	-	*PaintStyle*			The default paint style for a connection. Default is line width of 8 pixels, with color "#456".
		 * 	-	*RenderMode*			What mode to use to paint with.  If you're on IE<9, you don't really get to choose this.  You'll just get VML.  Otherwise, the jsPlumb default is to use Canvas elements.
		 * 	-	*Scope*				The default "scope" to use for connections. Scope lets you assign connections to different categories. 
		 */
		this.Defaults = {
			Anchor : "BottomCenter",
			Anchors : [ null, null ],
            ConnectionsDetachable : true,
            Connector : "Bezier",
			Container : null,
			DragOptions : { },
			DropOptions : { },
			Endpoint : "Dot",
			Endpoints : [ null, null ],
			EndpointStyle : { fillStyle : "#456" },
			EndpointStyles : [ null, null ],
			EndpointHoverStyle : null,
			EndpointHoverStyles : [ null, null ],
			HoverPaintStyle : null,
			LabelStyle : { color : "black" },
			LogEnabled : false,
			Overlays : [ ],
			MaxConnections : 1,
			MouseEventsEnabled : true, 
			PaintStyle : { lineWidth : 8, strokeStyle : "#456" },
            //Reattach:false,
			RenderMode : "svg",
			Scope : "jsPlumb_DefaultScope"
		};
		if (_defaults) jsPlumb.extend(this.Defaults, _defaults);
		
		this.logEnabled = this.Defaults.LogEnabled;

		EventGenerator.apply(this);
		var _bb = this.bind;
		this.bind = function(event, fn) {
			if ("ready" === event && initialized) fn();
			else _bb(event, fn);
		};
		var _currentInstance = this,
			_instanceIndex = getInstanceIndex(),

		log = null,
		repaintFunction = function() {
			jsPlumb.repaintEverything();
		},
		automaticRepaint = true,
		repaintEverything = function() {
			if (automaticRepaint)
				repaintFunction();
		},
		resizeTimer = null,
		initialized = false,
		connectionsByScope = {},
		/**
		 * map of element id -> endpoint lists. an element can have an arbitrary
		 * number of endpoints on it, and not all of them have to be connected
		 * to anything.
		 */
		endpointsByElement = {},
		endpointsByUUID = {},
		offsets = {},
		offsetTimestamps = {},
		floatingConnections = {},
		draggableStates = {},
		_mouseEventsEnabled = this.Defaults.MouseEventsEnabled,
		canvasList = [],
		sizes = [],
		//listeners = {}, // a map: keys are event types, values are lists of listeners.
		DEFAULT_SCOPE = this.Defaults.Scope,
		renderMode = null,  // will be set in init()							

		/**
		 * helper method to add an item to a list, creating the list if it does
		 * not yet exist.
		 */
		_addToList = function(map, key, value) {
			var l = map[key];
			if (l == null) {
				l = [];
				map[key] = l;
			}
			l.push(value);
			return l;
		},

		/**
		 * appends an element to some other element, which is calculated as follows:
		 * 
		 * 1. if _currentInstance.Defaults.Container exists, use that element.
		 * 2. if the 'parent' parameter exists, use that.
		 * 3. otherwise just use the document body.
		 * 
		 */
		_appendElement = function(el, parent) {
			if (_currentInstance.Defaults.Container)
				jsPlumb.CurrentLibrary.appendElement(el, _currentInstance.Defaults.Container);
			else if (!parent)
				document.body.appendChild(el);
			else
				jsPlumb.CurrentLibrary.appendElement(el, parent);
		},

		_curIdStamp = 1,
		_idstamp = function() { return "" + _curIdStamp++; },		
		
		/**
		 * YUI, for some reason, put the result of a Y.all call into an object that contains
		 * a '_nodes' array, instead of handing back an array-like object like the other
		 * libraries do.
		 */
		_convertYUICollection = function(c) {
			return c._nodes ? c._nodes : c;
		},

        _suspendDrawing = false,
        /*
        sets whether or not to suspend drawing.  you should use this if you need to connect a whole load of things in one go.
        it will save you a lot of time.
         */
        _setSuspendDrawing = function(val, repaintAfterwards) {
            _suspendDrawing = val;
            if (repaintAfterwards) _currentInstance.repaintEverything();
        },

		/**
		 * Draws an endpoint and its connections. this is the main entry point into drawing connections as well
		 * as endpoints, since jsPlumb is endpoint-centric under the hood.
		 * 
		 * @param element element to draw (of type library specific element object)
		 * @param ui UI object from current library's event system. optional.
		 * @param timestamp timestamp for this paint cycle. used to speed things up a little by cutting down the amount of offset calculations we do.
		 */
		_draw = function(element, ui, timestamp) {
            if (!_suspendDrawing) {
			    var id = _getAttribute(element, "id");
			    _currentInstance.anchorManager.redraw(id, ui, timestamp);
            }
		},

		/**
		 * executes the given function against the given element if the first
		 * argument is an object, or the list of elements, if the first argument
		 * is a list. the function passed in takes (element, elementId) as
		 * arguments.
		 */
		_elementProxy = function(element, fn) {
			var retVal = null;
			if (element.constructor == Array) {
				retVal = [];
				for ( var i = 0; i < element.length; i++) {
					var el = _getElementObject(element[i]), id = _getAttribute(el, "id");
					retVal.push(fn(el, id)); // append return values to what we will return
				}
			} else {
				var el = _getElementObject(element), id = _getAttribute(el, "id");
				retVal = fn(el, id);
			}
			return retVal;
		},				

		/**
		 * gets an Endpoint by uuid.
		 */
		_getEndpoint = function(uuid) { return endpointsByUUID[uuid]; },

		/**
		 * inits a draggable if it's not already initialised.
		 */
		_initDraggableIfNecessary = function(element, isDraggable, dragOptions) {
			var draggable = isDraggable == null ? false : isDraggable;
			if (draggable) {
				if (jsPlumb.CurrentLibrary.isDragSupported(element) && !jsPlumb.CurrentLibrary.isAlreadyDraggable(element)) {
					var options = dragOptions || _currentInstance.Defaults.DragOptions || jsPlumb.Defaults.DragOptions;
					options = jsPlumb.extend( {}, options); // make a copy.
					var dragEvent = jsPlumb.CurrentLibrary.dragEvents["drag"],
						stopEvent = jsPlumb.CurrentLibrary.dragEvents["stop"];
					options[dragEvent] = _wrap(options[dragEvent], function() {
						var ui = jsPlumb.CurrentLibrary.getUIPosition(arguments);
						_draw(element, ui);
						_addClass(element, "jsPlumb_dragged");
					});
					options[stopEvent] = _wrap(options[stopEvent], function() {
						var ui = jsPlumb.CurrentLibrary.getUIPosition(arguments);
						_draw(element, ui);
						_removeClass(element, "jsPlumb_dragged");
					});
					draggableStates[_getId(element)] = true;
					var draggable = draggableStates[_getId(element)];
					options.disabled = draggable == null ? false : !draggable;
					jsPlumb.CurrentLibrary.initDraggable(element, options, false);
				}
			}
		},
		
		/*
		* prepares a final params object that can be passed to _newConnection, taking into account defaults, events, etc.
		*/
		_prepareConnectionParams = function(params, referenceParams) {
			var _p = jsPlumb.extend( {}, params);
			if (referenceParams) jsPlumb.extend(_p, referenceParams);
			
			if (_p.source && _p.source.endpoint) _p.sourceEndpoint = _p.source;
			if (_p.source && _p.target.endpoint) _p.targetEndpoint = _p.target;
			
			// test for endpoint uuids to connect
			if (params.uuids) {
				_p.sourceEndpoint = _getEndpoint(params.uuids[0]);
				_p.targetEndpoint = _getEndpoint(params.uuids[1]);
			}

			// now ensure that if we do have Endpoints already, they're not full.
			if (_p.sourceEndpoint && _p.sourceEndpoint.isFull()) {
				_log(_currentInstance, "could not add connection; source endpoint is full");
				return;
			}

			if (_p.targetEndpoint && _p.targetEndpoint.isFull()) {
				_log(_currentInstance, "could not add connection; target endpoint is full");
				return;
			}			
			
			// copy in any connectorOverlays that were specified on the source endpoint.
			// it doesnt copy target endpoint overlays.  i'm not sure if we want it to or not.
			if (_p.sourceEndpoint && _p.sourceEndpoint.connectorOverlays) {
				_p.overlays = _p.overlays || [];
				for (var i = 0; i < _p.sourceEndpoint.connectorOverlays.length; i++) {
					_p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);
				}
			}
			
			// tooltip.  params.tooltip takes precedence, then sourceEndpoint.connectorTooltip.
			_p.tooltip = params.tooltip;
			if (!_p.tooltip && _p.sourceEndpoint && _p.sourceEndpoint.connectorTooltip)
				_p.tooltip = _p.sourceEndpoint.connectorTooltip;
			
			if (_p.target && !_p.target.endpoint) {
				var tid = _getId(_p.target),
				tep =_targetEndpointDefinitions[tid];

				var overrideOne = function(singlePropertyName, pluralPropertyName, tepProperty, tep) {
					if (tep[tepProperty]) {
						if (_p[pluralPropertyName]) _p[pluralPropertyName][1] = tep[tepProperty];
						else if (_p[singlePropertyName]) {
							_p[pluralPropertyName] = [ _p[singlePropertyName], tep[tepProperty] ];
							_p[singlePropertyName] = null;
						}
						else _p[pluralPropertyName] = [ null, tep[tepProperty] ];
					}
				};

				if (tep) {
					overrideOne("endpoint", "endpoints", "endpoint", tep);
					overrideOne("endpointStyle", "endpointStyles", "paintStyle", tep);
					overrideOne("endpointHoverStyle", "endpointHoverStyles", "hoverPaintStyle", tep);
				}
			}
			
			return _p;
		},
		
		_newConnection = function(params) {
			var connectionFunc = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
			    endpointFunc = _currentInstance.Defaults.EndpointType || Endpoint,
			    parent = jsPlumb.CurrentLibrary.getParent;
			
			if (params.container)
				params["parent"] = params.container;
			else {
				if (params.sourceEndpoint)
					params["parent"] = params.sourceEndpoint.parent;
				else if (params.source.constructor == endpointFunc)
					params["parent"] = params.source.parent;
				else params["parent"] = parent(params.source);
			}
			
			params["_jsPlumb"] = _currentInstance;
			var con = new connectionFunc(params);
			con.id = "con_" + _idstamp();
			_eventFireProxy("click", "click", con);
			_eventFireProxy("dblclick", "dblclick", con);
            _eventFireProxy("contextmenu", "contextmenu", con);
			return con;
		},
		
		/**
		* adds the connection to the backing model, fires an event if necessary and then redraws
		*/
		_finaliseConnection = function(jpc, params, originalEvent) {
            params = params || {};
			// add to list of connections (by scope).
            if (!jpc.suspendedEndpoint)
			    _addToList(connectionsByScope, jpc.scope, jpc);
			// fire an event
			if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {
				_currentInstance.fire("jsPlumbConnection", {
					connection:jpc,
					source : jpc.source, target : jpc.target,
					sourceId : jpc.sourceId, targetId : jpc.targetId,
					sourceEndpoint : jpc.endpoints[0], targetEndpoint : jpc.endpoints[1]
				}, originalEvent);
			}
            // always inform the anchor manager
            // except that if jpc has a suspended endpoint it's not true to say the
            // connection is new; it has just (possibly) moved. the question is whether
            // to make that call here or in the anchor manager.  i think perhaps here.
            _currentInstance.anchorManager.newConnection(jpc);
			// force a paint
			_draw(jpc.source);
		},
		
		_eventFireProxy = function(event, proxyEvent, obj) {
			obj.bind(event, function(originalObject, originalEvent) {
				_currentInstance.fire(proxyEvent, obj, originalEvent);
			});
		},
		
		/**
		 * for the given endpoint params, returns an appropriate parent element for the UI elements that will be added.
		 * this function is used by _newEndpoint (directly below), and also in the makeSource function in jsPlumb.
		 * 
		 *   the logic is to first look for a "container" member of params, and pass that back if found.  otherwise we
		 *   handoff to the 'getParent' function in the current library.
		 */
		_getParentFromParams = function(params) {
			if (params.container)
				return params.container;
			else {
                var tag = jsPlumb.CurrentLibrary.getTagName(params.source),
                    p = jsPlumb.CurrentLibrary.getParent(params.source);
                if (tag && tag.toLowerCase() === "td")
                    return jsPlumb.CurrentLibrary.getParent(p);
                else return p;
            }
		},
		
		/**
			factory method to prepare a new endpoint.  this should always be used instead of creating Endpoints
			manually, since this method attaches event listeners and an id.
		*/
		_newEndpoint = function(params) {
			var endpointFunc = _currentInstance.Defaults.EndpointType || Endpoint;
			params.parent = _getParentFromParams(params);
			params["_jsPlumb"] = _currentInstance;
			var ep = new endpointFunc(params);
			ep.id = "ep_" + _idstamp();
			_eventFireProxy("click", "endpointClick", ep);
			_eventFireProxy("dblclick", "endpointDblClick", ep);
            _eventFireProxy("contextmenu", "contextmenu", ep);
			return ep;
		},
		
		/**
		 * performs the given function operation on all the connections found
		 * for the given element id; this means we find all the endpoints for
		 * the given element, and then for each endpoint find the connectors
		 * connected to it. then we pass each connection in to the given
		 * function.
		 */
		_operation = function(elId, func, endpointFunc) {
			var endpoints = endpointsByElement[elId];
			if (endpoints && endpoints.length) {
				for ( var i = 0; i < endpoints.length; i++) {
					for ( var j = 0; j < endpoints[i].connections.length; j++) {
						var retVal = func(endpoints[i].connections[j]);
						// if the function passed in returns true, we exit.
						// most functions return false.
						if (retVal) return;
					}
					if (endpointFunc) endpointFunc(endpoints[i]);
				}
			}
		},
		/**
		 * perform an operation on all elements.
		 */
		_operationOnAll = function(func) {
			for ( var elId in endpointsByElement) {
				_operation(elId, func);
			}
		},		
		
		/**
		 * helper to remove an element from the DOM.
		 */
		_removeElement = function(element, parent) {
			if (element != null && element.parentNode != null) {
				element.parentNode.removeChild(element);
			}
		},
		/**
		 * helper to remove a list of elements from the DOM.
		 */
		_removeElements = function(elements, parent) {
			for ( var i = 0; i < elements.length; i++)
				_removeElement(elements[i], parent);
		},
		/**
		 * Sets whether or not the given element(s) should be draggable,
		 * regardless of what a particular plumb command may request.
		 * 
		 * @param element
		 *            May be a string, a element objects, or a list of
		 *            strings/elements.
		 * @param draggable
		 *            Whether or not the given element(s) should be draggable.
		 */
		_setDraggable = function(element, draggable) {
			return _elementProxy(element, function(el, id) {
				draggableStates[id] = draggable;
				if (jsPlumb.CurrentLibrary.isDragSupported(el)) {
					jsPlumb.CurrentLibrary.setDraggable(el, draggable);
				}
			});
		},
		/**
		 * private method to do the business of hiding/showing.
		 * 
		 * @param el
		 *            either Id of the element in question or a library specific
		 *            object for the element.
		 * @param state
		 *            String specifying a value for the css 'display' property
		 *            ('block' or 'none').
		 */
		_setVisible = function(el, state, alsoChangeEndpoints) {
			state = state === "block";
			var endpointFunc = null;
			if (alsoChangeEndpoints) {
				if (state) endpointFunc = function(ep) {
					ep.setVisible(true, true, true);
				};
				else endpointFunc = function(ep) {
					ep.setVisible(false, true, true);
				};
			}
			var id = _getAttribute(el, "id");
			_operation(id, function(jpc) {
				if (state && alsoChangeEndpoints) {		
					// this test is necessary because this functionality is new, and i wanted to maintain backwards compatibility.
					// this block will only set a connection to be visible if the other endpoint in the connection is also visible.
					var oidx = jpc.sourceId === id ? 1 : 0;
					if (jpc.endpoints[oidx].isVisible()) jpc.setVisible(true);
				}
				else  // the default behaviour for show, and what always happens for hide, is to just set the visibility without getting clever.
					jpc.setVisible(state);
			}, endpointFunc);
		},
		/**
		 * toggles the draggable state of the given element(s).
		 * 
		 * @param el
		 *            either an id, or an element object, or a list of
		 *            ids/element objects.
		 */
		_toggleDraggable = function(el) {
			return _elementProxy(el, function(el, elId) {
				var state = draggableStates[elId] == null ? false : draggableStates[elId];
				state = !state;
				draggableStates[elId] = state;
				jsPlumb.CurrentLibrary.setDraggable(el, state);
				return state;
			});
		},
		/**
		 * private method to do the business of toggling hiding/showing.
		 * 
		 * @param elId
		 *            Id of the element in question
		 */
		_toggleVisible = function(elId, changeEndpoints) {
			var endpointFunc = null;
			if (changeEndpoints) {
				endpointFunc = function(ep) {
					var state = ep.isVisible();
					ep.setVisible(!state);
				};
			}
			_operation(elId, function(jpc) {
				var state = jpc.isVisible();
				jpc.setVisible(!state);				
			}, endpointFunc);
			// todo this should call _elementProxy, and pass in the
			// _operation(elId, f) call as a function. cos _toggleDraggable does
			// that.
		},
		/**
		 * updates the offset and size for a given element, and stores the
		 * values. if 'offset' is not null we use that (it would have been
		 * passed in from a drag call) because it's faster; but if it is null,
		 * or if 'recalc' is true in order to force a recalculation, we get the current values.
		 */
		_updateOffset = function(params) {
			var timestamp = params.timestamp, recalc = params.recalc, offset = params.offset, elId = params.elId;
			if (!recalc) {
				if (timestamp && timestamp === offsetTimestamps[elId])
					return offsets[elId];
			}
			if (recalc || !offset) { // if forced repaint or no offset
											// available, we recalculate.
				// get the current size and offset, and store them
				var s = _getElementObject(elId);
				if (s != null) {
					sizes[elId] = _getSize(s);
					offsets[elId] = _getOffset(s);
					offsetTimestamps[elId] = timestamp;
				}
			} else {
				offsets[elId] = offset;
                if (sizes[elId] == null) {
                    var s = _getElementObject(elId);
				    if (s != null)
					    sizes[elId] = _getSize(s);
                }
			}
			
			if(offsets[elId] && !offsets[elId].right) {
				offsets[elId].right = offsets[elId].left + sizes[elId][0];
				offsets[elId].bottom = offsets[elId].top + sizes[elId][1];	
				offsets[elId].width = sizes[elId][0];
				offsets[elId].height = sizes[elId][1];	
				offsets[elId].centerx = offsets[elId].left + (offsets[elId].width / 2);
				offsets[elId].centery = offsets[elId].top + (offsets[elId].height / 2);				
			}
			return offsets[elId];
		},

		// TODO comparison performance
		_getCachedData = function(elId) {
			var o = offsets[elId];
			if (!o) o = _updateOffset({elId:elId});
			return {o:o, s:sizes[elId]};
		},

		/**
		 * gets an id for the given element, creating and setting one if
		 * necessary.  the id is of the form
		 *
		 *	jsPlumb_<instance index>_<index in instance>
		 *
		 * where "index in instance" is a monotonically increasing integer that starts at 0,
		 * for each instance.  this method is used not only to assign ids to elements that do not
		 * have them but also to connections and endpoints.
		 */
		_getId = function(element, uuid) {
			var ele = _getElementObject(element);
			var id = _getAttribute(ele, "id");
			if (!id || id == "undefined") {
				// check if fixed uuid parameter is given
				if (arguments.length == 2 && arguments[1] != undefined)
					id = uuid;
				else
					id = "jsPlumb_" + _instanceIndex + "_" + _idstamp();
				_setAttribute(ele, "id", id);
			}
			return id;
		},

		/**
		 * wraps one function with another, creating a placeholder for the
		 * wrapped function if it was null. this is used to wrap the various
		 * drag/drop event functions - to allow jsPlumb to be notified of
		 * important lifecycle events without imposing itself on the user's
		 * drag/drop functionality. TODO: determine whether or not we should
		 * support an error handler concept, if one of the functions fails.
		 * 
		 * @param wrappedFunction original function to wrap; may be null.
		 * @param newFunction function to wrap the original with.
		 * @param returnOnThisValue Optional. Indicates that the wrappedFunction should 
		 * not be executed if the newFunction returns a value matching 'returnOnThisValue'.
		 * note that this is a simple comparison and only works for primitives right now.
		 */
		_wrap = function(wrappedFunction, newFunction, returnOnThisValue) {
			wrappedFunction = wrappedFunction || function() { };
			newFunction = newFunction || function() { };
			return function() {
				var r = null;
				try {
					r = newFunction.apply(this, arguments);
				} catch (e) {
					_log(_currentInstance, 'jsPlumb function failed : ' + e);
				}
				if (returnOnThisValue == null || (r !== returnOnThisValue)) {
					try {
						wrappedFunction.apply(this, arguments);
					} catch (e) {
						_log(_currentInstance, 'wrapped function failed : ' + e);
					}
				}
				return r;
			};
		};	

		/*
		 * Property: connectorClass 
		 *   The CSS class to set on Connection elements. This value is a String and can have multiple classes; the entire String is appended as-is.
		 */
		this.connectorClass = "_jsPlumb_connector";

		/*
		 * Property: endpointClass 
		 *   The CSS class to set on Endpoint elements. This value is a String and can have multiple classes; the entire String is appended as-is.
		 */
		this.endpointClass = "_jsPlumb_endpoint";

		/*
		 * Property: overlayClass 
		 * The CSS class to set on an Overlay that is an HTML element. This value is a String and can have multiple classes; the entire String is appended as-is.
		 */
		this.overlayClass = "_jsPlumb_overlay";
		
		this.Anchors = {};
		
		this.Connectors = { 
			"canvas":{},
			"svg":{},
			"vml":{}
		};

		this.Endpoints = {
			"canvas":{},
			"svg":{},
			"vml":{}
		};

		this.Overlays = {
			"canvas":{},
			"svg":{},
			"vml":{}
		};
		
// ************************ PLACEHOLDER DOC ENTRIES FOR NATURAL DOCS *****************************************
		/*
		 * Function: bind
		 * Bind to an event on jsPlumb.  
		 * 
		 * Parameters:
		 * 	event - the event to bind.  Available events on jsPlumb are:
		 *         - *jsPlumbConnection* 			: 	notification that a new Connection was established.  jsPlumb passes the new Connection to the callback.
		 *         - *jsPlumbConnectionDetached* 	: 	notification that a Connection was detached.  jsPlumb passes the detached Connection to the callback.
		 *         - *click*						:	notification that a Connection was clicked.  jsPlumb passes the Connection that was clicked to the callback.
		 *         - *dblclick*						:	notification that a Connection was double clicked.  jsPlumb passes the Connection that was double clicked to the callback.
		 *         - *endpointClick*				:	notification that an Endpoint was clicked.  jsPlumb passes the Endpoint that was clicked to the callback.
		 *         - *endpointDblClick*				:	notification that an Endpoint was double clicked.  jsPlumb passes the Endpoint that was double clicked to the callback.
		 *         
		 *  callback - function to callback. This function will be passed the Connection/Endpoint that caused the event, and also the original event.    
		 */
		
		/*
		 * Function: clearListeners
		 * Clears either all listeners, or listeners for some specific event.
		 * 
		 * Parameters:
		 * 	event	-	optional. constrains the clear to just listeners for this event.
		 */				
		
// *************** END OF PLACEHOLDER DOC ENTRIES FOR NATURAL DOCS ***********************************************************		
		
		/*
		 Function: addClass
		 
		 Helper method to abstract out differences in setting css classes on the different renderer types.
		*/
		this.addClass = function(el, clazz) {
			return jsPlumb.CurrentLibrary.addClass(el, clazz);
		};
		
		/*
		 Function: removeClass
		 
		 Helper method to abstract out differences in setting css classes on the different renderer types.
		*/
		this.removeClass = function(el, clazz) {
			return jsPlumb.CurrentLibrary.removeClass(el, clazz);
		};
		
		/*
		 Function: hasClass
		 
		 Helper method to abstract out differences in testing for css classes on the different renderer types.
		*/
		this.hasClass = function(el, clazz) {
			return jsPlumb.CurrentLibrary.hasClass(el, clazz);
		};
		
		/*
		  Function: addEndpoint 
		  	
		  Adds an <Endpoint> to a given element or elements.
		  			  
		  Parameters:
		   
		  	el - Element to add the endpoint to. Either an element id, a selector representing some element(s), or an array of either of these. 
		  	params - Object containing Endpoint constructor arguments.  For more information, see <Endpoint>.
		  	referenceParams - Object containing more Endpoint constructor arguments; it will be merged with params by jsPlumb.  You would use this if you had some 
		  					  shared parameters that you wanted to reuse when you added Endpoints to a number of elements. The allowed values in
		  					  this object are anything that 'params' can contain.  See <Endpoint>.
		  	 
		  Returns: 
		  	The newly created <Endpoint>, if el referred to a single element.  Otherwise, an array of newly created <Endpoint>s. 
		  	
		  See Also: 
		  	<addEndpoints>
		 */
		this.addEndpoint = function(el, params, referenceParams) {
			referenceParams = referenceParams || {};
			var p = jsPlumb.extend({}, referenceParams);
			jsPlumb.extend(p, params);
			p.endpoint = p.endpoint || _currentInstance.Defaults.Endpoint || jsPlumb.Defaults.Endpoint;
			p.paintStyle = p.paintStyle || _currentInstance.Defaults.EndpointStyle || jsPlumb.Defaults.EndpointStyle;
            // YUI wrapper
			el = _convertYUICollection(el);			
			
			var results = [], inputs = el.length && el.constructor != String ? el : [ el ];
						
			for (var i = 0; i < inputs.length; i++) {
				var _el = _getElementObject(inputs[i]), id = _getId(_el);
				p.source = _el;
                _updateOffset({ elId : id });
				var e = _newEndpoint(p);
				if (p.parentAnchor) e.parentAnchor = p.parentAnchor;
				_addToList(endpointsByElement, id, e);
				var myOffset = offsets[id], myWH = sizes[id];
				var anchorLoc = e.anchor.compute( { xy : [ myOffset.left, myOffset.top ], wh : myWH, element : e });
				e.paint({ anchorLoc : anchorLoc });
				results.push(e);
			}
			
			return results.length == 1 ? results[0] : results;
		};
		
		/*
		  Function: addEndpoints 
		  Adds a list of <Endpoint>s to a given element or elements.
		  
		  Parameters: 
		  	target - element to add the Endpoint to. Either an element id, a selector representing some element(s), or an array of either of these. 
		  	endpoints - List of objects containing Endpoint constructor arguments. one Endpoint is created for each entry in this list.  See <Endpoint>'s constructor documentation. 
			referenceParams - Object containing more Endpoint constructor arguments; it will be merged with params by jsPlumb.  You would use this if you had some shared parameters that you wanted to reuse when you added Endpoints to a number of elements.		  	 

		  Returns: 
		  	List of newly created <Endpoint>s, one for each entry in the 'endpoints' argument. 
		  	
		  See Also:
		  	<addEndpoint>
		 */
		this.addEndpoints = function(el, endpoints, referenceParams) {
			var results = [];
			for ( var i = 0; i < endpoints.length; i++) {
				var e = _currentInstance.addEndpoint(el, endpoints[i], referenceParams);
				if (e.constructor == Array)
					Array.prototype.push.apply(results, e);
				else results.push(e);
			}
			return results;
		};

		/*
		  Function: animate 
		  This is a wrapper around the supporting library's animate function; it injects a call to jsPlumb in the 'step' function (creating
		  the 'step' function if necessary). This only supports the two-arg version of the animate call in jQuery, the one that takes an 'options' object as
		  the second arg. MooTools has only one method, a two arg one. Which is handy.  YUI has a one-arg method, so jsPlumb merges 'properties' and 'options' together for YUI.
		   
		  Parameters: 
		  	el - Element to animate. Either an id, or a selector representing the element. 
		  	properties - The 'properties' argument you want passed to the library's animate call. 
		   	options - The 'options' argument you want passed to the library's animate call.
		    
		  Returns: 
		  	void
		 */
		this.animate = function(el, properties, options) {
			var ele = _getElementObject(el), id = _getAttribute(el, "id");
			options = options || {};
			var stepFunction = jsPlumb.CurrentLibrary.dragEvents['step'];
			var completeFunction = jsPlumb.CurrentLibrary.dragEvents['complete'];
			options[stepFunction] = _wrap(options[stepFunction], function() {
				_currentInstance.repaint(id);
			});

			// onComplete repaints, just to make sure everything looks good at the end of the animation.
			options[completeFunction] = _wrap(options[completeFunction],
					function() {
						_currentInstance.repaint(id);
					});

			jsPlumb.CurrentLibrary.animate(ele, properties, options);
		};		
		
		/**
		* checks for a listener for the given condition, executing it if found, passing in the given value.
		* condition listeners would have been attached using "bind" (which is, you could argue, now overloaded, since
		* firing click events etc is a bit different to what this does).  i thought about adding a "bindCondition"
		* or something, but decided against it, for the sake of simplicity. jsPlumb will never fire one of these
		* condition events anyway.
		*/
		this.checkCondition = function(conditionName, value) {
			var l = _currentInstance.getListener(conditionName);
			var r = true;
			if (l && l.length > 0) {
				try {
					for (var i = 0 ; i < l.length; i++) {
						r = r && l[i](value); 
					}
				}
				catch (e) { 
					_log(_currentInstance, "cannot check condition [" + conditionName + "]" + e); 
				}
			}
			return r;
		};

		/*
		  Function: connect 
		  Establishes a <Connection> between two elements (or <Endpoint>s, which are themselves registered to elements).
		  
		  Parameters: 
		    params - Object containing constructor arguments for the Connection. See <Connection>'s constructor documentation.
		    referenceParams - Optional object containing more constructor arguments for the Connection. Typically you would pass in data that a lot of 
		    Connections are sharing here, such as connector style etc, and then use the main params for data specific to this Connection.
		     
		  Returns: 
		  	The newly created <Connection>.
		 */
		this.connect = function(params, referenceParams) {
			// prepare a final set of parameters to create connection with
			var _p = _prepareConnectionParams(params, referenceParams);
			// TODO probably a nicer return value if the connection was not made.  _prepareConnectionParams
			// will return null (and log something) if either endpoint was full.  what would be nicer is to 
			// create a dedicated 'error' object.
			if (_p) {
				// a connect call will delete its created endpoints on detach, unless otherwise specified.
				// this is because the endpoints belong to this connection only, and are no use to
				// anyone else, so they hang around like a bad smell.
				if (_p.deleteEndpointsOnDetach == null)
					_p.deleteEndpointsOnDetach = true;

				// create the connection.  it is not yet registered 
				var jpc = _newConnection(_p);
				// now add it the model, fire an event, and redraw
				_finaliseConnection(jpc, _p);						
				return jpc;
			}
		};
		
		/*
		 Function: deleteEndpoint		 
		 Deletes an Endpoint and removes all Connections it has (which removes the Connections from the other Endpoints involved too)
		 
		 Parameters:
		 	object - either an <Endpoint> object (such as from an addEndpoint call), or a String UUID.
		 	
		 Returns:
		 	void		  
		 */
		this.deleteEndpoint = function(object) {
			var endpoint = (typeof object == "string") ? endpointsByUUID[object] : object;			
			if (endpoint) {					
				var uuid = endpoint.getUuid();
				if (uuid) endpointsByUUID[uuid] = null;				
				endpoint.detachAll();				
				_removeElements(endpoint.endpoint.getDisplayElements());
				_currentInstance.anchorManager.deleteEndpoint(endpoint);
				for (var e in endpointsByElement) {
					var endpoints = endpointsByElement[e];
					if (endpoints) {
						var newEndpoints = [];
						for (var i = 0; i < endpoints.length; i++)
							if (endpoints[i] != endpoint) newEndpoints.push(endpoints[i]);
						
						endpointsByElement[e] = newEndpoints;
					}
				}
				delete endpoint;								
			}									
		};
		
		/*
		 Function: deleteEveryEndpoint
		  Deletes every <Endpoint>, and their associated <Connection>s, in this instance of jsPlumb. Does not unregister any event listeners (this is the only difference
between this method and jsPlumb.reset).  
		  
		 Returns: 
		 	void 
		 */
		this.deleteEveryEndpoint = function() {
			for ( var id in endpointsByElement) {
				var endpoints = endpointsByElement[id];
				if (endpoints && endpoints.length) {
					for ( var i = 0; i < endpoints.length; i++) {
						_currentInstance.deleteEndpoint(endpoints[i]);
					}
				}
			}
			delete endpointsByElement;
			endpointsByElement = {};
			delete endpointsByUUID;
			endpointsByUUID = {};
		};

		var fireDetachEvent = function(jpc, doFireEvent) {
            // may have been given a connection, or in special cases, an object
            var connType =  _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
                argIsConnection = jpc.constructor == connType,
                params = argIsConnection ? {
                    connection:jpc,
				    source : jpc.source, target : jpc.target,
				    sourceId : jpc.sourceId, targetId : jpc.targetId,
				    sourceEndpoint : jpc.endpoints[0], targetEndpoint : jpc.endpoints[1]
                } : jpc;

			if (doFireEvent) _currentInstance.fire("jsPlumbConnectionDetached", params);
            _currentInstance.anchorManager.connectionDetached(params);
		};

		/*
		  Function: detach 
		  Detaches and then removes a <Connection>.  From 1.3.5 this method has been altered to remove support for
		  specifying Connections by various parameters; you can now pass in a Connection as the first argument and
		  an optional parameters object as a second argument.  If you need the functionality this method provided
		  before 1.3.5 then you should use the getConnections method to get the list of Connections to detach, and
		  then iterate through them, calling this for each one.
		  		   
		  Parameters: 
		    connection  -   the <Connection> to detach
		    params      -   optional parameters to the detach call.  valid values here are
		                    fireEvent   :   defaults to false; indicates you want jsPlumb to fire a connection
		                                    detached event. The thinking behind this is that if you made a programmatic
		                                    call to detach an event, you probably don't need the callback.
		                    forceDetach :   defaults to false. allows you to override any beforeDetach listeners that may be registered.

		    Returns: 
		    	true if successful, false if not.
		 */
		this.detach = function() {

            if (arguments.length == 0) return;
            var connType =  _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
                firstArgIsConnection = arguments[0].constructor == connType,
                params = arguments.length == 2 ? firstArgIsConnection ? (arguments[1] || {}) : arguments[0] : arguments[0],
                fireEvent = (params.fireEvent !== false),
                forceDetach = params.forceDetach,
                connection = firstArgIsConnection ? arguments[0] : params.connection;

				if (connection) {
                    if (forceDetach || (connection.isDetachAllowed(connection)
                                        && connection.endpoints[0].isDetachAllowed(connection)
                                        && connection.endpoints[1].isDetachAllowed(connection))) {
                        if (forceDetach || _currentInstance.checkCondition("beforeDetach", connection))
						    connection.endpoints[0].detach(connection, false, true, fireEvent); // TODO check this param iscorrect for endpoint's detach method
                    }
                }
                else {
					var _p = jsPlumb.extend( {}, params); // a backwards compatibility hack: source should be thought of as 'params' in this case.
					// test for endpoint uuids to detach
					if (_p.uuids) {
						_getEndpoint(_p.uuids[0]).detachFrom(_getEndpoint(_p.uuids[1]), fireEvent);
					} else if (_p.sourceEndpoint && _p.targetEndpoint) {
						_p.sourceEndpoint.detachFrom(_p.targetEndpoint);
					} else {
						var sourceId = _getId(_p.source),
						    targetId = _getId(_p.target);
						_operation(sourceId, function(jpc) {
						    if ((jpc.sourceId == sourceId && jpc.targetId == targetId) || (jpc.targetId == sourceId && jpc.sourceId == targetId)) {
							    if (_currentInstance.checkCondition("beforeDetach", jpc)) {
                                    jpc.endpoints[0].detach(jpc, false, true, fireEvent);
								}
							}
						});
					}
				}
		};

		/*
		  Function: detachAllConnections
		  Removes all an element's Connections.
		   
		  Parameters:
		  	el - either the id of the element, or a selector for the element.
		  	params - optional parameters.  alowed values:
		  	        fireEvent : defaults to true, whether or not to fire the detach event.
		  	
		  Returns: 
		  	void
		 */
		this.detachAllConnections = function(el, params) {
            params = params || {};
            el = _getElementObject(el);
			var id = _getAttribute(el, "id"),
                endpoints = endpointsByElement[id];
			if (endpoints && endpoints.length) {
				for ( var i = 0; i < endpoints.length; i++) {
					endpoints[i].detachAll(params.fireEvent);
				}
			}
		};

		/*
		  Function: detachEveryConnection 
		  Remove all Connections from all elements, but leaves Endpoints in place.

		  Parameters:
		    params  - optional params object containing:
		            fireEvent : whether or not to fire detach events. defaults to true.

		   
		  Returns: 
		  	void
		  	 
		  See Also:
		  	<removeEveryEndpoint>
		 */
		this.detachEveryConnection = function(params) {
            params = params || {};
			for ( var id in endpointsByElement) {
				var endpoints = endpointsByElement[id];
				if (endpoints && endpoints.length) {
					for ( var i = 0; i < endpoints.length; i++) {
						endpoints[i].detachAll(params.fireEvent);
					}
				}
			}
			delete connectionsByScope;
			connectionsByScope = {};
		};


		/*
		  Function: draggable 
		  Initialises the draggability of some element or elements.  You should use this instead of y
		  our library's draggable method so that jsPlumb can setup the appropriate callbacks.  Your 
		  underlying library's drag method is always called from this method.
		  
		  Parameters: 
		  	el - either an element id, a list of element ids, or a selector. 
		  	options - options to pass through to the underlying library
		  	 
		  Returns: 
		  	void
		 */
		 // TODO it would be nice if this supported a selector string, instead of an id.
		this.draggable = function(el, options) {
			if (typeof el == 'object' && el.length) {
				for ( var i = 0; i < el.length; i++) {
					var ele = _getElementObject(el[i]);
					if (ele) _initDraggableIfNecessary(ele, true, options);
				}
			} 
			else if (el._nodes) { 	// TODO this is YUI specific; really the logic should be forced
				// into the library adapters (for jquery and mootools aswell)
				for ( var i = 0; i < el._nodes.length; i++) {
					var ele = _getElementObject(el._nodes[i]);
					if (ele) _initDraggableIfNecessary(ele, true, options);
				}
			}
			else {
				var ele = _getElementObject(el);
				if (ele) _initDraggableIfNecessary(ele, true, options);
			}
		};

		/*
		  Function: extend 
		  Wraps the underlying library's extend functionality.
		  
		  Parameters: 
		  	o1 - object to extend 
		  	o2 - object to extend o1 with
		  	
		  Returns: 
		  	o1, extended with all properties from o2.
		 */
		this.extend = function(o1, o2) {
			return jsPlumb.CurrentLibrary.extend(o1, o2);
		};
		
		/*
		 * Function: getDefaultEndpointType
		 * 	Returns the default Endpoint type. Used when someone wants to subclass Endpoint and have jsPlumb return instances of their subclass.
		 *  you would make a call like this in your class's constructor:
		 *    jsPlumb.getDefaultEndpointType().apply(this, arguments);
		 * 
		 * Returns:
		 * 	the default Endpoint function used by jsPlumb.
		 */
		this.getDefaultEndpointType = function() {
			return Endpoint;
		};
		
		/*
		 * Function: getDefaultConnectionType
		 * 	Returns the default Connection type. Used when someone wants to subclass Connection and have jsPlumb return instances of their subclass.
		 *  you would make a call like this in your class's constructor:
		 *    jsPlumb.getDefaultConnectionType().apply(this, arguments);
		 * 
		 * Returns:
		 * 	the default Connection function used by jsPlumb.
		 */
		this.getDefaultConnectionType = function() {
			return Connection;
		};

		/*
		 * Function: getConnections 
		 * Gets all or a subset of connections currently managed by this jsPlumb instance.  If only one scope is passed in to this method,
		 * the result will be a list of connections having that scope (passing in no scope at all will result in jsPlumb assuming you want the
		 * default scope).  If multiple scopes are passed in, the return value will be a map of { scope -> [ connection... ] }.
		 * 
		 *  Parameters
		 *  	scope	-	if the only argument to getConnections is a string, jsPlumb will treat that string as a scope filter, and return a list
		 *                  of connections that are in the given scope.
		 *      options	-	if the argument is a JS object, you can specify a finer-grained filter:
		 *      
		 *      		-	*scope* may be a string specifying a single scope, or an array of strings, specifying multiple scopes.
		 *      		-	*source* either a string representing an element id, or a selector.  constrains the result to connections having this source.
		 *      		-	*target* either a string representing an element id, or a selector.  constrains the result to connections having this target.
		 * 
		 */
		this.getConnections = function(options) {
			if (!options) {
				options = {};
			} else if (options.constructor == String) {
				options = { "scope": options };
			}
			var prepareList = function(input) {
				var r = [];
				if (input) {
					if (typeof input == 'string')
						r.push(input);
					else
						r = input;
				}
				return r;
			},
			scope = options.scope || _currentInstance.getDefaultScope(),
			scopes = prepareList(scope),
			sources = prepareList(options.source),
			targets = prepareList(options.target),
			filter = function(list, value) {
				return list.length > 0 ? _findIndex(list, value) != -1 : true;
			},
			results = scopes.length > 1 ? {} : [],
			_addOne = function(scope, obj) {
				if (scopes.length > 1) {
					var ss = results[scope];
					if (ss == null) {
						ss = []; results[scope] = ss;
					}
					ss.push(obj);
				} else results.push(obj);
			};
			for ( var i in connectionsByScope) {
				if (filter(scopes, i)) {
					for ( var j = 0; j < connectionsByScope[i].length; j++) {
						var c = connectionsByScope[i][j];
						if (filter(sources, c.sourceId) && filter(targets, c.targetId))
							_addOne(i, c);
					}
				}
			}
			return results;
		};

		/*
		 * Function: getAllConnections
		 * Gets all connections, as a map of { scope -> [ connection... ] }. 
		 */
		this.getAllConnections = function() {
			return connectionsByScope;
		};

		/*
		 * Function: getDefaultScope 
		 * Gets the default scope for connections and  endpoints. a scope defines a type of endpoint/connection; supplying a
		 * scope to an endpoint or connection allows you to support different
		 * types of connections in the same UI. but if you're only interested in
		 * one type of connection, you don't need to supply a scope. this method
		 * will probably be used by very few people; it's good for testing
		 * though.
		 */
		this.getDefaultScope = function() {
			return DEFAULT_SCOPE;
		};

		/*
		  Function: getEndpoint 
		  Gets an Endpoint by UUID
		   
		  Parameters: 
		  	uuid - the UUID for the Endpoint
		  	 
		  Returns: 
		  	Endpoint with the given UUID, null if nothing found.
		 */
		this.getEndpoint = _getEndpoint;
		
		/**
		 * Function:getEndpoints
		 * Gets the list of Endpoints for a given selector, or element id.
		 * @param el
		 * @return
		 */
		this.getEndpoints = function(el) {
			return endpointsByElement[_getId(el)];
		};

		/*
		 * Gets an element's id, creating one if necessary. really only exposed
		 * for the lib-specific functionality to access; would be better to pass
		 * the current instance into the lib-specific code (even though this is
		 * a static call. i just don't want to expose it to the public API).
		 */
		this.getId = _getId;
		this.getOffset = function(id) { 
			var o = offsets[id]; 
			return _updateOffset({elId:id});
		};
		
		this.getSelector = function(spec) {
			return jsPlumb.CurrentLibrary.getSelector(spec);
		};
		
		this.getSize = function(id) { 
			var s = sizes[id]; 
			if (!s) _updateOffset({elId:id});
			return sizes[id];
		};		
		
		this.appendElement = _appendElement;
		
		var _hoverSuspended = false;
		this.isHoverSuspended = function() { return _hoverSuspended; };
		this.setHoverSuspended = function(s) { _hoverSuspended = s; };

		/*
		  Function: hide 
		  Sets an element's connections to be hidden.
		  
		  Parameters: 
		  	el - either the id of the element, or a selector for the element.
		  	changeEndpoints - whether not to also hide endpoints on the element. by default this is false.  
		  	 
		  Returns: 
		  	void
		 */
		this.hide = function(el, changeEndpoints) {
			_setVisible(el, "none", changeEndpoints);
		};
		
		// exposed for other objects to use to get a unique id.
		this.idstamp = _idstamp;
		
		/**
		 * callback from the current library to tell us to prepare ourselves (attach
		 * mouse listeners etc; can't do that until the library has provided a bind method)
		 * @return
		 */
		this.init = function() {
			if (!initialized) {
				_currentInstance.setRenderMode(_currentInstance.Defaults.RenderMode);  // calling the method forces the capability logic to be run.
				
				var bindOne = function(event) {
						jsPlumb.CurrentLibrary.bind(document, event, function(e) {
							if (!_currentInstance.currentlyDragging && _mouseEventsEnabled && renderMode == jsPlumb.CANVAS) {
								// try connections first
								for (var scope in connectionsByScope) {
					    			var c = connectionsByScope[scope];
					    			for (var i = 0; i < c.length; i++) {
					    				var t = c[i].connector[event](e);
					    				if (t) return;	
					    			}
					    		}
								for (var el in endpointsByElement) {
									var ee = endpointsByElement[el];
									for (var i = 0; i < ee.length; i++) {
										if (ee[i].endpoint[event](e)) return;
									}
								}
							}
						});					
				};
				bindOne("click");bindOne("dblclick");bindOne("mousemove");bindOne("mousedown");bindOne("mouseup");bindOne("contextmenu");
			
				initialized = true;
				_currentInstance.fire("ready");
			}
		};
		
		this.log = log;
		this.jsPlumbUIComponent = jsPlumbUIComponent;
		this.EventGenerator = EventGenerator;

		/*
		 * Creates an anchor with the given params.
		 * 
		 * 
		 * Returns: The newly created Anchor.
		 */
		this.makeAnchor = function() {
			if (arguments.length == 0) return null;
			var specimen = arguments[0], elementId = arguments[1], jsPlumbInstance = arguments[2], newAnchor = null;
			if (!jsPlumbInstance) 
				throw "NO JSPLUMB SET";
			// if it appears to be an anchor already...
			if (specimen.compute && specimen.getOrientation) return specimen;  //TODO hazy here about whether it should be added or is already added somehow.
			// is it the name of an anchor type?
			else if (typeof specimen == "string") {
				newAnchor = jsPlumb.Anchors[arguments[0]]({elementId:elementId, jsPlumbInstance:_currentInstance});
			}
			// is it an array? it will be one of:
			// 		an array of [name, params] - this defines a single anchor
			//		an array of arrays - this defines some dynamic anchors
			//		an array of numbers - this defines a single anchor.				
			else if (specimen.constructor == Array) {					
				if (specimen[0].constructor == Array || specimen[0].constructor == String) {
					if (specimen.length == 2 && specimen[0].constructor == String && specimen[1].constructor == Object) {
						var pp = jsPlumb.extend({elementId:elementId, jsPlumbInstance:_currentInstance}, specimen[1]);
						newAnchor = jsPlumb.Anchors[specimen[0]](pp);
					}
					else
						newAnchor = new DynamicAnchor(specimen, null, elementId);
				}
				else {
					var anchorParams = {
						x:specimen[0], y:specimen[1],
						orientation : (specimen.length >= 4) ? [ specimen[2], specimen[3] ] : [0,0],
						offsets : (specimen.length == 6) ? [ specimen[4], specimen[5] ] : [ 0, 0 ],
						elementId:elementId
					};						
					newAnchor = new Anchor(anchorParams);
					newAnchor.clone = function() { return new Anchor(anchorParams); };						 					
				}
			}
			
			if (!newAnchor.id) newAnchor.id = "anchor_" + _idstamp();
			return newAnchor;
		};

		/**
		 * makes a list of anchors from the given list of types or coords, eg
		 * ["TopCenter", "RightMiddle", "BottomCenter", [0, 1, -1, -1] ]
		 */
		this.makeAnchors = function(types, elementId, jsPlumbInstance) {
			var r = [];
			for ( var i = 0; i < types.length; i++) {
				if (typeof types[i] == "string")
					r.push(jsPlumb.Anchors[types[i]]({elementId:elementId, jsPlumbInstance:jsPlumbInstance}));
				else if (types[i].constructor == Array)
					r.push(_currentInstance.makeAnchor(types[i], elementId, jsPlumbInstance));
			}
			return r;
		};

		/**
		 * Makes a dynamic anchor from the given list of anchors (which may be in shorthand notation as strings or dimension arrays, or Anchor
		 * objects themselves) and the given, optional, anchorSelector function (jsPlumb uses a default if this is not provided; most people will
		 * not need to provide this - i think). 
		 */
		this.makeDynamicAnchor = function(anchors, anchorSelector) {
			return new DynamicAnchor(anchors, anchorSelector);
		};
		
		/**
		 * Function: makeTarget
		 * Makes some DOM element a Connection target, allowing you to drag connections to it
		 * without having to register any Endpoints on it first.  When a Connection is established,
		 * the endpoint spec that was passed in to this method is used to create a suitable 
		 * Endpoint (the default will be used if you do not provide one).
		 * 
		 * Parameters:
		 *  el		-	string id or element selector for the element to make a target.
		 * 	params	-	JS object containing parameters:
		 * 	  endpoint	optional.	specification of an endpoint to create when a connection is created.
		 * 	  scope		optional.   scope for the drop zone.
		 * 	  dropOptions optional. same stuff as you would pass to dropOptions of an Endpoint definition.
		 * 	  deleteEndpointsOnDetach  optional, defaults to true. whether or not to delete
		 *                             any Endpoints created by a connection to this target if
		 *                             the connection is subsequently detached. this will not 
		 *                             remove Endpoints that have had more Connections attached
		 *                             to them after they were created.
		 *                   	
		 * 
		 */
		var _targetEndpointDefinitions = {};
		var _setEndpointPaintStylesAndAnchor = function(ep, epIndex) {
			ep.paintStyle = ep.paintStyle ||
			 				_currentInstance.Defaults.EndpointStyles[epIndex] ||
                            _currentInstance.Defaults.EndpointStyle ||
                            jsPlumb.Defaults.EndpointStyles[epIndex] ||
                            jsPlumb.Defaults.EndpointStyle;
			ep.hoverPaintStyle = ep.hoverPaintStyle ||
                           _currentInstance.Defaults.EndpointHoverStyles[epIndex] ||
                           _currentInstance.Defaults.EndpointHoverStyle ||
                           jsPlumb.Defaults.EndpointHoverStyles[epIndex] ||
                           jsPlumb.Defaults.EndpointHoverStyle;                            

			ep.anchor = ep.anchor ||
                      	_currentInstance.Defaults.Anchors[epIndex] ||
                      	_currentInstance.Defaults.Anchor ||
                      	jsPlumb.Defaults.Anchors[epIndex] ||
                      	jsPlumb.Defaults.Anchor;                           
				
		};
		this.makeTarget = function(el, params, referenceParams) {						
			
			var p = jsPlumb.extend({}, referenceParams);
			jsPlumb.extend(p, params);
			var jpcl = jsPlumb.CurrentLibrary,
			    targetScope = p.scope || _currentInstance.Defaults.Scope,
			    deleteEndpointsOnDetach = p.deleteEndpointsOnDetach || true,
			_doOne = function(_el) {
				
				// get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
				// and use the endpoint definition if found.
				var elid = _getId(_el);
				_targetEndpointDefinitions[elid] = p.endpoint;
				
				var dropOptions = jsPlumb.extend({}, p.dropOptions || {}),
				_drop = function() {
					_currentInstance.currentlyDragging = false;
					var draggable = _getElementObject(jpcl.getDragObject(arguments)),
						id = _getAttribute(draggable, "dragId"),				
						// restore the original scope if necessary (issue 57)
						scope = _getAttribute(draggable, "originalScope"),
						jpc = floatingConnections[id],
						source = jpc.endpoints[0],
						_endpoint = p.endpoint ? jsPlumb.extend({}, p.endpoint) : {};

                    // use defaults for endpoint style, if not present..this either uses EndpointStyle, or EndpointStyles[1],
                    // if it is present, since this is a target endpoint.
                    // TODO - this should be a helper method.  makeTarget should use it too.  give it an endpoint
                    _setEndpointPaintStylesAndAnchor(_endpoint, 1);                                                    

					// unlock the source anchor to allow it to refresh its position if necessary
					source.anchor.locked = false;					
										
					if (scope) jpcl.setDragScope(draggable, scope);				
					
					// check if drop is allowed here.					
					var _continue = jpc.isDropAllowed(jpc.sourceId, _getId(_el), jpc.scope);		
					
					// regardless of whether the connection is ok, reconfigure the existing connection to 
					// point at the current info. we need this to be correct for the detach event that will follow.
					// clear the source endpoint from the list to detach. we will detach this connection at this
					// point, but we want to keep the source endpoint.  the target is a floating endpoint and should
					// be removed.  TODO need to figure out whether this code can result in endpoints kicking around
					// when they shouldnt be.  like is this a full detach of a connection?  can it be?
					if (jpc.endpointsToDeleteOnDetach) {
						if (source === jpc.endpointsToDeleteOnDetach[0])
							jpc.endpointsToDeleteOnDetach[0] = null;
						else if (source === jpc.endpointsToDeleteOnDetach[1])
							jpc.endpointsToDeleteOnDetach[1] = null;
					}
					// reinstate any suspended endpoint; this just puts the connection back into
					// a state in which it will report sensible values if someone asks it about
					// its target.  we're going to throw this connection away shortly so it doesnt matter
					// if we manipulate it a bit.
					if (jpc.suspendedEndpoint) {
						jpc.targetId = jpc.suspendedEndpoint.elementId;
						jpc.target = jpcl.getElementObject(jpc.suspendedEndpoint.elementId);
						jpc.endpoints[1] = jpc.suspendedEndpoint;
					}																										
					
					if (_continue) {
					
						// detach this connection from the source.
						source.detach(jpc, false, true, true);//source.endpointWillMoveAfterConnection);
				
						// make a new Endpoint for the target
						var newEndpoint = _currentInstance.addEndpoint(_el, _endpoint);
																
						// if the anchor has a 'positionFinder' set, then delegate to that function to find
						// out where to locate the anchor.
						if (newEndpoint.anchor.positionFinder != null) {
							var dropPosition = jpcl.getUIPosition(arguments),
							elPosition = jpcl.getOffset(_el),
							elSize = jpcl.getSize(_el),
							ap = newEndpoint.anchor.positionFinder(dropPosition, elPosition, elSize, newEndpoint.anchor);
							newEndpoint.anchor.x = ap[0];
							newEndpoint.anchor.y = ap[1];
							// now figure an orientation for it..kind of hard to know what to do actually. probably the best thing i can do is to
							// support specifying an orientation in the anchor's spec. if one is not supplied then i will make the orientation 
							// be what will cause the most natural link to the source: it will be pointing at the source, but it needs to be
							// specified in one axis only, and so how to make that choice? i think i will use whichever axis is the one in which
							// the target is furthest away from the source.
						}
						var c = _currentInstance.connect({
							source:source,
							target:newEndpoint,
							scope:scope,
							previousConnection:jpc,
							container:jpc.parent,
							// 'endpointWillMoveAfterConnection' is set by the makeSource function, and it indicates that the
							// given endpoint will actually transfer from the element it is currently attached to to some other
							// element after a connection has been established.  in that case, we do not want to fire the
							// connection event, since it will have the wrong data in it; makeSource will do it for us.
							// this is controlled by the 'parent' parameter on a makeSource call.
							doNotFireConnectionEvent:source.endpointWillMoveAfterConnection
						});
						if (deleteEndpointsOnDetach) 
							c.endpointsToDeleteOnDetach = [ source, newEndpoint ];
					}				
					// if not allowed to drop...
					else {
						// TODO this code is identical (pretty much) to what happens when a connection
						// dragged from a normal endpoint is in this situation. refactor.
						// is this an existing connection, and will we reattach?
						if (jpc.suspendedEndpoint) {
							if (source.isReattach) {
								jpc.setHover(false);
								jpc.floatingAnchorIndex = null;
								jpc.suspendedEndpoint.addConnection(jpc);
								_currentInstance.repaint(source.elementId);
							}
							else
								source.detach(jpc, false, true, true);  // otherwise, detach the connection and tell everyone about it.
						}
						
					}														
				};
				
				var dropEvent = jpcl.dragEvents['drop'];
				dropOptions["scope"] = dropOptions["scope"] || targetScope;
				dropOptions[dropEvent] = _wrap(dropOptions[dropEvent], _drop);
				
				jpcl.initDroppable(_el, dropOptions, true);
			};
			
			el = _convertYUICollection(el);			
			
			var inputs = el.length && el.constructor != String ? el : [ el ];
						
			for (var i = 0; i < inputs.length; i++) {			
				_doOne(_getElementObject(inputs[i]));
			}
		};
		
		/**
		 * helper method to make a list of elements drop targets.
		 * @param els
		 * @param params
		 * @param referenceParams
		 * @return
		 */
		this.makeTargets = function(els, params, referenceParams) {
			for ( var i = 0; i < els.length; i++) {
				_currentInstance.makeTarget(els[i], params, referenceParams);				
			}
		};
		
		/**
		 * Function: makeSource
		 * Makes some DOM element a Connection source, allowing you to drag connections from it
		 * without having to register any Endpoints on it first.  When a Connection is established,
		 * the endpoint spec that was passed in to this method is used to create a suitable 
		 * Endpoint (the default will be used if you do not provide one).
		 * 
		 * Parameters:
		 *  el		-	string id or element selector for the element to make a source.
		 * 	params	-	JS object containing parameters:
		 * 	  endpoint	optional.	specification of an endpoint to create when a connection is created.
		 * 	  parent	optional.   the element to add Endpoints to when a Connection is established.  if you omit this, 
		 *                          Endpoints will be added to 'el'.
		 * 	  scope		optional.   scope for the connections dragged from this element.
		 * 	  dragOptions optional. same stuff as you would pass to dragOptions of an Endpoint definition.
		 * 	  deleteEndpointsOnDetach  optional, defaults to false. whether or not to delete
		 *                             any Endpoints created by a connection from this source if
		 *                             the connection is subsequently detached. this will not 
		 *                             remove Endpoints that have had more Connections attached
		 *                             to them after they were created.
		 *                   	
		 * 
		 */
		var _sourceEndpointDefinitions = {};
		this.makeSource = function(el, params, referenceParams) {
			var p = jsPlumb.extend({}, referenceParams);
			jsPlumb.extend(p, params);
			var jpcl = jsPlumb.CurrentLibrary,						
			_doOne = function(_el) {
				// get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
				// and use the endpoint definition if found.
				var elid = _getId(_el);
				_sourceEndpointDefinitions[elid] = p.endpoint || {};
				var stopEvent = jpcl.dragEvents["stop"],
					dragEvent = jpcl.dragEvents["drag"],
					dragOptions = jsPlumb.extend({ }, p.dragOptions || _sourceEndpointDefinitions[elid].dragOptions || {}),
					existingDrag = dragOptions.drag,
					existingStop = dragOptions.stop,
					ep = null,
					endpointAddedButNoDragYet = false;

				// set scope if its not set in dragOptions but was passed in in params
				dragOptions["scope"] = dragOptions["scope"] || p.scope;

				// make sure this method honours whatever defaults have been set for Endpoint.				
				_sourceEndpointDefinitions[elid].endpoint = _sourceEndpointDefinitions[elid].endpoint || _currentInstance.Defaults.Endpoints[0] || _currentInstance.Defaults.Endpoint;

                // set endpoint paint styles and anchor, using either styles that are set or defaults.
                _setEndpointPaintStylesAndAnchor(_sourceEndpointDefinitions[elid], 0);
                

				dragOptions[dragEvent] = _wrap(dragOptions[dragEvent], function() {
					if (existingDrag) existingDrag.apply(this, arguments);
					endpointAddedButNoDragYet = false;
				});
					
				dragOptions[stopEvent] = function() { 
				
					if (existingStop) existingStop.apply(this, arguments);								

                    //_currentlyDown = false;
					_currentInstance.currentlyDragging = false;
					
					if (ep.connections.length == 0)
						_currentInstance.deleteEndpoint(ep);
					else {
						
						jpcl.unbind(ep.canvas, "mousedown"); 
								
						// reset the anchor to the anchor that was initially provided. the one we were using to drag
						// the connection was just a placeholder that was located at the place the user pressed the
						// mouse button to initiate the drag.
						var anchorDef = _sourceEndpointDefinitions[elid].anchor || _currentInstance.Defaults.Anchor;
						ep.anchor = _currentInstance.makeAnchor(anchorDef, elid, _currentInstance);
						
						if (p.parent) {						
							var parent = jpcl.getElementObject(p.parent);
							if (parent) {	
								var currentId = ep.elementId;
								ep.setElement(parent);
								ep.endpointWillMoveAfterConnection = false;
								_currentInstance.anchorManager.rehomeEndpoint(currentId, parent);
								ep.connections[0].previousConnection = null;
								_finaliseConnection(ep.connections[0]);
							}
						}										
						_currentInstance.repaint(elid);												
					}
				};
				// when the user presses the mouse, add an Endpoint
				var mouseDownListener = function(e) {
					// make sure we have the latest offset for this div 
					var myOffsetInfo = _updateOffset({elId:elid});		

					var x = ((e.pageX || e.page.x) - myOffsetInfo.left) / myOffsetInfo.width, 
					    y = ((e.pageY || e.page.y) - myOffsetInfo.top) / myOffsetInfo.height,
					    parentX = x, 
					    parentY = y;
					
							
					// if there is a parent, the endpoint will actually be added to it now, rather than the div
					// that was the source.  in that case, we have to adjust the anchor position so it refers to
					// the parent.
					if (p.parent) {
						var pEl = jsPlumb.CurrentLibrary.getElementObject(p.parent),
							pId = _getId(pEl);
						myOffsetInfo = _updateOffset({elId:pId});
						parentX = ((e.pageX || e.page.x) - myOffsetInfo.left) / myOffsetInfo.width, 
					    parentY = ((e.pageY || e.page.y) - myOffsetInfo.top) / myOffsetInfo.height;
					}											
					
					// we need to override the anchor in here, and force 'isSource', but we don't want to mess with
					// the params passed in, because after a connection is established we're going to reset the endpoint
					// to have the anchor we were given.
					var tempEndpointParams = {};
					jsPlumb.extend(tempEndpointParams, _sourceEndpointDefinitions[elid]);
					tempEndpointParams.isSource = true;
					tempEndpointParams.anchor = [x,y,0,0];
					tempEndpointParams.parentAnchor = [ parentX, parentY, 0, 0 ];
					tempEndpointParams.dragOptions = dragOptions;
					// if a parent was given we need to turn that into a "container" argument.  this is, by default,
					// the parent of the element we will move to, so parent of p.parent in this case.  however, if
					// the user has specified a 'container' on the endpoint definition or on 
					// the defaults, we should use that.
					if (p.parent) {
						var potentialParent = tempEndpointParams.container || _currentInstance.Defaults.Container;
						if (potentialParent)
							tempEndpointParams.container = potentialParent;
						else
							tempEndpointParams.container = jsPlumb.CurrentLibrary.getParent(p.parent);
					}
					
					ep = _currentInstance.addEndpoint(elid, tempEndpointParams);

					endpointAddedButNoDragYet = true;
					// we set this to prevent connections from firing attach events before this function has had a chance
					// to move the endpoint.
					ep.endpointWillMoveAfterConnection = p.parent != null;
					ep.endpointWillMoveTo = p.parent ? jpcl.getElementObject(p.parent) : null;

                    var _delTempEndpoint = function() {
						// this mouseup event is fired only if no dragging occurred, by jquery and yui, but for mootools
						// it is fired even if dragging has occurred, in which case we would blow away a perfectly
						// legitimate endpoint, were it not for this check.  the flag is set after adding an
						// endpoint and cleared in a drag listener we set in the dragOptions above.
						if(endpointAddedButNoDragYet) {
							_currentInstance.deleteEndpoint(ep);
                        }
					};

					_currentInstance.registerListener(ep.canvas, "mouseup", _delTempEndpoint);
                    _currentInstance.registerListener(_el, "mouseup", _delTempEndpoint);
					
					// and then trigger its mousedown event, which will kick off a drag, which will start dragging
					// a new connection from this endpoint.
					jpcl.trigger(ep.canvas, "mousedown", e);
				};
               
                // register this on jsPlumb so that it can be cleared by a reset.
                _currentInstance.registerListener(_el, "mousedown", mouseDownListener);
			};
			
			el = _convertYUICollection(el);			
			
			var inputs = el.length && el.constructor != String ? el : [ el ];
						
			for (var i = 0; i < inputs.length; i++) {			
				_doOne(_getElementObject(inputs[i]));
			}
		};
		
		/**
		 * helper method to make a list of elements connection sources.
		 * @param els
		 * @param params
		 * @param referenceParams
		 * @return
		 */
		this.makeSources = function(els, params, referenceParams) {
			for ( var i = 0; i < els.length; i++) {
				_currentInstance.makeSource(els[i], params, referenceParams);				
			}
		};
		
		/*
		  Function: ready
		  Helper method to bind a function to jsPlumb's ready event.
		 */
		this.ready = function(fn) {
			_currentInstance.bind("ready", fn);
		},

		/*
		  Function: repaint 
		  Repaints an element and its connections. This method gets new sizes for the elements before painting anything.
		  
		  Parameters: 
		  	el - either the id of the element or a selector representing the element.
		  	 
		  Returns: 
		  	void
		  	 
		  See Also: 
		  	<repaintEverything>
		 */
		this.repaint = function(el) {
			var _processElement = function(el) { _draw(_getElementObject(el)); };
			// support both lists...
			if (typeof el == 'object')
				for ( var i = 0; i < el.length; i++) _processElement(el[i]);			 
			else // ...and single strings.
				_processElement(el);
		};

		/*
		  Function: repaintEverything 
		  Repaints all connections.
		   
		  Returns: 
		  	void
		  	
		  See Also: 
		  	<repaint>
		 */
		this.repaintEverything = function() {
			var timestamp = _timestamp();
			for ( var elId in endpointsByElement) {
				_draw(_getElementObject(elId), null, timestamp);
			}
		};

		/*
		  Function: removeAllEndpoints 
		  Removes all Endpoints associated with a given element. Also removes all Connections associated with each Endpoint it removes.
		  
		  Parameters: 
		  	el - either an element id, or a selector for an element.
		  	 
		  Returns: 
		  	void
		  	 
		  See Also: 
		  	<removeEndpoint>
		 */
		this.removeAllEndpoints = function(el) {
			var elId = _getAttribute(el, "id"),
			    ebe = endpointsByElement[elId];
			if (ebe) {
				for ( var i = 0; i < ebe.length; i++) 
					_currentInstance.deleteEndpoint(ebe[i]);
			}
			endpointsByElement[elId] = [];
		};

		/*
		  Removes every Endpoint in this instance of jsPlumb.		   		  		  		  
		  @deprecated use deleteEveryEndpoint instead
		 */
		this.removeEveryEndpoint = this.deleteEveryEndpoint;
		
		/*
		  Removes the given Endpoint from the given element.		  		  
		  @deprecated Use jsPlumb.deleteEndpoint instead (and note you dont need to supply the element. it's irrelevant).
		 */
		this.removeEndpoint = function(el, endpoint) {
			_currentInstance.deleteEndpoint(endpoint);
		};

        var _registeredListeners = {},
            _unbindRegisteredListeners = function() {
                for (var i in _registeredListeners) {
                    for (var j = 0; j < _registeredListeners[i].length; j++) {
                        var info = _registeredListeners[i][j];
                        jsPlumb.CurrentLibrary.unbind(info.el, info.event, info.listener);
                    }
                }
                _registeredListeners = {};
            };

        // internal register listener method.  gives us a hook to clean things up
        // with if the user calls jsPlumb.reset.
        this.registerListener = function(el, type, listener) {
            jsPlumb.CurrentLibrary.bind(el, type, listener);
            _addToList(_registeredListeners, type, {el:el, event:type, listener:listener});
        };

		/*
		  Function:reset 
		  Removes all endpoints and connections and clears the listener list. To keep listeners call jsPlumb.deleteEveryEndpoint instead of this.
		 */
		this.reset = function() {
			_currentInstance.deleteEveryEndpoint();
			_currentInstance.clearListeners();
            _unbindRegisteredListeners();
            _currentInstance.anchorManager.reset();
		};

		/*
		  Function: setAutomaticRepaint 
		  Sets/unsets automatic repaint on window resize.
		   
		  Parameters: 
		  	value - whether or not to automatically repaint when the window is resized.
		  	 
		  Returns: void
		 */
		this.setAutomaticRepaint = function(value) {
			automaticRepaint = value;
		};

		/*
		 * Function: setDefaultScope 
		 * Sets the default scope for Connections and Endpoints. A scope defines a type of Endpoint/Connection; supplying a
		 * scope to an Endpoint or Connection allows you to support different
		 * types of Connections in the same UI.  If you're only interested in
		 * one type of Connection, you don't need to supply a scope. This method
		 * will probably be used by very few people; it just instructs jsPlumb
		 * to use a different key for the default scope.
		 * 
		 * Parameters:
		 * 	scope - scope to set as default.
		 */
		this.setDefaultScope = function(scope) {
			DEFAULT_SCOPE = scope;
		};

		/*
		 * Function: setDraggable 
		 * Sets whether or not a given element is
		 * draggable, regardless of what any jsPlumb command may request.
		 * 
		 * Parameters: 
		 * 	el - either the id for the element, or a selector representing the element.
		 *  
		 * Returns: 
		 * 	void
		 */
		this.setDraggable = _setDraggable;

		this.setDebugLog = function(debugLog) {
			log = debugLog;
		};

		/*
		 * Function: setRepaintFunction 
		 * 	Sets the function to fire when the window size has changed and a repaint was fired. 
		 * 
		 * Parameters: 
		 * 	f - Function to execute.
		 *  
		 * Returns: void
		 */
		this.setRepaintFunction = function(f) {
			repaintFunction = f;
		};
		
		/*
		 * Function: setMouseEventsEnabled
		 * Sets whether or not mouse events are enabled.  Default is true.
		 *  
		 * Parameters:
		 * 	enabled - whether or not mouse events should be enabled.
		 * 
		 * Returns: 
		 * 	void
		 */
		this.setMouseEventsEnabled = function(enabled) {
			_mouseEventsEnabled = enabled;
		};

        /*
         * Function: setSuspendDrawing
         * Suspends drawing operations.  This can be used when you have a lot of connections to make or endpoints to register;
         * it will save you a lot of time.
         */
        this.setSuspendDrawing = _setSuspendDrawing;
		
		/*
		 * Constant for use with the setRenderMode method
		 */
		this.CANVAS = "canvas";
		
		/*
		 * Constant for use with the setRenderMode method
		 */
		this.SVG = "svg";
		
		this.VML = "vml";
		
		/*
		 * Function: setRenderMode
		 * Sets render mode: jsPlumb.CANVAS, jsPlumb.SVG or jsPlumb.VML.  jsPlumb will fall back to VML if it determines that
		 * what you asked for is not supported (and that VML is).  If you asked for VML but the browser does
		 * not support it, jsPlumb uses SVG.  
		 * 
		 * Returns:
		 * the render mode that jsPlumb set, which of course may be different from that requested.
		 */
		this.setRenderMode = function(mode) {
			if (mode) 
				mode = mode.toLowerCase();
			else 
				return;
			if (mode !== jsPlumb.CANVAS && mode !== jsPlumb.SVG && mode !== jsPlumb.VML) throw new Error("render mode must be one of jsPlumb.CANVAS, jsPlumb.SVG or jsPlumb.VML");
			// now test we actually have the capability to do this.
			if (mode === jsPlumb.CANVAS && canvasAvailable) 
				renderMode = jsPlumb.CANVAS;
			else if (mode === jsPlumb.SVG && svgAvailable)
				renderMode = jsPlumb.SVG;
			else if (vmlAvailable)
				renderMode = jsPlumb.VML;		
			
			return renderMode;
		};
		
		this.getRenderMode = function() { return renderMode; };

		/*
		 * Function: show 
		 * Sets an element's connections to be visible.
		 * 
		 * Parameters: 
		 * 	el - either the id of the element, or a selector for the element.
		 *  changeEndpoints - whether or not to also change the visible state of the endpoints on the element.  this also has a bearing on
		 *  other connections on those endpoints: if their other endpoint is also visible, the connections are made visible.  
		 *  
		 * Returns: 
		 * 	void
		 */
		this.show = function(el, changeEndpoints) {
			_setVisible(el, "block", changeEndpoints);
		};

		/*
		 * Function: sizeCanvas 
		 * Helper to size a canvas. You would typically use
		 * this when writing your own Connector or Endpoint implementation.
		 * 
		 * Parameters: 
		 * 	x - [int] x position for the Canvas origin 
		 * 	y - [int] y position for the Canvas origin 
		 * 	w - [int] width of the canvas 
		 * 	h - [int] height of the canvas
		 *  
		 * Returns: 
		 * 	void
		 */
		this.sizeCanvas = function(canvas, x, y, w, h) {
			if (canvas) {
				canvas.style.height = h + "px";
				canvas.height = h;
				canvas.style.width = w + "px";
				canvas.width = w;
				canvas.style.left = x + "px";
				canvas.style.top = y + "px";
			}
		};

		/**
		 * gets some test hooks. nothing writable.
		 */
		this.getTestHarness = function() {
			return {
				endpointsByElement : endpointsByElement,  
				endpointCount : function(elId) {
					var e = endpointsByElement[elId];
					return e ? e.length : 0;
				},
				connectionCount : function(scope) {
					scope = scope || DEFAULT_SCOPE;
					var c = connectionsByScope[scope];
					return c ? c.length : 0;
				},
				findIndex : _findIndex,
				getId : _getId,
				makeAnchor:self.makeAnchor,
				makeDynamicAnchor:self.makeDynamicAnchor
			};
		};

		/**
		 * Toggles visibility of an element's connections. kept for backwards
		 * compatibility
		 */
		this.toggle = _toggleVisible;

		/*
		 * Function: toggleVisible 
		 * Toggles visibility of an element's Connections.
		 *  
		 * Parameters: 
		 * 	el - either the element's id, or a selector representing the element.
		 *  changeEndpoints - whether or not to also toggle the endpoints on the element.
		 *  
		 * Returns: 
		 * 	void, but should be updated to return the current state
		 */
		// TODO: update this method to return the current state.
		this.toggleVisible = _toggleVisible;

		/*
		 * Function: toggleDraggable 
		 * Toggles draggability (sic?) of an element's Connections.
		 *  
		 * Parameters: 
		 * 	el - either the element's id, or a selector representing the element.
		 *  
		 * Returns: 
		 * 	The current draggable state.
		 */
		this.toggleDraggable = _toggleDraggable;

		/*
		 * Function: unload 
		 * Unloads jsPlumb, deleting all storage. You should call this from an onunload attribute on the <body> element. 
		 * 
		 * Returns:
		 * 	void
		 */
		this.unload = function() {
			// this used to do something, but it turns out that what it did was nothing.
			// now it exists only for backwards compatibility.
		};

		/*
		 * Helper method to wrap an existing function with one of
		 * your own. This is used by the various implementations to wrap event
		 * callbacks for drag/drop etc; it allows jsPlumb to be transparent in
		 * its handling of these things. If a user supplies their own event
		 * callback, for anything, it will always be called. 
		 */
		this.wrap = _wrap;			
		this.addListener = this.bind;
		
		var adjustForParentOffsetAndScroll = function(xy, el) {

			var offsetParent = null, result = xy;
			if (el.tagName.toLowerCase() === "svg" && el.parentNode) {
				offsetParent = el.parentNode;
			}
			else if (el.offsetParent) {
				offsetParent = el.offsetParent;					
			}
			if (offsetParent != null) {
				var po = offsetParent.tagName.toLowerCase() === "body" ? {left:0,top:0} : _getOffset(offsetParent),
					so = offsetParent.tagName.toLowerCase() === "body" ? {left:0,top:0} : {left:offsetParent.scrollLeft, top:offsetParent.scrollTop};					


				// i thought it might be cool to do this:
				//	lastReturnValue[0] = lastReturnValue[0] - offsetParent.offsetLeft + offsetParent.scrollLeft;
				//	lastReturnValue[1] = lastReturnValue[1] - offsetParent.offsetTop + offsetParent.scrollTop;					
				// but i think it ignores margins.  my reasoning was that it's quicker to not hand off to some underlying					
				// library.
				
				result[0] = xy[0] - po.left + so.left;
				result[1] = xy[1] - po.top + so.top;
			}
		
			return result;
			
		};

		/**
		 * Anchors model a position on some element at which an Endpoint may be located.  They began as a first class citizen of jsPlumb, ie. a user
		 * was required to create these themselves, but over time this has been replaced by the concept of referring to them either by name (eg. "TopMiddle"),
		 * or by an array describing their coordinates (eg. [ 0, 0.5, 0, -1 ], which is the same as "TopMiddle").  jsPlumb now handles all of the
		 * creation of Anchors without user intervention.
		 */
		var Anchor = function(params) {
			var self = this;
			this.x = params.x || 0;
			this.y = params.y || 0;
			this.elementId = params.elementId;
			var orientation = params.orientation || [ 0, 0 ];
			var lastTimestamp = null, lastReturnValue = null;
			this.offsets = params.offsets || [ 0, 0 ];
			self.timestamp = null;
			this.compute = function(params) {
				var xy = params.xy, wh = params.wh, element = params.element, timestamp = params.timestamp;
				
				if (timestamp && timestamp === self.timestamp)
					return lastReturnValue;
	
				lastReturnValue = [ xy[0] + (self.x * wh[0]) + self.offsets[0], xy[1] + (self.y * wh[1]) + self.offsets[1] ];
				
				// adjust loc if there is an offsetParent
				lastReturnValue = adjustForParentOffsetAndScroll(lastReturnValue, element.canvas);
				
				self.timestamp = timestamp;
				return lastReturnValue;
			};

			this.getOrientation = function(_endpoint) { return orientation; };

			this.equals = function(anchor) {
				if (!anchor) return false;
				var ao = anchor.getOrientation();
				var o = this.getOrientation();
				return this.x == anchor.x && this.y == anchor.y
						&& this.offsets[0] == anchor.offsets[0]
						&& this.offsets[1] == anchor.offsets[1]
						&& o[0] == ao[0] && o[1] == ao[1];
			};

			this.getCurrentLocation = function() { return lastReturnValue; };
		};

		/**
		 * An Anchor that floats. its orientation is computed dynamically from
		 * its position relative to the anchor it is floating relative to.  It is used when creating 
		 * a connection through drag and drop.
		 * 
		 * TODO FloatingAnchor could totally be refactored to extend Anchor just slightly.
		 */
		var FloatingAnchor = function(params) {

			// this is the anchor that this floating anchor is referenced to for
			// purposes of calculating the orientation.
			var ref = params.reference,
			// the canvas this refers to.
			refCanvas = params.referenceCanvas,
			size = _getSize(_getElementObject(refCanvas)),

			// these are used to store the current relative position of our
			// anchor wrt the reference anchor. they only indicate
			// direction, so have a value of 1 or -1 (or, very rarely, 0). these
			// values are written by the compute method, and read
			// by the getOrientation method.
			xDir = 0, yDir = 0,
			// temporary member used to store an orientation when the floating
			// anchor is hovering over another anchor.
			orientation = null,
			_lastResult = null;

			// set these to 0 each; they are used by certain types of connectors in the loopback case,
			// when the connector is trying to clear the element it is on. but for floating anchor it's not
			// very important.
			this.x = 0; this.y = 0;

			this.isFloating = true;

			this.compute = function(params) {
				var xy = params.xy, element = params.element,
				result = [ xy[0] + (size[0] / 2), xy[1] + (size[1] / 2) ]; // return origin of the element. we may wish to improve this so that any object can be the drag proxy.
							
				// adjust loc if there is an offsetParent
				result = adjustForParentOffsetAndScroll(result, element.canvas);
				
				_lastResult = result;
				return result;
			};

			this.getOrientation = function(_endpoint) {
				if (orientation) return orientation;
				else {
					var o = ref.getOrientation(_endpoint);
					// here we take into account the orientation of the other
					// anchor: if it declares zero for some direction, we declare zero too. this might not be the most awesome. perhaps we can come
					// up with a better way. it's just so that the line we draw looks like it makes sense. maybe this wont make sense.
					return [ Math.abs(o[0]) * xDir * -1,
							Math.abs(o[1]) * yDir * -1 ];
				}
			};

			/**
			 * notification the endpoint associated with this anchor is hovering
			 * over another anchor; we want to assume that anchor's orientation
			 * for the duration of the hover.
			 */
			this.over = function(anchor) { 
				orientation = anchor.getOrientation(); 
			};

			/**
			 * notification the endpoint associated with this anchor is no
			 * longer hovering over another anchor; we should resume calculating
			 * orientation as we normally do.
			 */
			this.out = function() { orientation = null; };

			this.getCurrentLocation = function() { return _lastResult; };
		};

		/* 
		 * A DynamicAnchor is an Anchor that contains a list of other Anchors, which it cycles
		 * through at compute time to find the one that is located closest to
		 * the center of the target element, and returns that Anchor's compute
		 * method result. this causes endpoints to follow each other with
		 * respect to the orientation of their target elements, which is a useful
		 * feature for some applications.
		 * 
		 */
		var DynamicAnchor = function(anchors, anchorSelector, elementId) {
			this.isSelective = true;
			this.isDynamic = true;			
			var _anchors = [], self = this,
			_convert = function(anchor) { 
				return anchor.constructor == Anchor ? anchor: _currentInstance.makeAnchor(anchor, elementId, _currentInstance); 
			};
			for (var i = 0; i < anchors.length; i++) 
				_anchors[i] = _convert(anchors[i]);			
			this.addAnchor = function(anchor) { _anchors.push(_convert(anchor)); };
			this.getAnchors = function() { return _anchors; };
			this.locked = false;
			var _curAnchor = _anchors.length > 0 ? _anchors[0] : null,
				_curIndex = _anchors.length > 0 ? 0 : -1,
				self = this,
			
				// helper method to calculate the distance between the centers of the two elements.
				_distance = function(anchor, cx, cy, xy, wh) {
					var ax = xy[0] + (anchor.x * wh[0]), ay = xy[1] + (anchor.y * wh[1]);
					return Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2));
				},
			
			// default method uses distance between element centers.  you can provide your own method in the dynamic anchor
			// constructor (and also to jsPlumb.makeDynamicAnchor). the arguments to it are four arrays: 
			// xy - xy loc of the anchor's element
			// wh - anchor's element's dimensions
			// txy - xy loc of the element of the other anchor in the connection
			// twh - dimensions of the element of the other anchor in the connection.
			// anchors - the list of selectable anchors
			_anchorSelector = anchorSelector || function(xy, wh, txy, twh, anchors) {
				var cx = txy[0] + (twh[0] / 2), cy = txy[1] + (twh[1] / 2);
				var minIdx = -1, minDist = Infinity;
				for ( var i = 0; i < anchors.length; i++) {
					var d = _distance(anchors[i], cx, cy, xy, wh);
					if (d < minDist) {
						minIdx = i + 0;
						minDist = d;
					}
				}
				return anchors[minIdx];
			};
			
			this.compute = function(params) {				
				var xy = params.xy, wh = params.wh, timestamp = params.timestamp, txy = params.txy, twh = params.twh;				
				// if anchor is locked or an opposite element was not given, we
				// maintain our state. anchor will be locked
				// if it is the source of a drag and drop.
				if (self.locked || txy == null || twh == null)
					return _curAnchor.compute(params);				
				else
					params.timestamp = null; // otherwise clear this, i think. we want the anchor to compute.
				
				_curAnchor = _anchorSelector(xy, wh, txy, twh, _anchors);
				self.x = _curAnchor.x;
				self.y = _curAnchor.y;
				
				return _curAnchor.compute(params);
			};

			this.getCurrentLocation = function() {
				return _curAnchor != null ? _curAnchor.getCurrentLocation() : null;
			};

			this.getOrientation = function(_endpoint) { return _curAnchor != null ? _curAnchor.getOrientation(_endpoint) : [ 0, 0 ]; };
			this.over = function(anchor) { if (_curAnchor != null) _curAnchor.over(anchor); };
			this.out = function() { if (_curAnchor != null) _curAnchor.out(); };
		};
		
	/*
	manages anchors for all elements.
	*/
	// "continuous" anchors: anchors that pick their location based on how many connections the given element has.
	// this requires looking at a lot more elements than normal - anything that has had a Continuous anchor applied has
	// to be recalculated.  so this manager is used as a reference point.  the first time, with a new timestamp, that
	// a continuous anchor is asked to compute, it calls this guy.  or maybe, even, this guy gets called somewhere else
	// and compute only ever returns pre-computed values.  either way, this is the central point, and we want it to
	// be called as few times as possible.
	var continuousAnchors = {},
        continuousAnchorLocations = {},
	    continuousAnchorOrientations = {},
	    Orientation = { HORIZONTAL : "horizontal", VERTICAL : "vertical", DIAGONAL : "diagonal", IDENTITY:"identity" },
    
	// TODO this functions uses a crude method of determining orientation between two elements.
	// 'diagonal' should be chosen when the angle of the line between the two centers is around
	// one of 45, 135, 225 and 315 degrees. maybe +- 15 degrees.
	calculateOrientation = function(sourceId, targetId, sd, td) {

		if (sourceId === targetId) return {
			orientation:Orientation.IDENTITY,
			a:["top", "top"]
		};

		var theta = Math.atan2((td.centery - sd.centery) , (td.centerx - sd.centerx)),
		    theta2 = Math.atan2((sd.centery - td.centery) , (sd.centerx - td.centerx)),
		    h = ((sd.left <= td.left && sd.right >= td.left) || (sd.left <= td.right && sd.right >= td.right) ||
			    (sd.left <= td.left && sd.right >= td.right) || (td.left <= sd.left && td.right >= sd.right)),
		    v = ((sd.top <= td.top && sd.bottom >= td.top) || (sd.top <= td.bottom && sd.bottom >= td.bottom) ||
			    (sd.top <= td.top && sd.bottom >= td.bottom) || (td.top <= sd.top && td.bottom >= sd.bottom));

		if (! (h || v)) {
			var a = null, rls = false, rrs = false, sortValue = null;
			if (td.left > sd.left && td.top > sd.top)
				a = ["right", "top"];
			else if (td.left > sd.left && sd.top > td.top)
				a = [ "top", "left"];
			else if (td.left < sd.left && td.top < sd.top)
				a = [ "top", "right"];
			else if (td.left < sd.left && td.top > sd.top)
				a = ["left", "top" ];

			return { orientation:Orientation.DIAGONAL, a:a, theta:theta, theta2:theta2 };
		}
		else if (h) return {
			orientation:Orientation.HORIZONTAL,
			a:sd.top < td.top ? ["bottom", "top"] : ["top", "bottom"],
			theta:theta, theta2:theta2
		}
		else return {
			orientation:Orientation.VERTICAL,
			a:sd.left < td.left ? ["right", "left"] : ["left", "right"],
			theta:theta, theta2:theta2
		}
	},
	placeAnchorsOnLine = function(desc, elementDimensions, elementPosition,
					connections, horizontal, otherMultiplier, reverse) {
		var a = [], step = elementDimensions[horizontal ? 0 : 1] / (connections.length + 1);

		for (var i = 0; i < connections.length; i++) {
			var val = (i + 1) * step, other = otherMultiplier * elementDimensions[horizontal ? 1 : 0];
			if (reverse)
			  val = elementDimensions[horizontal ? 0 : 1] - val;

			var dx = (horizontal ? val : other), x = elementPosition[0] + dx,  xp = dx / elementDimensions[0],
			 	dy = (horizontal ? other : val), y = elementPosition[1] + dy, yp = dy / elementDimensions[1];

			a.push([ x, y, xp, yp, connections[i][1], connections[i][2] ]);
		}

		return a;
	},
	standardEdgeSort = function(a, b) { return a[0] > b[0] ? 1 : -1 },
	currySort = function(reverseAngles) {
		return function(a,b) {
            var r = true;
			if (reverseAngles) {
				if (a[0][0] < b[0][0])
					r = true;
				else
					r = a[0][1] > b[0][1];
			}
			else {
				if (a[0][0] > b[0][0])
					r= true;
				else
					r =a[0][1] > b[0][1];
			}
            return r === false ? -1 : 1;
		};
	},
	leftSort = function(a,b) {
		// first get adjusted values
		var p1 = a[0][0] < 0 ? -Math.PI - a[0][0] : Math.PI - a[0][0],
		p2 = b[0][0] < 0 ? -Math.PI - b[0][0] : Math.PI - b[0][0];
		if (p1 > p2) return 1;
		else return a[0][1] > b[0][1] ? 1 : -1;
	},
	edgeSortFunctions = {
		"top":standardEdgeSort,
		"right":currySort(true),
		"bottom":currySort(true),
		"left":leftSort
	},
    _sortHelper = function(_array, _fn) {
      return _array.sort(_fn);
    },
	placeAnchors = function(elementId, _anchorLists) {
		var sS = sizes[elementId], sO = offsets[elementId],
		placeSomeAnchors = function(desc, elementDimensions, elementPosition, unsortedConnections, isHorizontal, otherMultiplier) {
            if (unsortedConnections.length > 0) {
			    var sc = _sortHelper(unsortedConnections, edgeSortFunctions[desc]), // puts them in order based on the target element's pos on screen
			    //sc = unsortedConnections.sort(edgeSortFunctions[desc]), // puts them in order based on the target element's pos on screen
				    reverse = desc === "right" || desc === "top",
				    anchors = placeAnchorsOnLine(desc, elementDimensions,
											 elementPosition, sc,
											 isHorizontal, otherMultiplier, reverse );

			    // takes a computed anchor position and adjusts it for parent offset and scroll, then stores it.
			    var _setAnchorLocation = function(endpoint, anchorPos) {
				    var a = adjustForParentOffsetAndScroll([anchorPos[0], anchorPos[1]], endpoint.canvas);
				    continuousAnchorLocations[endpoint.id] = [ a[0], a[1], anchorPos[2], anchorPos[3] ];
			    };

			    for (var i = 0; i < anchors.length; i++) {
				    var c = anchors[i][4], weAreSource = c.endpoints[0].elementId === elementId, weAreTarget = c.endpoints[1].elementId === elementId;
				    if (weAreSource)
					    _setAnchorLocation(c.endpoints[0], anchors[i]);
				    else if (weAreTarget)
					    _setAnchorLocation(c.endpoints[1], anchors[i]);
			    }
            }
		};

		placeSomeAnchors("bottom", sS, [sO.left,sO.top], _anchorLists.bottom, true, 1);
		placeSomeAnchors("top", sS, [sO.left,sO.top], _anchorLists.top, true, 0);
		placeSomeAnchors("left", sS, [sO.left,sO.top], _anchorLists.left, false, 0);
		placeSomeAnchors("right", sS, [sO.left,sO.top], _anchorLists.right, false, 1);
	},
    AnchorManager = function() {
		var _amEndpoints = {},
			endpointConnectionsByElementId = {}, 
			continuousAnchorConnectionsByElementId = {},
			continuousAnchorEndpoints = [],
			self = this,
            anchorLists = {};

        this.reset = function() {
            endpointConnectionsByElementId = {};
			continuousAnchorConnectionsByElementId = {};
			continuousAnchorEndpoints = [];
            anchorLists = {};
        };
			
 		this.newConnection = function(conn) {
			var sourceId = conn.sourceId, targetId = conn.targetId,
				ep = conn.endpoints,
                doRegisterTarget = true,
			    registerConnection = function(otherIndex, otherEndpoint, otherAnchor, elId, c) {
					if (otherAnchor.constructor == DynamicAnchor || otherAnchor.constructor == Anchor) {
						_addToList(endpointConnectionsByElementId, elId, [c, otherEndpoint, otherAnchor.constructor == DynamicAnchor]);
					}
					else {
						// continuous.  if they are the same element, just assign the same anchor
                        // to both.
                        if (sourceId == targetId) {
                           // remove the target endpoint's canvas.  we dont need it.
                            jsPlumb.CurrentLibrary.removeElement(ep[1].canvas);
                            doRegisterTarget = false;
                        }
						_addToList(continuousAnchorConnectionsByElementId, elId, c);
					}
			    };
			registerConnection(0, ep[0], ep[0].anchor, targetId, conn);
             if (doRegisterTarget)
                registerConnection(1, ep[1], ep[1].anchor, sourceId, conn);
		};
		this.connectionDetached = function(connInfo) {
			var sourceId = connInfo.sourceId,
                targetId = connInfo.targetId,
				ep = connInfo.connection.endpoints,
				removeConnection = function(otherIndex, otherEndpoint, otherAnchor, elId, c) {
					if (otherAnchor.constructor == FloatingAnchor) {
						// no-op
					}
					else if (otherAnchor.constructor == DynamicAnchor || otherAnchor.constructor == Anchor) {
                        var _conns = endpointConnectionsByElementId[elId];
                        if (_conns) {
                            _removeWithFunction(_conns, function(e) { return e[0].id == c.id; });
                        }
                    }
					else // continuous.
						_removeWithFunction(continuousAnchorConnectionsByElementId[elId], function(_c) {
							return _c.id == c.id;
						});
				};
				
			removeConnection(1, ep[1], ep[1].anchor, sourceId, connInfo.connection);
			removeConnection(0, ep[0], ep[0].anchor, targetId, connInfo.connection);

            // remove from anchorLists
            var sEl = connInfo.connection.sourceId,
                tEl = connInfo.connection.targetId,
                sE =  connInfo.connection.endpoints[0].id,
                tE = connInfo.connection.endpoints[1].id,
                _remove = function(list, eId) {
                    if (list) {  // transient anchors dont get entries in this list.
                        var f = function(e) { return e[4] == eId; };
                        _removeWithFunction(list["top"], f);
                        _removeWithFunction(list["left"], f);
                        _removeWithFunction(list["bottom"], f);
                        _removeWithFunction(list["right"], f);
                    }
                };
            
            _remove(anchorLists[sEl], sE);
            _remove(anchorLists[tEl], tE);
            self.redraw(sEl);
            self.redraw(tEl);
		};
		this.add = function(endpoint, elementId) {
			_addToList(_amEndpoints, elementId, endpoint);
		};
		this.get = function(elementId) {
			return {
				"standard":endpointConnectionsByElementId[elementId] || [],
				"continuous":continuousAnchorConnectionsByElementId[elementId] || [],
				"endpoints":_amEndpoints[elementId],
				"continuousAnchorEndpoints":continuousAnchorEndpoints
			};
		};
		this.deleteEndpoint = function(endpoint) {
			var cIdx = _findIndex(continuousAnchorEndpoints, endpoint);
			if (cIdx > -1)
				continuousAnchorEndpoints.splice(cIdx, 1);
			else
				_removeWithFunction(_amEndpoints[endpoint.elementId], function(e) {
					return e.id == endpoint.id;
				});
		};
		this.clearFor = function(elementId) {
			delete _amEndpoints[elementId];
			_amEndpoints[elementId] = [];
		};
        // updates the given anchor list by either updating an existing anchor's info, or adding it. this function
        // also removes the anchor from its previous list, if the edge it is on has changed.
        // all connections found along the way (those that are connected to one of the faces this function
        // operates on) are added to the connsToPaint list, as are their endpoints. in this way we know to repaint
        // them wthout having to calculate anything else about them.
        var _updateAnchorList = function(lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, elId, connsToPaint, endpointsToPaint) {
            // first try to find the exact match, but keep track of the first index of a matching element id along the way.s
            var exactIdx = -1,
                firstMatchingElIdx = -1,
                endpoint = conn.endpoints[idx],
                endpointId = endpoint.id,
                oIdx = [1,0][idx],
                values = [ [ theta, order ], conn, aBoolean, otherElId, endpointId ],
                listToAddTo = lists[edgeId],
                listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null;

            if (listToRemoveFrom) {
                var rIdx = _findWithFunction(listToRemoveFrom, function(e) { return e[4] == endpointId });
                if (rIdx != -1) {
                    listToRemoveFrom.splice(rIdx, 1);
                    // get all connections from this list
                    for (var i = 0; i < listToRemoveFrom.length; i++) {
                        _addWithFunction(connsToPaint, listToRemoveFrom[i][1], function(c) { return c.id == listToRemoveFrom[i][1].id });
                        _addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[idx], function(e) { return e.id == listToRemoveFrom[i][1].endpoints[idx].id });
                    }
                }
            }

            for (var i = 0; i < listToAddTo.length; i++) {
                if (idx == 1 && listToAddTo[i][3] === otherElId && firstMatchingElIdx == -1)
                    firstMatchingElIdx = i;
                _addWithFunction(connsToPaint, listToAddTo[i][1], function(c) { return c.id == listToAddTo[i][1].id });                
                _addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[idx], function(e) { return e.id == listToAddTo[i][1].endpoints[idx].id });
            }
            if (exactIdx != -1) {
                listToAddTo[exactIdx] = values;
            }
            else {
                var insertIdx = reverse ? firstMatchingElIdx != -1 ? firstMatchingElIdx : 0 : listToAddTo.length; // of course we will get this from having looked through the array shortly.
                listToAddTo.splice(insertIdx, 0, values);
            }

            // store this for next time.
            endpoint._continuousAnchorEdge = edgeId;
        };
		this.redraw = function(elementId, ui, timestamp) {
			// get all the endpoints for this element
			var ep = _amEndpoints[elementId] || [],
				endpointConnections = endpointConnectionsByElementId[elementId] || [],
				continuousAnchorConnections = continuousAnchorConnectionsByElementId[elementId] || [],
				connectionsToPaint = [],
				endpointsToPaint = [],
                anchorsToUpdate = [];
            
			timestamp = timestamp || _timestamp();
				
			_updateOffset( { elId : elementId, offset : ui, recalc : false, timestamp : timestamp }); 
			// valid for one paint cycle.
			var myOffset = offsets[elementId],
                myWH = sizes[elementId],
                orientationCache = {};
			
			// actually, first we should compute the orientation of this element to all other elements to which
			// this element is connected with a continuous anchor (whether both ends of the connection have
			// a continuous anchor or just one)
            for (var i = 0; i < continuousAnchorConnections.length; i++) {
                var conn = continuousAnchorConnections[i],
                    sourceId = conn.sourceId,
                    targetId = conn.targetId,
                    oKey = sourceId + "_" + targetId,
                    oKey2 = targetId + "_" + sourceId,
                    o = orientationCache[oKey],
					td = _getCachedData(targetId),
					sd = _getCachedData(sourceId),
                    oIdx = conn.sourceId == elementId ? 1 : 0;

                if (!anchorLists[sourceId]) anchorLists[sourceId] = { top:[], right:[], bottom:[], left:[] };
                if (!anchorLists[targetId]) anchorLists[targetId] = { top:[], right:[], bottom:[], left:[] };

                if (targetId == sourceId) {
                    // here we may want to improve this by somehow determining the face we'd like
				    // to put the connector on.  ideally, when drawing, the face should be calculated
				    // by determining which face is closest to the point at which the mouse button
					// was released.  for now, we're putting it on the top face.
                    _updateAnchorList(anchorLists[sourceId], -Math.PI / 2, 0, conn, false, targetId, 0, false, "top", sourceId, connectionsToPaint, endpointsToPaint)
				}
                else {
                    if (!o) {
                        o = calculateOrientation(sourceId, targetId, sd.o, td.o);
                        orientationCache[oKey] = o;
                        // this would be a performance enhancement, but the computed angles need to be clamped to
                        //the (-PI/2 -> PI/2) range in order for the sorting to work properly.
                    /*  orientationCache[oKey2] = {
                            orientation:o.orientation,
                            a:[o.a[1], o.a[0]],
                            theta:o.theta + Math.PI,
                            theta2:o.theta2 + Math.PI
                        };*/
                    }
                    _updateAnchorList(anchorLists[sourceId], o.theta, 0, conn, false, targetId, 0, false, o.a[0], sourceId, connectionsToPaint, endpointsToPaint);
                    _updateAnchorList(anchorLists[targetId], o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], targetId, connectionsToPaint, endpointsToPaint);
                }

                _addWithFunction(anchorsToUpdate, sourceId, function(a) { return a === sourceId; });
                _addWithFunction(anchorsToUpdate, targetId, function(a) { return a === targetId; });
                _addWithFunction(connectionsToPaint, conn, function(c) { return c.id == conn.id; });
                _addWithFunction(endpointsToPaint, conn.endpoints[oIdx], function(e) { return e.id == conn.endpoints[oIdx].id; });
            }

            // now place all the continuous anchors we need to;
            for (var i = 0; i < anchorsToUpdate.length; i++) {
				placeAnchors(anchorsToUpdate[i], anchorLists[anchorsToUpdate[i]]);
			}
			
			// now that continuous anchors have been placed, paint all the endpoints for this element
            // TODO performance: add the endpoint ids to a temp array, and then when iterating in the next
            // loop, check that we didn't just paint that endpoint. we can probably shave off a few more milliseconds this way.
			for (var i = 0; i < ep.length; i++) {				
				ep[i].paint( { timestamp : timestamp, offset : myOffset, dimensions : myWH });
			}
            // ... and any other endpoints we came across as a result of the continuous anchors.
            for (var i = 0; i < endpointsToPaint.length; i++) {
				endpointsToPaint[i].paint( { timestamp : timestamp, offset : myOffset, dimensions : myWH });
			}


			// paint all the standard and "dynamic connections", which are connections whose other anchor is
			// static and therefore does need to be recomputed; we make sure that happens only one time.
			for (var i = 0; i < endpointConnections.length; i++) {
				var otherEndpoint = endpointConnections[i][1];
				if (otherEndpoint.anchor.constructor == DynamicAnchor) {			 							
					otherEndpoint.paint({ elementWithPrecedence:elementId });								
                    _addWithFunction(connectionsToPaint, endpointConnections[i][0], function(c) { return c.id == endpointConnections[i][0].id; });
					// all the connections for the other endpoint now need to be repainted
					for (var k = 0; k < otherEndpoint.connections.length; k++) {
						if (otherEndpoint.connections[k] !== endpointConnections[i][0])							
                            _addWithFunction(connectionsToPaint, otherEndpoint.connections[k], function(c) { return c.id == otherEndpoint.connections[k].id; });
					}
				} else if (otherEndpoint.anchor.constructor == Anchor) {					
                    _addWithFunction(connectionsToPaint, endpointConnections[i][0], function(c) { return c.id == endpointConnections[i][0].id; });
				}
			}
			// paint current floating connection for this element, if there is one.
			var fc = floatingConnections[elementId];
			if (fc) 
				fc.paint({timestamp:timestamp, recalc:false, elId:elementId});
				
			// paint all the connections
			for (var i = 0; i < connectionsToPaint.length; i++) {
				connectionsToPaint[i].paint({elId:elementId, timestamp:timestamp, recalc:false});
			}
		};
		this.rehomeEndpoint = function(currentId, element) {
			var eps = _amEndpoints[currentId] || [], //, 
				elementId = _currentInstance.getId(element);
			for (var i = 0; i < eps.length; i++) {
				self.add(eps[i], elementId);
			}
			eps.splice(0, eps.length);
		};
	};
	_currentInstance.anchorManager = new AnchorManager();				
	_currentInstance.continuousAnchorFactory = {
		get:function(params) {
			var existing = continuousAnchors[params.elementId];
			if (!existing) {
				existing = {
					type:"Continuous",
					compute : function(params) {
						return continuousAnchorLocations[params.element.id] || [0,0];
					},
					getCurrentLocation : function(endpoint) {
						return continuousAnchorLocations[endpoint.id] || [0,0];
					},
					getOrientation : function(endpoint) {
						return continuousAnchorOrientations[endpoint.id] || [0,0];
					},
					isDynamic : true,
					isContinuous : true
				};
				continuousAnchors[params.elementId] = existing;
			}
			return existing;
		}
	};


		/*
		 * Class: Connection
		 * The connecting line between two Endpoints.
		 */
		/*
		 * Function: Connection
		 * Connection constructor.
		 * 
		 * Parameters:
		 * 	source 	- either an element id, a selector for an element, or an Endpoint.
		 * 	target	- either an element id, a selector for an element, or an Endpoint
		 * 	scope	- scope descriptor for this connection. optional.
		 *  container - optional id or selector instructing jsPlumb where to attach all the elements it creates for this connection.  you should read the documentation for a full discussion of this.
		 *  endpoint - Optional. Endpoint definition to use for both ends of the connection.
		 *  endpoints - Optional. Array of two Endpoint definitions, one for each end of the Connection. This and 'endpoint' are mutually exclusive parameters.
		 *  endpointStyle - Optional. Endpoint style definition to use for both ends of the Connection.
		 *  endpointStyles - Optional. Array of two Endpoint style definitions, one for each end of the Connection. This and 'endpoint' are mutually exclusive parameters.
		 *  paintStyle - Parameters defining the appearance of the Connection. Optional; jsPlumb will use the defaults if you supply nothing here.
		 *  hoverPaintStyle - Parameters defining the appearance of the Connection when the mouse is hovering over it. Optional; jsPlumb will use the defaults if you supply nothing here (note that the default hoverPaintStyle is null).
		 *  overlays - Optional array of Overlay definitions to appear on this Connection.
		 *  drawEndpoints - if false, instructs jsPlumb to not draw the endpoints for this Connection.  Be careful with this: it only really works when you tell jsPlumb to attach elements to the document body. Read the documentation for a full discussion of this. 
		 */
		var Connection = function(params) {
			var self = this, visible = true;
			self.idPrefix = "_jsplumb_c_";
			self.defaultLabelLocation = 0.5;
			self.defaultOverlayKeys = ["Overlays", "ConnectionOverlays"];
			this.parent = params.parent;
			overlayCapableJsPlumbUIComponent.apply(this, arguments);
			// ************** get the source and target and register the connection. *******************
			
			/**
				Function:isVisible
				Returns whether or not the Connection is currently visible.
			*/
			this.isVisible = function() { return visible; };
			/**
				Function: setVisible
				Sets whether or not the Connection should be visible.

				Parameters:
					visible - boolean indicating desired visible state.
			*/
			this.setVisible = function(v) {
				visible = v;
				if (self.connector && self.connector.canvas) self.connector.canvas.style.display = v ? "block" : "none";
			};
			
			/**
				Property: source
				The source element for this Connection.
			*/
			this.source = _getElementObject(params.source);
			/**
				Property:target
				The target element for this Connection.
			*/
			this.target = _getElementObject(params.target);
			// sourceEndpoint and targetEndpoint override source/target, if they are present. but 
			// source is not overridden if the Endpoint has declared it is not the final target of a connection;
			// instead we use the source that the Endpoint declares will be the final source element.
			if (params.sourceEndpoint) {
				this.source = params.sourceEndpoint.endpointWillMoveTo || params.sourceEndpoint.getElement();
			}
			if (params.targetEndpoint) this.target = params.targetEndpoint.getElement();
			
			// if a new connection is the result of moving some existing connection, params.previousConnection
			// will have that Connection in it. listeners for the jsPlumbConnection event can look for that
			// member and take action if they need to.
			self.previousConnection = params.previousConnection;
			
			var _cost = params.cost;
			self.getCost = function() { return _cost; };
			self.setCost = function(c) { _cost = c; };
			
			var _bidirectional = params.bidirectional === true;
			self.isBidirectional = function() { return _bidirectional; };
			
			/*
			 * Property: sourceId
			 * Id of the source element in the connection.
			 */
			this.sourceId = _getAttribute(this.source, "id");
			/*
			 * Property: targetId
			 * Id of the target element in the connection.
			 */
			this.targetId = _getAttribute(this.target, "id");
			
			/**
			 * implementation of abstract method in EventGenerator
			 * @return list of attached elements. in our case, a list of Endpoints.
			 */
			this.getAttachedElements = function() {
				return self.endpoints;
			};
			
			/*
			 * Property: scope
			 * Optional scope descriptor for the connection.
			 */
			this.scope = params.scope; // scope may have been passed in to the connect call. if it wasn't, we will pull it from the source endpoint, after having initialised the endpoints. 
			/*
			 * Property: endpoints
			 * Array of [source, target] Endpoint objects.
			 */
			this.endpoints = [];
			this.endpointStyles = [];
			// wrapped the main function to return null if no input given. this lets us cascade defaults properly.
			var _makeAnchor = function(anchorParams, elementId) {
				if (anchorParams)
					return _currentInstance.makeAnchor(anchorParams, elementId, _currentInstance);
			},
			prepareEndpoint = function(existing, index, params, element, elementId, connectorPaintStyle, connectorHoverPaintStyle) {
				if (existing) {
					self.endpoints[index] = existing;
					existing.addConnection(self);
				} else {
					if (!params.endpoints) params.endpoints = [ null, null ];
					var ep = params.endpoints[index] 
					        || params.endpoint
							|| _currentInstance.Defaults.Endpoints[index]
							|| jsPlumb.Defaults.Endpoints[index]
							|| _currentInstance.Defaults.Endpoint
							|| jsPlumb.Defaults.Endpoint;

					if (!params.endpointStyles) params.endpointStyles = [ null, null ];
					if (!params.endpointHoverStyles) params.endpointHoverStyles = [ null, null ];
					var es = params.endpointStyles[index] || params.endpointStyle || _currentInstance.Defaults.EndpointStyles[index] || jsPlumb.Defaults.EndpointStyles[index] || _currentInstance.Defaults.EndpointStyle || jsPlumb.Defaults.EndpointStyle;
					// Endpoints derive their fillStyle from the connector's strokeStyle, if no fillStyle was specified.
					if (es.fillStyle == null && connectorPaintStyle != null)
						es.fillStyle = connectorPaintStyle.strokeStyle;
					
					// TODO: decide if the endpoint should derive the connection's outline width and color.  currently it does:
					//*
					if (es.outlineColor == null && connectorPaintStyle != null) 
						es.outlineColor = connectorPaintStyle.outlineColor;
					if (es.outlineWidth == null && connectorPaintStyle != null) 
						es.outlineWidth = connectorPaintStyle.outlineWidth;
					//*/
					
					var ehs = params.endpointHoverStyles[index] || params.endpointHoverStyle || _currentInstance.Defaults.EndpointHoverStyles[index] || jsPlumb.Defaults.EndpointHoverStyles[index] || _currentInstance.Defaults.EndpointHoverStyle || jsPlumb.Defaults.EndpointHoverStyle;
					// endpoint hover fill style is derived from connector's hover stroke style.  TODO: do we want to do this by default? for sure?
					if (connectorHoverPaintStyle != null) {
						if (ehs == null) ehs = {};
						if (ehs.fillStyle == null) {
							ehs.fillStyle = connectorHoverPaintStyle.strokeStyle;
						}
					}
					var a = params.anchors ? params.anchors[index] : 
						params.anchor ? params.anchor :
						_makeAnchor(_currentInstance.Defaults.Anchors[index], elementId) || 
						_makeAnchor(jsPlumb.Defaults.Anchors[index], elementId) || 
						_makeAnchor(_currentInstance.Defaults.Anchor, elementId) || 
						_makeAnchor(jsPlumb.Defaults.Anchor, elementId),					
					u = params.uuids ? params.uuids[index] : null,
					e = _newEndpoint({ 
						paintStyle : es, 
						hoverPaintStyle:ehs, 
						endpoint : ep, 
						connections : [ self ], 
						uuid : u, 
						anchor : a, 
						source : element,
						container:params.container,
						reattach:params.reattach,
                        detachable:params.detachable
					});
					self.endpoints[index] = e;
					
					
					if (params.drawEndpoints === false) e.setVisible(false, true, true);
					
					return e;
				}
			};					

			var eS = prepareEndpoint(params.sourceEndpoint, 
									 0, 
									 params, 
									 self.source, 
									 self.sourceId, 
									 params.paintStyle, 
									 params.hoverPaintStyle);
			if (eS) _addToList(endpointsByElement, this.sourceId, eS);
			
			// if there were no endpoints supplied and the source element is the target element, we will reuse the source
			// endpoint that was just created.
			var existingTargetEndpoint = ((self.sourceId == self.targetId) && params.targetEndpoint == null) ? eS : params.targetEndpoint,
				eT = prepareEndpoint(existingTargetEndpoint, 
									 1, 
									 params, 
									 self.target, 
									 self.targetId, 
									 params.paintStyle, 
									 params.hoverPaintStyle);
			if (eT) _addToList(endpointsByElement, this.targetId, eT);
			// if scope not set, set it to be the scope for the source endpoint.
			if (!this.scope) this.scope = this.endpoints[0].scope;		
			
			// if delete endpoints on detach, keep a record of just exactly which endpoints they are.
			if (params.deleteEndpointsOnDetach)
				self.endpointsToDeleteOnDetach = [eS, eT];

            var _detachable = _currentInstance.Defaults.ConnectionsDetachable;
            if (params.detachable === false) _detachable = false;
            if(self.endpoints[0].connectionsDetachable === false) _detachable = false;
            if(self.endpoints[1].connectionsDetachable === false) _detachable = false;
            
            // inherit connectin cost if it was set on source endpoint
            if (_cost == null) _cost = self.endpoints[0].getConnectionCost();
            // inherit bidirectional flag if set no source endpoint
            if (params.bidirectional == null) _bidirectional = self.endpoints[0].areConnectionsBidirectional();
            
            /*
                Function: isDetachable
                Returns whether or not this connection can be detached from its target/source endpoint.  by default this
                is false; use it in conjunction with the 'reattach' parameter.
             */
            this.isDetachable = function() {
                return _detachable === true;
            };

            /*
                Function: setDetachable
                Sets whether or not this connection is detachable.
             */
            this.setDetachable = function(detachable) {
              _detachable = detachable === true;
            };
			
			// merge all the parameters objects into the connection.  parameters set
			// on the connection take precedence; then target endpoint params, then
			// finally source endpoint params.
			// TODO jsPlumb.extend could be made to take more than two args, and it would
			// apply the second through nth args in order.
			var _p = jsPlumb.extend({}, this.endpoints[0].getParameters());
			jsPlumb.extend(_p, this.endpoints[1].getParameters());
			jsPlumb.extend(_p, self.getParameters());
			self.setParameters(_p);
			
			// override setHover to pass it down to the underlying connector
			var _sh = self.setHover;

			self.setHover = function() {
				self.connector.setHover.apply(self.connector, arguments);
				_sh.apply(self, arguments);
			};
			
			var _internalHover = function(state) {
				if (_connectionBeingDragged == null) {
					self.setHover(state, false);
				}
			};						

			/*
			 * Function: setConnector
			 * Sets the Connection's connector (eg "Bezier", "Flowchart", etc).  You pass a Connector definition into this method - the same
			 * thing that you would set as the 'connector' property on a jsPlumb.connect call.
			 * 
			 * Parameters:
			 * 	connector		-	Connector definition
			 */
			this.setConnector = function(connector, doNotRepaint) {
				if (self.connector != null) _removeElements(self.connector.getDisplayElements(), self.parent);
				var connectorArgs = { 
					_jsPlumb:self._jsPlumb, 
					parent:params.parent, 
					cssClass:params.cssClass, 
					container:params.container,
					tooltip:self.tooltip
				};
				if (connector.constructor == String) 
					this.connector = new jsPlumb.Connectors[renderMode][connector](connectorArgs); // lets you use a string as shorthand.
				else if (connector.constructor == Array)
					this.connector = new jsPlumb.Connectors[renderMode][connector[0]](jsPlumb.extend(connector[1], connectorArgs));
				self.canvas = self.connector.canvas;
				// binds mouse listeners to the current connector.
				_bindListeners(self.connector, self, _internalHover);				
				if (!doNotRepaint) self.repaint();
			};
			/*
			 * Property: connector
			 * The underlying Connector for this Connection (eg. a Bezier connector, straight line connector, flowchart connector etc)
			 */			
						
			self.setConnector(this.endpoints[0].connector || 
							  this.endpoints[1].connector || 
							  params.connector || 
							  _currentInstance.Defaults.Connector || 
							  jsPlumb.Defaults.Connector, true);
							  							  			
			
			this.setPaintStyle(this.endpoints[0].connectorStyle || 
							   this.endpoints[1].connectorStyle || 
							   params.paintStyle || 
							   _currentInstance.Defaults.PaintStyle || 
							   jsPlumb.Defaults.PaintStyle, true);
						
			this.setHoverPaintStyle(this.endpoints[0].connectorHoverStyle || 
									this.endpoints[1].connectorHoverStyle || 
									params.hoverPaintStyle || 
									_currentInstance.Defaults.HoverPaintStyle || 
									jsPlumb.Defaults.HoverPaintStyle, true);
			
			this.paintStyleInUse = this.paintStyle;
								
			
			this.moveParent = function(newParent) {
				var jpcl = jsPlumb.CurrentLibrary, curParent = jpcl.getParent(self.connector.canvas);				
				jpcl.removeElement(self.connector.canvas, curParent);
				jpcl.appendElement(self.connector.canvas, newParent);
                if (self.connector.bgCanvas) {
				    jpcl.removeElement(self.connector.bgCanvas, curParent);
				    jpcl.appendElement(self.connector.bgCanvas, newParent);
                }
                // this only applies for DOMOverlays
				for (var i = 0; i < self.overlays.length; i++) {
                    if (self.overlays[i].isAppendedAtTopLevel) {
					    jpcl.removeElement(self.overlays[i].canvas, curParent);
					    jpcl.appendElement(self.overlays[i].canvas, newParent);
					    if (self.overlays[i].reattachListeners) 
					    	self.overlays[i].reattachListeners(self.connector);
                    }
				}
				if (self.connector.reattachListeners)		// this is for SVG/VML; change an element's parent and you have to reinit its listeners.
					self.connector.reattachListeners();     // the Canvas implementation doesn't have to care about this
			};
			
// ***************************** PLACEHOLDERS FOR NATURAL DOCS *************************************************
			/*
			 * Function: bind
			 * Bind to an event on the Connection.  
			 * 
			 * Parameters:
			 * 	event - the event to bind.  Available events on a Connection are:
			 *         - *click*						:	notification that a Connection was clicked.  
			 *         - *dblclick*						:	notification that a Connection was double clicked.
			 *         - *mouseenter*					:	notification that the mouse is over a Connection. 
			 *         - *mouseexit*					:	notification that the mouse exited a Connection.
			 *         
			 *  callback - function to callback. This function will be passed the Connection that caused the event, and also the original event.    
			 */
			
			/*
		     * Function: setPaintStyle
		     * Sets the Connection's paint style and then repaints the Connection.
		     * 
		     * Parameters:
		     * 	style - Style to use.
		     */
			
			/*
		     * Function: setHoverPaintStyle
		     * Sets the paint style to use when the mouse is hovering over the Connection. This is null by default.
		     * The hover paint style is applied as extensions to the paintStyle; it does not entirely replace
		     * it.  This is because people will most likely want to change just one thing when hovering, say the
		     * color for example, but leave the rest of the appearance the same.
		     * 
		     * Parameters:
		     * 	style - Style to use when the mouse is hovering.
		     *  doNotRepaint - if true, the Connection will not be repainted.  useful when setting things up initially.
		     */
			
			/*
		     * Function: setHover
		     * Sets/unsets the hover state of this Connection.
		     * 
		     * Parameters:
		     * 	hover - hover state boolean
		     * 	ignoreAttachedElements - if true, does not notify any attached elements of the change in hover state.  used mostly to avoid infinite loops.
		     */
			
// ***************************** END OF PLACEHOLDERS FOR NATURAL DOCS *************************************************												

			_updateOffset( { elId : this.sourceId });
			_updateOffset( { elId : this.targetId });
			
			// paint the endpoints
			var myOffset = offsets[this.sourceId], myWH = sizes[this.sourceId],
			otherOffset = offsets[this.targetId],
			otherWH = sizes[this.targetId],
			initialTimestamp = _timestamp(),
			anchorLoc = this.endpoints[0].anchor.compute( {
				xy : [ myOffset.left, myOffset.top ], wh : myWH, element : this.endpoints[0],
				elementId:this.endpoints[0].elementId,
				txy : [ otherOffset.left, otherOffset.top ], twh : otherWH, tElement : this.endpoints[1],
				timestamp:initialTimestamp
			});
			this.endpoints[0].paint( { anchorLoc : anchorLoc, timestamp:initialTimestamp });

			anchorLoc = this.endpoints[1].anchor.compute( {
				xy : [ otherOffset.left, otherOffset.top ], wh : otherWH, element : this.endpoints[1],
				elementId:this.endpoints[1].elementId,				
				txy : [ myOffset.left, myOffset.top ], twh : myWH, tElement : this.endpoints[0],
				timestamp:initialTimestamp				
			});
			this.endpoints[1].paint({ anchorLoc : anchorLoc, timestamp:initialTimestamp });										    		  		    	    		  
		    
			/*
			 * Paints the Connection.  Not exposed for public usage. 
			 * 
			 * Parameters:
			 * 	elId - Id of the element that is in motion.
			 * 	ui - current library's event system ui object (present if we came from a drag to get here).
			 *  recalc - whether or not to recalculate all anchors etc before painting. 
			 *  timestamp - timestamp of this paint.  If the Connection was last painted with the same timestamp, it does not paint again.
			 */
			this.paint = function(params) {
				params = params || {};
				var elId = params.elId, ui = params.ui, recalc = params.recalc, timestamp = params.timestamp,
				// if the moving object is not the source we must transpose the two references.
				swap = false,
				tId = swap ? this.sourceId : this.targetId, sId = swap ? this.targetId : this.sourceId,
				tIdx = swap ? 0 : 1, sIdx = swap ? 1 : 0;

				var sourceInfo = _updateOffset( { elId : elId, offset : ui, recalc : recalc, timestamp : timestamp }),
					targetInfo = _updateOffset( { elId : tId, timestamp : timestamp }); // update the target if this is a forced repaint. otherwise, only the source has been moved.
				
				var sE = this.endpoints[sIdx], tE = this.endpoints[tIdx],
					sAnchorP = sE.anchor.getCurrentLocation(sE),				
					tAnchorP = tE.anchor.getCurrentLocation(tE);

				/* paint overlays*/
				var maxSize = 0;
				for ( var i = 0; i < self.overlays.length; i++) {
					var o = self.overlays[i];
					if (o.isVisible()) maxSize = Math.max(maxSize, o.computeMaxSize(self.connector));
				}

				var dim = this.connector.compute(sAnchorP, tAnchorP, 
				this.endpoints[sIdx], this.endpoints[tIdx],
				this.endpoints[sIdx].anchor, this.endpoints[tIdx].anchor, 
				self.paintStyleInUse.lineWidth, maxSize,
				sourceInfo,
				targetInfo);
				
				self.connector.paint(dim, self.paintStyleInUse);

				/* paint overlays*/
				for ( var i = 0; i < self.overlays.length; i++) {
					var o = self.overlays[i];
					if (o.isVisible) self.overlayPlacements[i] = o.draw(self.connector, self.paintStyleInUse, dim);
				}
			};			

			/*
			 * Function: repaint
			 * Repaints the Connection.
			 */
			this.repaint = function(params) {
				params = params || {};
                var recalc = !(params.recalc === false);
				this.paint({ elId : this.sourceId, recalc : recalc, timestamp:params.timestamp });
			};			
			
			// just to make sure the UI gets initialised fully on all browsers.
			self.repaint();
		};
		
// ENDPOINT HELPER FUNCTIONS
		var _makeConnectionDragHandler = function(placeholder) {
            var stopped = false;
			return {
				drag : function() {
                	if (stopped) return true;
					var _ui = jsPlumb.CurrentLibrary.getUIPosition(arguments),
					el = placeholder.element;
                	if (el) {
				    	jsPlumb.CurrentLibrary.setOffset(el, _ui);
				    	_draw(_getElementObject(el), _ui);
                	}
                },
                stopDrag : function() {
                    stopped = true;
                }
			};
		};		
		
		var _makeFloatingEndpoint = function(paintStyle, referenceAnchor, endpoint, referenceCanvas, sourceElement) {			
			var floatingAnchor = new FloatingAnchor( { reference : referenceAnchor, referenceCanvas : referenceCanvas });

            //setting the scope here should not be the way to fix that mootools issue.  it should be fixed by not
            // adding the floating endpoint as a droppable.  that makes more sense anyway!
            
			return _newEndpoint({ paintStyle : paintStyle, endpoint : endpoint, anchor : floatingAnchor, source : sourceElement, scope:"__floating" });
		};
		
		/**
		 * creates a placeholder div for dragging purposes, adds it to the DOM, and pre-computes its offset. then returns
		 * both the element id and a selector for the element.
		 */
		var _makeDraggablePlaceholder = function(placeholder, parent) {
			var n = document.createElement("div");
			n.style.position = "absolute";
			var placeholderDragElement = _getElementObject(n);
			_appendElement(n, parent);
			var id = _getId(placeholderDragElement);
			_updateOffset( { elId : id });
			// create and assign an id, and initialize the offset.
			placeholder.id = id;
			placeholder.element = placeholderDragElement;
		};

		/*
		 * Class: Endpoint 
		 * 
		 * Models an endpoint. Can have 1 to 'maxConnections' Connections emanating from it (set maxConnections to -1 
		 * to allow unlimited).  Typically, if you use 'jsPlumb.connect' to programmatically connect two elements, you won't
		 * actually deal with the underlying Endpoint objects.  But if you wish to support drag and drop Connections, one of the ways you
		 * do so is by creating and registering Endpoints using 'jsPlumb.addEndpoint', and marking these Endpoints as 'source' and/or
		 * 'target' Endpoints for Connections.  
		 * 
		 * 
		 */

		/*
		 * Function: Endpoint 
		 * 
		 * Endpoint constructor.
		 * 
		 * Parameters: 
		 * anchor - definition of the Anchor for the endpoint.  You can include one or more Anchor definitions here; if you include more than one, jsPlumb creates a 'dynamic' Anchor, ie. an Anchor which changes position relative to the other elements in a Connection.  Each Anchor definition can be either a string nominating one of the basic Anchors provided by jsPlumb (eg. "TopCenter"), or a four element array that designates the Anchor's location and orientation (eg, and this is equivalent to TopCenter, [ 0.5, 0, 0, -1 ]).  To provide more than one Anchor definition just put them all in an array. You can mix string definitions with array definitions.
		 * endpoint - optional Endpoint definition. This takes the form of either a string nominating one of the basic Endpoints provided by jsPlumb (eg. "Rectangle"), or an array containing [name,params] for those cases where you don't wish to use the default values, eg. [ "Rectangle", { width:5, height:10 } ].
		 * paintStyle - endpoint style, a js object. may be null. 
		 * hoverPaintStyle - style to use when the mouse is hovering over the Endpoint. A js object. may be null; defaults to null. 
		 * source - element the Endpoint is attached to, of type String (an element id) or element selector. Required.
		 * canvas - canvas element to use. may be, and most often is, null.
		 * container - optional id or selector instructing jsPlumb where to attach the element it creates for this endpoint.  you should read the documentation for a full discussion of this.
		 * connections - optional list of Connections to configure the Endpoint with. 
		 * isSource - boolean. indicates the endpoint can act as a source of new connections. Optional; defaults to false.
		 * maxConnections - integer; defaults to 1.  a value of -1 means no upper limit. 
		 * dragOptions - if isSource is set to true, you can supply arguments for the underlying library's drag method. Optional; defaults to null. 
		 * connectorStyle - if isSource is set to true, this is the paint style for Connections from this Endpoint. Optional; defaults to null.
		 * connectorHoverStyle - if isSource is set to true, this is the hover paint style for Connections from this Endpoint. Optional; defaults to null.
		 * connector - optional Connector type to use.  Like 'endpoint', this may be either a single string nominating a known Connector type (eg. "Bezier", "Straight"), or an array containing [name, params], eg. [ "Bezier", { curviness:160 } ].
		 * connectorOverlays - optional array of Overlay definitions that will be applied to any Connection from this Endpoint. 
		 * isTarget - boolean. indicates the endpoint can act as a target of new connections. Optional; defaults to false.
		 * dropOptions - if isTarget is set to true, you can supply arguments for the underlying library's drop method with this parameter. Optional; defaults to null. 
		 * reattach - optional boolean that determines whether or not the Connections reattach after they have been dragged off an Endpoint and left floating. defaults to false: Connections dropped in this way will just be deleted.
		 */
		var Endpoint = function(params) {
			var self = this;
			self.idPrefix = "_jsplumb_e_";			
			self.defaultLabelLocation = [ 0.5, 0.5 ];
			self.defaultOverlayKeys = ["Overlays", "EndpointOverlays"];
			this.parent = params.parent;
			overlayCapableJsPlumbUIComponent.apply(this, arguments);
			params = params || {};

// ***************************** PLACEHOLDERS FOR NATURAL DOCS *************************************************
			/*
			 * Function: bind
			 * Bind to an event on the Endpoint.  
			 * 
			 * Parameters:
			 * 	event - the event to bind.  Available events on an Endpoint are:
			 *         - *click*						:	notification that a Endpoint was clicked.  
			 *         - *dblclick*						:	notification that a Endpoint was double clicked.
			 *         - *mouseenter*					:	notification that the mouse is over a Endpoint. 
			 *         - *mouseexit*					:	notification that the mouse exited a Endpoint.
			 *         
			 *  callback - function to callback. This function will be passed the Endpoint that caused the event, and also the original event.    
			 */
			
			/*
		     * Function: setPaintStyle
		     * Sets the Endpoint's paint style and then repaints the Endpoint.
		     * 
		     * Parameters:
		     * 	style - Style to use.
		     */
			
			/*
		     * Function: setHoverPaintStyle
		     * Sets the paint style to use when the mouse is hovering over the Endpoint. This is null by default.
		     * The hover paint style is applied as extensions to the paintStyle; it does not entirely replace
		     * it.  This is because people will most likely want to change just one thing when hovering, say the
		     * color for example, but leave the rest of the appearance the same.
		     * 
		     * Parameters:
		     * 	style - Style to use when the mouse is hovering.
		     *  doNotRepaint - if true, the Endpoint will not be repainted.  useful when setting things up initially.
		     */
			
			/*
		     * Function: setHover
		     * Sets/unsets the hover state of this Endpoint.
		     * 
		     * Parameters:
		     * 	hover - hover state boolean
		     * 	ignoreAttachedElements - if true, does not notify any attached elements of the change in hover state.  used mostly to avoid infinite loops.
		     */
			
// ***************************** END OF PLACEHOLDERS FOR NATURAL DOCS *************************************************
			
			var visible = true;
			/*
				Function: isVisible
				Returns whether or not the Endpoint is currently visible.
			*/
			this.isVisible = function() { return visible; };
			/*
				Function: setVisible
				Sets whether or not the Endpoint is currently visible.

				Parameters:
					visible - whether or not the Endpoint should be visible.
					doNotChangeConnections - Instructs jsPlumb to not pass the visible state on to any attached Connections. defaults to false.
					doNotNotifyOtherEndpoint - Instructs jsPlumb to not pass the visible state on to Endpoints at the other end of any attached Connections. defaults to false. 
			*/
			this.setVisible = function(v, doNotChangeConnections, doNotNotifyOtherEndpoint) {
				visible = v;
				if (self.canvas) self.canvas.style.display = v ? "block" : "none";
				if (!doNotChangeConnections) {
					for (var i = 0; i < self.connections.length; i++) {
						self.connections[i].setVisible(v);
						if (!doNotNotifyOtherEndpoint) {
							var oIdx = self === self.connections[i].endpoints[0] ? 1 : 0;
							// only change the other endpoint if this is its only connection.
							if (self.connections[i].endpoints[oIdx].connections.length == 1) self.connections[i].endpoints[oIdx].setVisible(v, true, true);
						}
					}
				}
			};			
			var _element = params.source,  _uuid = params.uuid, floatingEndpoint = null,  inPlaceCopy = null;
			if (_uuid) endpointsByUUID[_uuid] = self;
			var _elementId = _getAttribute(_element, "id");
			this.elementId = _elementId;
			this.element = _element;
			
			var _connectionCost = params.connectionCost;
			this.getConnectionCost = function() { return _connectionCost; };
			this.setConnectionCost = function(c) {
				_connectionCost = c; 
			};
			
			var _connectionsBidirectional = params.connectionsBidirectional === true;
			this.areConnectionsBidirectional = function() { return _connectionsBidirectional; };
			this.setConnectionsBidirectional = function(b) { _connectionsBidirectional = b; };
			
			self.anchor = params.anchor ? _currentInstance.makeAnchor(params.anchor, _elementId, _currentInstance) : params.anchors ? _currentInstance.makeAnchor(params.anchors, _elementId, _currentInstance) : _currentInstance.makeAnchor("TopCenter", _elementId, _currentInstance);
				
			// ANCHOR MANAGER
			if (!params._transient) // in place copies, for example, are transient.  they will never need to be retrieved during a paint cycle, because they dont move, and then they are deleted.
				_currentInstance.anchorManager.add(self, _elementId);
			 
			var _endpoint = params.endpoint || _currentInstance.Defaults.Endpoint || jsPlumb.Defaults.Endpoint || "Dot",
			endpointArgs = {
                _jsPlumb:self._jsPlumb,
                parent:params.parent,
                container:params.container,
                tooltip:params.tooltip,
                connectorTooltip:params.connectorTooltip,
                endpoint:self
            };
			if (_endpoint.constructor == String) 
				_endpoint = new jsPlumb.Endpoints[renderMode][_endpoint](endpointArgs);
			else if (_endpoint.constructor == Array) {
				endpointArgs = jsPlumb.extend(_endpoint[1], endpointArgs);
				_endpoint = new jsPlumb.Endpoints[renderMode][_endpoint[0]](endpointArgs);
			}
			else {
				_endpoint = _endpoint.clone();
			}

			// assign a clone function using a copy of endpointArgs. this is used when a drag starts: the endpoint that was dragged is cloned,
			// and the clone is left in its place while the original one goes off on a magical journey. 
			// the copy is to get around a closure problem, in which endpointArgs ends up getting shared by
			// the whole world.
			var argsForClone = jsPlumb.extend({}, endpointArgs);						
			_endpoint.clone = function() {
				var o = new Object();
				_endpoint.constructor.apply(o, [argsForClone]);
				return o;
			};
			
			self.endpoint = _endpoint;
			self.type = self.endpoint.type;
			// override setHover to pass it down to the underlying endpoint
			var _sh = self.setHover;
			self.setHover = function() {
				self.endpoint.setHover.apply(self.endpoint, arguments);
				_sh.apply(self, arguments);
			};
            // endpoint delegates to first connection for hover, if there is one.
            var internalHover = function(state) {
              if (self.connections.length > 0)
                self.connections[0].setHover(state, false);
              else
                self.setHover(state);
            };
			
			// bind listeners from endpoint to self, with the internal hover function defined above.
            _bindListeners(self.endpoint, self, internalHover);
			
			this.setPaintStyle(params.paintStyle || 
							   params.style || 
							   _currentInstance.Defaults.EndpointStyle || 
							   jsPlumb.Defaults.EndpointStyle, true);
			this.setHoverPaintStyle(params.hoverPaintStyle || 
									_currentInstance.Defaults.EndpointHoverStyle || 
									jsPlumb.Defaults.EndpointHoverStyle, true);
			this.paintStyleInUse = this.paintStyle;
			this.connectorStyle = params.connectorStyle;
			this.connectorHoverStyle = params.connectorHoverStyle;
			this.connectorOverlays = params.connectorOverlays;
			this.connector = params.connector;
			this.connectorTooltip = params.connectorTooltip;			
			this.isSource = params.isSource || false;
			this.isTarget = params.isTarget || false;
			
			var _maxConnections = params.maxConnections || _currentInstance.Defaults.MaxConnections; // maximum number of connections this endpoint can be the source of.
						
			this.getAttachedElements = function() {
				return self.connections;
			};
			
			/*
			 * Property: canvas
			 * The Endpoint's Canvas.
			 */
			this.canvas = this.endpoint.canvas;
			/*
			 * Property: connections
			 * List of Connections this Endpoint is attached to.
			 */
			this.connections = params.connections || [];
			/*
			 * Property: scope
			 * Scope descriptor for this Endpoint.
			 */
			this.scope = params.scope || DEFAULT_SCOPE;
			this.timestamp = null;
			self.isReattach = params.reattach || false;
            self.connectionsDetachable = _currentInstance.Defaults.ConnectionsDetachable;
            if (params.connectionsDetachable === false || params.detachable === false)
                self.connectionsDetachable = false;
			var dragAllowedWhenFull = params.dragAllowedWhenFull || true;

			this.computeAnchor = function(params) {
				return self.anchor.compute(params);
			};
			/*
			 * Function: addConnection
			 *   Adds a Connection to this Endpoint.
			 *   
			 * Parameters:
			 *   connection - the Connection to add.
			 */
			this.addConnection = function(connection) {
				self.connections.push(connection);
			};			
			/*
			 * Function: detach
			 *   Detaches the given Connection from this Endpoint.
			 *   
			 * Parameters:
			 *   connection - the Connection to detach.
			 *   ignoreTarget - optional; tells the Endpoint to not notify the Connection target that the Connection was detached.  The default behaviour is to notify the target.
			 */
			this.detach = function(connection, ignoreTarget, forceDetach, fireEvent) {
				//var idx = _findIndex(self.connections, connection), actuallyDetached = false;
				var idx = _findWithFunction(self.connections, function(c) { return c.id == connection.id}), 
					actuallyDetached = false;
                fireEvent = (fireEvent !== false);
				if (idx >= 0) {		
					// 1. does the connection have a before detach (note this also checks jsPlumb's bound
					// detach handlers; but then Endpoint's check will, too, hmm.)
					if (forceDetach || connection._forceDetach || connection.isDetachable() || connection.isDetachAllowed(connection)) {
						// get the target endpoint
						var t = connection.endpoints[0] == self ? connection.endpoints[1] : connection.endpoints[0];
						// it would be nice to check with both endpoints that it is ok to detach. but 
						// for this we'll have to get a bit fancier: right now if you use the same beforeDetach
						// interceptor for two endpoints (which is kind of common, because it's part of the
						// endpoint definition), then it gets fired twice.  so in fact we need to loop through
						// each beforeDetach and see if it returns false, at which point we exit.  but if it
						// returns true, we have to check the next one.  however we need to track which ones
						// have already been run, and not run them again.
						if (forceDetach || connection._forceDetach || (self.isDetachAllowed(connection) /*&& t.isDetachAllowed(connection)*/)) {
					
							self.connections.splice(idx, 1);										
					
							// this avoids a circular loop
							if (!ignoreTarget) {
							
								t.detach(connection, true, forceDetach);
								// check connection to see if we want to delete the endpoints associated with it.
								// we only detach those that have just this connection; this scenario is most
								// likely if we got to this bit of code because it is set by the methods that
								// create their own endpoints, like .connect or .makeTarget. the user is
								// not likely to have interacted with those endpoints.
								if (connection.endpointsToDeleteOnDetach){
									for (var i = 0; i < connection.endpointsToDeleteOnDetach.length; i++) {
										var cde = connection.endpointsToDeleteOnDetach[i];
										if (cde && cde.connections.length == 0) 
											_currentInstance.deleteEndpoint(cde);							
									}
								}
							}
							_removeElements(connection.connector.getDisplayElements(), connection.parent);
							_removeWithFunction(connectionsByScope[connection.scope], function(c) {
								return c.id == connection.id;
							});
							actuallyDetached = true;
                            var doFireEvent = (!ignoreTarget && fireEvent)
							fireDetachEvent(connection, doFireEvent);
						}
					}
				}
				return actuallyDetached;
			};			

			/*
			 * Function: detachAll
			 *   Detaches all Connections this Endpoint has.
			 *
			 * Parameters:
			 *  fireEvent   -   whether or not to fire the detach event.  defaults to false.
			 */
			this.detachAll = function(fireEvent) {
			  
			    console.log( "detachAll "+self.connections.length );
			  
				while (self.connections.length > 0) {
					self.detach(self.connections[0], false, true, fireEvent);
				}
			};
			/*
			 * Function: detachFrom
			 *   Removes any connections from this Endpoint that are connected to the given target endpoint.
			 *   
			 * Parameters:
			 *   targetEndpoint     - Endpoint from which to detach all Connections from this Endpoint.
			 *   fireEvent          - whether or not to fire the detach event. defaults to false.
			 */
			this.detachFrom = function(targetEndpoint, fireEvent) {
				var c = [];
				for ( var i = 0; i < self.connections.length; i++) {
					if (self.connections[i].endpoints[1] == targetEndpoint
							|| self.connections[i].endpoints[0] == targetEndpoint) {
						c.push(self.connections[i]);
					}
				}
				for ( var i = 0; i < c.length; i++) {
					if (self.detach(c[i], false, true, fireEvent))
						c[i].setHover(false, false);					
				}
			};			
			/*
			 * Function: detachFromConnection
			 *   Detach this Endpoint from the Connection, but leave the Connection alive. Used when dragging.
			 *   
			 * Parameters:
			 *   connection - Connection to detach from.
			 */
			this.detachFromConnection = function(connection) {
				var idx = _findIndex(self.connections, connection);
				if (idx >= 0) {
					self.connections.splice(idx, 1);
				}
			};

			/*
			 * Function: getElement
			 *   Returns the DOM element this Endpoint is attached to.
			 */
			this.getElement = function() {
				return _element;
			};		
			
			/*
			 * Function: setElement
			 * Sets the DOM element this Endpoint is attached to.  
			 */
			this.setElement = function(el) {
				// TODO possibly have this object take charge of moving the UI components into the appropriate
				// parent.  this is used only by makeSource right now, and that function takes care of
				// moving the UI bits and pieces.  however it would s			
				var parentId = _getId(el);
				// remove the endpoint from the list for the current endpoint's element
				_removeWithFunction(endpointsByElement[_elementId], function(e) {
					return e.id == self.id;
				});
				_element = _getElementObject(el);
				_elementId = _getId(_element);
				self.elementId = _elementId;
				
				// need to get the new parent now
				var newParentElement = _getParentFromParams({source:parentId}),
				curParent = jpcl.getParent(self.canvas);
				jpcl.removeElement(self.canvas, curParent);
				jpcl.appendElement(self.canvas, newParentElement);								
				
				// now move connection(s)...i would expect there to be only one but we will iterate.
				for (var i = 0; i < self.connections.length; i++) {
					self.connections[i].moveParent(newParentElement);
					self.connections[i].sourceId = _elementId;
					self.connections[i].source = _element;					
				}	
									
				_addToList(endpointsByElement, parentId, self);
				_currentInstance.repaint(parentId);
			};

			/*
			 * Function: getUuid
			 *   Returns the UUID for this Endpoint, if there is one. Otherwise returns null.
			 */
			this.getUuid = function() {
				return _uuid;
			};
			/**
			 * private but must be exposed.
			 */
			this.makeInPlaceCopy = function() {
				return _newEndpoint( { 
					anchor : self.anchor, 
					source : _element, 
					paintStyle : this.paintStyle, 
					endpoint : _endpoint,
					_transient:true,
                    scope:self.scope
				});
			};
			/*
			 * Function: isConnectedTo
			 *   Returns whether or not this endpoint is connected to the given Endpoint.
			 *   
			 * Parameters:
			 *   endpoint - Endpoint to test.
			 */
			this.isConnectedTo = function(endpoint) {
				var found = false;
				if (endpoint) {
					for ( var i = 0; i < self.connections.length; i++) {
						if (self.connections[i].endpoints[1] == endpoint) {
							found = true;
							break;
						}
					}
				}
				return found;
			};

			/**
			 * private but needs to be exposed.
			 */
			this.isFloating = function() {
				return floatingEndpoint != null;
			};
			
			/**
			 * returns a connection from the pool; used when dragging starts.  just gets the head of the array if it can.
			 */
			this.connectorSelector = function() {
				var candidate = self.connections[0];
				if (self.isTarget && candidate) return candidate;
				else {
					return (self.connections.length < _maxConnections) || _maxConnections == -1 ? null : candidate;
				}
			};

			/*
			 * Function: isFull
			 *   Returns whether or not the Endpoint can accept any more Connections.
			 */
			this.isFull = function() {
				return !(self.isFloating() || _maxConnections < 1 || self.connections.length < _maxConnections);				
			};
			/*
			 * Function: setDragAllowedWhenFull
			 *   Sets whether or not connections can be dragged from this Endpoint once it is full. You would use this in a UI in 
			 *   which you're going to provide some other way of breaking connections, if you need to break them at all. This property 
			 *   is by default true; use it in conjunction with the 'reattach' option on a connect call.
			 *   
			 * Parameters:
			 *   allowed - whether drag is allowed or not when the Endpoint is full.
			 */
			this.setDragAllowedWhenFull = function(allowed) {
				dragAllowedWhenFull = allowed;
			};
			/*
			 * Function: setStyle
			 *   Sets the paint style of the Endpoint.  This is a JS object of the same form you supply to a jsPlumb.addEndpoint or jsPlumb.connect call.
			 *   TODO move setStyle into EventGenerator, remove it from here. is Connection's method currently setPaintStyle ? wire that one up to
			 *   setStyle and deprecate it if so.
			 *   
			 * Parameters:
			 *   style - Style object to set, for example {fillStyle:"blue"}.
			 *   
			 *  @deprecated use setPaintStyle instead.
			 */
			this.setStyle = self.setPaintStyle;

			/**
			 * a deep equals check. everything must match, including the anchor,
			 * styles, everything. TODO: finish Endpoint.equals
			 */
			this.equals = function(endpoint) {
				return this.anchor.equals(endpoint.anchor);
			};
			
			// a helper function that tries to find a connection to the given element, and returns it if so. if elementWithPrecedence is null,
			// or no connection to it is found, we return the first connection in our list.
			var findConnectionToUseForDynamicAnchor = function(elementWithPrecedence) {
				var idx = 0;
				if (elementWithPrecedence != null) {
					for (var i = 0; i < self.connections.length; i++) {
						if (self.connections[i].sourceId == elementWithPrecedence || self.connections[i].targetId == elementWithPrecedence) {
							idx = i;
							break;
						}
					}
				}
				
				return self.connections[idx];
			};

			/*
			 * Function: paint
			 *   Paints the Endpoint, recalculating offset and anchor positions if necessary. This does NOT paint
			 *   any of the Endpoint's connections.
			 *   
			 * Parameters:
			 *   timestamp - optional timestamp advising the Endpoint of the current paint time; if it has painted already once for this timestamp, it will not paint again.
			 *   canvas - optional Canvas to paint on.  Only used internally by jsPlumb in certain obscure situations.
			 *   connectorPaintStyle - paint style of the Connector attached to this Endpoint. Used to get a fillStyle if nothing else was supplied.
			 */
			this.paint = function(params) {
				params = params || {};
				var timestamp = params.timestamp,
                    recalc = !(params.recalc === false);
				if (!timestamp || self.timestamp !== timestamp) {			
					_updateOffset({ elId:_elementId, timestamp:timestamp, recalc:recalc });
					var xy = params.offset || offsets[_elementId];
					if(xy) {
						var ap = params.anchorPoint,connectorPaintStyle = params.connectorPaintStyle;
						if (ap == null) {
							var wh = params.dimensions || sizes[_elementId];
							if (xy == null || wh == null) {
								_updateOffset( { elId : _elementId, timestamp : timestamp });
								xy = offsets[_elementId];
								wh = sizes[_elementId];
							}
							var anchorParams = { xy : [ xy.left, xy.top ], wh : wh, element : self, timestamp : timestamp };
							if (recalc && self.anchor.isDynamic && self.connections.length > 0) {
								var c = findConnectionToUseForDynamicAnchor(params.elementWithPrecedence),
								oIdx = c.endpoints[0] == self ? 1 : 0,
								oId = oIdx == 0 ? c.sourceId : c.targetId,
								oOffset = offsets[oId], oWH = sizes[oId];
								anchorParams.txy = [ oOffset.left, oOffset.top ];
								anchorParams.twh = oWH;
								anchorParams.tElement = c.endpoints[oIdx];
							}
							ap = self.anchor.compute(anchorParams);
						}
											
						var d = _endpoint.compute(ap, self.anchor.getOrientation(_endpoint), self.paintStyleInUse, connectorPaintStyle || self.paintStyleInUse);
						_endpoint.paint(d, self.paintStyleInUse, self.anchor);					
						self.timestamp = timestamp;


						/* paint overlays*/
						for ( var i = 0; i < self.overlays.length; i++) {
							var o = self.overlays[i];
							if (o.isVisible) self.overlayPlacements[i] = o.draw(self.endpoint, self.paintStyleInUse, d);
						}
					}
				}
			};

            this.repaint = this.paint;

			/**
			 * @deprecated
			 */
			this.removeConnection = this.detach; // backwards compatibility

			// is this a connection source? we make it draggable and have the
			// drag listener maintain a connection with a floating endpoint.
			if (jsPlumb.CurrentLibrary.isDragSupported(_element)) {
				var placeholderInfo = {
						id:null,
						element:null
				    },
                    jpc = null,
                    existingJpc = false,
                    existingJpcParams = null,
                    _dragHandler = _makeConnectionDragHandler(placeholderInfo);

				var start = function() {	
				// drag might have started on an endpoint that is not actually a source, but which has
				// one or more connections.
					jpc = self.connectorSelector();
                    var _continue = true;
					// if no connection and we're not a source, return.
					if (jpc == null && !params.isSource) _continue = false;
                    // otherwise if we're full and not allowed to drag, also return false.
                    if (params.isSource && self.isFull() && !dragAllowedWhenFull) _continue = false;

                    // if the connection was setup as not detachable (or one of its endpoints
                    // was setup as connectionsDetachable = false, or Defaults.ConnectionsDetachable
                    // is set to false...
                    if (jpc != null && !jpc.isDetachable()) _continue = false;

                    if (_continue === false) {
                        // this is for mootools and yui. returning false from this causes jquery to stop drag.
                        // the events are wrapped in both mootools and yui anyway, but i don't think returning
                        // false from the start callback would stop a drag.
                        if (jsPlumb.CurrentLibrary.stopDrag) jsPlumb.CurrentLibrary.stopDrag();
                        _dragHandler.stopDrag();
                        return false;
                    }

					// if we're not full but there was a connection, make it null. we'll create a new one.
					if (jpc && !self.isFull() && params.isSource) jpc = null;

					_updateOffset( { elId : _elementId });
					inPlaceCopy = self.makeInPlaceCopy();
					inPlaceCopy.paint();										
					
					_makeDraggablePlaceholder(placeholderInfo, self.parent);
					
					// set the offset of this div to be where 'inPlaceCopy' is, to start with.
					// TODO merge this code with the code in both Anchor and FloatingAnchor, because it
					// does the same stuff.
					var ipcoel = _getElementObject(inPlaceCopy.canvas),
					    ipco = jsPlumb.CurrentLibrary.getOffset(ipcoel),
					    po = adjustForParentOffsetAndScroll([ipco.left, ipco.top], inPlaceCopy.canvas);
					jsPlumb.CurrentLibrary.setOffset(placeholderInfo.element, {left:po[0], top:po[1]});															
					
					// when using makeSource and a parent, we first draw the source anchor on the source element, then
					// move it to the parent.  note that this happens after drawing the placeholder for the
					// first time.
					if (self.parentAnchor) self.anchor = _currentInstance.makeAnchor(self.parentAnchor, self.elementId, _currentInstance);


					// store the id of the dragging div and the source element. the drop function will pick these up.					
					_setAttribute(_getElementObject(self.canvas), "dragId", placeholderInfo.id);
					_setAttribute(_getElementObject(self.canvas), "elId", _elementId);
					// create a floating anchor
					floatingEndpoint = _makeFloatingEndpoint(self.paintStyle, self.anchor, _endpoint, self.canvas, placeholderInfo.element);
					
					if (jpc == null) {                                                                                                                                                         
						self.anchor.locked = true;
                        self.setHover(false, false);
                        // TODO the hover call above does not reset any target endpoint's hover
                        // states.
						// create a connection. one end is this endpoint, the other is a floating endpoint.
						jpc = _newConnection({
							sourceEndpoint : self,
							targetEndpoint : floatingEndpoint,
							source : self.endpointWillMoveTo || _getElementObject(_element),  // for makeSource with parent option.  ensure source element is represented correctly.
							target : placeholderInfo.element,
							anchors : [ self.anchor, floatingEndpoint.anchor ],
							paintStyle : params.connectorStyle, // this can be null. Connection will use the default.
							hoverPaintStyle:params.connectorHoverStyle,
							connector : params.connector, // this can also be null. Connection will use the default.
							overlays : params.connectorOverlays 
						});

					} else {
						existingJpc = true;
						jpc.connector.setHover(false, false);
                       // jpc.endpoints[0].setHover(false, false);
                        //jpc.endpoints[1].setHover(false, false);
						// if existing connection, allow to be dropped back on the source endpoint (issue 51).
						_initDropTarget(_getElementObject(inPlaceCopy.canvas), false, true);
						//var anchorIdx = jpc.sourceId == _elementId ? 0 : 1;  	// are we the source or the target?
                        // new anchor idx
						var anchorIdx = jpc.endpoints[0].id == self.id ? 0 : 1;
						jpc.floatingAnchorIndex = anchorIdx;					// save our anchor index as the connection's floating index.						
						self.detachFromConnection(jpc);							// detach from the connection while dragging is occurring.
						
						// store the original scope (issue 57)
						var c = _getElementObject(self.canvas),
						    dragScope = jsPlumb.CurrentLibrary.getDragScope(c);
						_setAttribute(c, "originalScope", dragScope);
						// now we want to get this endpoint's DROP scope, and set it for now: we can only be dropped on drop zones
						// that have our drop scope (issue 57).
						var dropScope = jsPlumb.CurrentLibrary.getDropScope(c);
						jsPlumb.CurrentLibrary.setDragScope(c, dropScope);
				
						// now we replace ourselves with the temporary div we created above:
						if (anchorIdx == 0) {
							existingJpcParams = [ jpc.source, jpc.sourceId, i, dragScope ];
							jpc.source = placeholderInfo.element;
							jpc.sourceId = placeholderInfo.id;
						} else {
							existingJpcParams = [ jpc.target, jpc.targetId, i, dragScope ];
							jpc.target = placeholderInfo.element;
							jpc.targetId = placeholderInfo.id;
						}

						// lock the other endpoint; if it is dynamic it will not move while the drag is occurring.
						jpc.endpoints[anchorIdx == 0 ? 1 : 0].anchor.locked = true;
						// store the original endpoint and assign the new floating endpoint for the drag.
						jpc.suspendedEndpoint = jpc.endpoints[anchorIdx];
                        jpc.suspendedEndpoint.setHover(false);
						jpc.endpoints[anchorIdx] = floatingEndpoint;
					}
					// register it and register connection on it.
					floatingConnections[placeholderInfo.id] = jpc;
					floatingEndpoint.addConnection(jpc);
					// only register for the target endpoint; we will not be dragging the source at any time
					// before this connection is either discarded or made into a permanent connection.
					_addToList(endpointsByElement, placeholderInfo.id, floatingEndpoint);
					// tell jsplumb about it
					_currentInstance.currentlyDragging = true;
				};

				var jpcl = jsPlumb.CurrentLibrary,
				    dragOptions = params.dragOptions || {},
				    defaultOpts = jsPlumb.extend( {}, jpcl.defaultDragOptions),
				    startEvent = jpcl.dragEvents["start"],
				    stopEvent = jpcl.dragEvents["stop"],
				    dragEvent = jpcl.dragEvents["drag"];
				
				dragOptions = jsPlumb.extend(defaultOpts, dragOptions);
				dragOptions.scope = dragOptions.scope || self.scope;
				dragOptions[startEvent] = _wrap(dragOptions[startEvent], start);
				// extracted drag handler function so can be used by makeSource
				dragOptions[dragEvent] = _wrap(dragOptions[dragEvent], _dragHandler.drag);
				dragOptions[stopEvent] = _wrap(dragOptions[stopEvent],
					function() {	
						_currentInstance.currentlyDragging = false;						
						_removeWithFunction(endpointsByElement[placeholderInfo.id], function(e) {
							return e.id == floatingEndpoint.id;
						});
						_removeElements( [ placeholderInfo.element[0], floatingEndpoint.canvas ], _element); // TODO: clean up the connection canvas (if the user aborted)
						_removeElement(inPlaceCopy.canvas, _element);
						_currentInstance.anchorManager.clearFor(placeholderInfo.id);
						var idx = jpc.floatingAnchorIndex == null ? 1 : jpc.floatingAnchorIndex;
						jpc.endpoints[idx == 0 ? 1 : 0].anchor.locked = false;
						if (jpc.endpoints[idx] == floatingEndpoint) {
							// if the connection was an existing one:
							if (existingJpc && jpc.suspendedEndpoint) {
								// fix for issue35, thanks Sylvain Gizard: when firing the detach event make sure the
								// floating endpoint has been replaced.
								if (idx == 0) {
									jpc.source = existingJpcParams[0];
									jpc.sourceId = existingJpcParams[1];
								} else {
									jpc.target = existingJpcParams[0];
									jpc.targetId = existingJpcParams[1];
								}
								
								// restore the original scope (issue 57)
								jsPlumb.CurrentLibrary.setDragScope(existingJpcParams[2], existingJpcParams[3]);
								jpc.endpoints[idx] = jpc.suspendedEndpoint;
								if (self.isReattach || jpc._forceDetach || !jpc.endpoints[idx == 0 ? 1 : 0].detach(jpc)) {
									jpc.setHover(false);
									jpc.floatingAnchorIndex = null;
									jpc.suspendedEndpoint.addConnection(jpc);
									_currentInstance.repaint(existingJpcParams[1]);
								}
                                jpc._forceDetach = null;
							} else {
								// TODO this looks suspiciously kind of like an Endpoint.detach call too.
								// i wonder if this one should post an event though.  maybe this is good like this.
								_removeElements(jpc.connector.getDisplayElements(), self.parent);
								self.detachFromConnection(jpc);								
							}																
						}
						self.anchor.locked = false;												
						self.paint({recalc:false});
						jpc.setHover(false, false);
						jpc = null;						
						inPlaceCopy = null;							
						delete endpointsByElement[floatingEndpoint.elementId];
						floatingEndpoint.anchor = null;
                        floatingEndpoint = null;
						_currentInstance.currentlyDragging = false;
					});
				
				var i = _getElementObject(self.canvas);				
				jsPlumb.CurrentLibrary.initDraggable(i, dragOptions, true);
			}

			// pulled this out into a function so we can reuse it for the inPlaceCopy canvas; you can now drop detached connections
			// back onto the endpoint you detached it from.
			var _initDropTarget = function(canvas, forceInit, isTransient) {
				if ((params.isTarget || forceInit) && jsPlumb.CurrentLibrary.isDropSupported(_element)) {
					var dropOptions = params.dropOptions || _currentInstance.Defaults.DropOptions || jsPlumb.Defaults.DropOptions;
					dropOptions = jsPlumb.extend( {}, dropOptions);
					dropOptions.scope = dropOptions.scope || self.scope;
					var dropEvent = jsPlumb.CurrentLibrary.dragEvents['drop'],
					    overEvent = jsPlumb.CurrentLibrary.dragEvents['over'],
					    outEvent = jsPlumb.CurrentLibrary.dragEvents['out'],
					drop = function(originalEvent) {
						var draggable = _getElementObject(jsPlumb.CurrentLibrary.getDragObject(arguments)),
						id = _getAttribute(draggable, "dragId"),
						elId = _getAttribute(draggable, "elId"),						
						scope = _getAttribute(draggable, "originalScope"),
						jpc = floatingConnections[id],
						idx = jpc.floatingAnchorIndex == null ? 1 : jpc.floatingAnchorIndex, oidx = idx == 0 ? 1 : 0;
						
						// restore the original scope if necessary (issue 57)						
						if (scope) jsPlumb.CurrentLibrary.setDragScope(draggable, scope);							
						
						if (!self.isFull() && !(idx == 0 && !self.isSource) && !(idx == 1 && !self.isTarget)) {
						
							var _doContinue = true;
                            // the second check here is for the case that the user is dropping it back
                            // where it came from.
							if (jpc.suspendedEndpoint && jpc.suspendedEndpoint.id != self.id) {
								if (!jpc.isDetachAllowed(jpc) || !jpc.endpoints[idx].isDetachAllowed(jpc) || !jpc.suspendedEndpoint.isDetachAllowed(jpc) || !_currentInstance.checkCondition("beforeDetach", jpc))
									_doContinue = false;								
							}
			
							// these have to be set before testing for beforeDrop.
							if (idx == 0) {
								jpc.source = _element;
								jpc.sourceId = _elementId;
							} else {
								jpc.target = _element;
								jpc.targetId = _elementId;
							}
							
							// now check beforeDrop.  this will be available only on Endpoints that are setup to
							// have a beforeDrop condition (although, secretly, under the hood all Endpoints and 
							// the Connection have them, because they are on jsPlumbUIComponent.  shhh!), because
							// it only makes sense to have it on a target endpoint.
							_doContinue = _doContinue && self.isDropAllowed(jpc.sourceId, jpc.targetId, jpc.scope);
													
							if (_doContinue) {
								// remove this jpc from the current endpoint
								jpc.endpoints[idx].detachFromConnection(jpc);
								if (jpc.suspendedEndpoint) jpc.suspendedEndpoint.detachFromConnection(jpc);
								jpc.endpoints[idx] = self;
								self.addConnection(jpc);
								if (!jpc.suspendedEndpoint) {  
									//_addToList(connectionsByScope, jpc.scope, jpc);
									_initDraggableIfNecessary(_element, params.draggable, {});
								}
								else {
									var suspendedElement = jpc.suspendedEndpoint.getElement(), suspendedElementId = jpc.suspendedEndpoint.elementId;
									// fire a detach event
									fireDetachEvent({
										source : idx == 0 ? suspendedElement : jpc.source, 
										target : idx == 1 ? suspendedElement : jpc.target,
										sourceId : idx == 0 ? suspendedElementId : jpc.sourceId, 
										targetId : idx == 1 ? suspendedElementId : jpc.targetId,
										sourceEndpoint : idx == 0 ? jpc.suspendedEndpoint : jpc.endpoints[0], 
										targetEndpoint : idx == 1 ? jpc.suspendedEndpoint : jpc.endpoints[1],
										connection : jpc
									}, true);
								}

                                // finalise will inform the anchor manager and also add to
                                // connectionsByScope if necessary.
                                _finaliseConnection(jpc, null, originalEvent);
							}
							else {
                                // otherwise just put it back on the endpoint it was on before the drag.
								if (jpc.suspendedEndpoint) {
                            //        self.detachFrom(jpc);
                                    jpc.endpoints[idx] = jpc.suspendedEndpoint;
									jpc.setHover(false);
                                    jpc._forceDetach = true;
                                    if (idx == 0) {
								        jpc.source = jpc.suspendedEndpoint.element;
								        jpc.sourceId = jpc.suspendedEndpoint.elementId;
							        } else {
								        jpc.target = jpc.suspendedEndpoint.element;
								        jpc.targetId = jpc.suspendedEndpoint.elementId;;
							        }
								    jpc.suspendedEndpoint.addConnection(jpc);

                                    jpc.endpoints[0].repaint();
                                    jpc.repaint();
									_currentInstance.repaint(jpc.source.elementId);
                                    jpc._forceDetach = false;
								}
							}

                            jpc.floatingAnchorIndex = null;
						}
						_currentInstance.currentlyDragging = false;
						delete floatingConnections[id];						
					};
					
					dropOptions[dropEvent] = _wrap(dropOptions[dropEvent], drop);
					dropOptions[overEvent] = _wrap(dropOptions[overEvent], function() {
						if (self.isTarget) {
							var draggable = jsPlumb.CurrentLibrary.getDragObject(arguments),
								id = _getAttribute( _getElementObject(draggable), "dragId"),
								jpc = floatingConnections[id];
							if (jpc != null) {
								var idx = jpc.floatingAnchorIndex == null ? 1 : jpc.floatingAnchorIndex;
								jpc.endpoints[idx].anchor.over(self.anchor);
							}
						}
					});	
					dropOptions[outEvent] = _wrap(dropOptions[outEvent], function() {
						if (self.isTarget) {
							var draggable = jsPlumb.CurrentLibrary.getDragObject(arguments),
								id = _getAttribute( _getElementObject(draggable), "dragId"),
								jpc = floatingConnections[id];
							if (jpc != null) {
								var idx = jpc.floatingAnchorIndex == null ? 1 : jpc.floatingAnchorIndex;
								jpc.endpoints[idx].anchor.out();
							}
						}
					});
					jsPlumb.CurrentLibrary.initDroppable(canvas, dropOptions, true, isTransient);
				}
			};
			
			// initialise the endpoint's canvas as a drop target.  this will be ignored if the endpoint is not a target or drag is not supported.
			_initDropTarget(_getElementObject(self.canvas), true, !(params._transient || self.anchor.isFloating));

			return self;
		};					
	};		

	var jsPlumb = window.jsPlumb = new jsPlumbInstance();
	jsPlumb.getInstance = function(_defaults) {
		var j = new jsPlumbInstance(_defaults);
		j.init();
		return j;
	};
	jsPlumb.util = {
		convertStyle : function(s, ignoreAlpha) {
			// TODO: jsPlumb should support a separate 'opacity' style member.
			if ("transparent" === s) return s;
			var o = s,
			    pad = function(n) { return n.length == 1 ? "0" + n : n; },
			    hex = function(k) { return pad(Number(k).toString(16)); },
			    pattern = /(rgb[a]?\()(.*)(\))/;
			if (s.match(pattern)) {
				var parts = s.match(pattern)[2].split(",");
				o = "#" + hex(parts[0]) + hex(parts[1]) + hex(parts[2]);
				if (!ignoreAlpha && parts.length == 4) 
					o = o + hex(parts[3]);
			}
			return o;
		},
		gradient : function(p1, p2) {
			p1 = p1.constructor == Array ? p1 : [p1.x, p1.y];
			p2 = p2.constructor == Array ? p2 : [p2.x, p2.y];			
			return (p2[1] - p1[1]) / (p2[0] - p1[0]);		
		},
		normal : function(p1, p2) {
			return -1 / jsPlumb.util.gradient(p1,p2);
		},
        segment : function(p1, p2) {
            p1 = p1.constructor == Array ? p1 : [p1.x, p1.y];
            p2 = p2.constructor == Array ? p2 : [p2.x, p2.y];
            if (p2[0] > p1[0]) {
                return (p2[1] > p1[1]) ? 2 : 1;
            }
            else {
                return (p2[1] > p1[1]) ? 3 : 4;
            }
        },
        segmentMultipliers : [null, [1, -1], [1, 1], [-1, 1], [-1, -1] ],
        inverseSegmentMultipliers : [null, [-1, -1], [-1, 1], [1, 1], [1, -1] ],
		pointOnLine : function(fromPoint, toPoint, distance) {
            var m = jsPlumb.util.gradient(fromPoint, toPoint),
                s = jsPlumb.util.segment(fromPoint, toPoint),
			    segmentMultiplier = distance > 0 ? jsPlumb.util.segmentMultipliers[s] : jsPlumb.util.inverseSegmentMultipliers[s],
				theta = Math.atan(m),
        		y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1],
				x =  Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];
			return { x:fromPoint.x + x, y:fromPoint.y + y };
		},
        /**
         * calculates a perpendicular to the line fromPoint->toPoint, that passes through toPoint and is 'length' long.
         * @param fromPoint
         * @param toPoint
         * @param length
         */
		perpendicularLineTo : function(fromPoint, toPoint, length) {
			var m = jsPlumb.util.gradient(fromPoint, toPoint),
                theta2 = Math.atan(-1 / m),
        		y =  length / 2 * Math.sin(theta2),
				x =  length / 2 * Math.cos(theta2);
			return [{x:toPoint.x + x, y:toPoint.y + y}, {x:toPoint.x - x, y:toPoint.y - y}];
		}
	};
	
	var _curryAnchor = function(x, y, ox, oy, type, fnInit) {
		return function(params) {
			params = params || {};
			//var a = jsPlumb.makeAnchor([ x, y, ox, oy, 0, 0 ], params.elementId, params.jsPlumbInstance);
			var a = params.jsPlumbInstance.makeAnchor([ x, y, ox, oy, 0, 0 ], params.elementId, params.jsPlumbInstance);
			a.type = type;
			if (fnInit) fnInit(a, params);
			return a;
		};
	};
	jsPlumb.Anchors["TopCenter"] 		= _curryAnchor(0.5, 0, 0,-1, "TopCenter");
	jsPlumb.Anchors["BottomCenter"] 	= _curryAnchor(0.5, 1, 0, 1, "BottomCenter");
	jsPlumb.Anchors["LeftMiddle"] 		= _curryAnchor(0, 0.5, -1, 0, "LeftMiddle");
	jsPlumb.Anchors["RightMiddle"] 		= _curryAnchor(1, 0.5, 1, 0, "RightMiddle");
	jsPlumb.Anchors["Center"] 			= _curryAnchor(0.5, 0.5, 0, 0, "Center");
	jsPlumb.Anchors["TopRight"] 		= _curryAnchor(1, 0, 0,-1, "TopRight");
	jsPlumb.Anchors["BottomRight"] 		= _curryAnchor(1, 1, 0, 1, "BottomRight");
	jsPlumb.Anchors["TopLeft"] 			= _curryAnchor(0, 0, 0, -1, "TopLeft");
	jsPlumb.Anchors["BottomLeft"] 		= _curryAnchor(0, 1, 0, 1, "BottomLeft");
		
	// TODO test that this does not break with the current instance idea
	jsPlumb.Defaults.DynamicAnchors = function(params) {
		return params.jsPlumbInstance.makeAnchors(["TopCenter", "RightMiddle", "BottomCenter", "LeftMiddle"], params.elementId, params.jsPlumbInstance);
	};
	jsPlumb.Anchors["AutoDefault"]  = function(params) { 
		var a = params.jsPlumbInstance.makeDynamicAnchor(jsPlumb.Defaults.DynamicAnchors(params));
		a.type = "AutoDefault";
		return a;
	};
	
	jsPlumb.Anchors["Assign"] = _curryAnchor(0,0,0,0,"Assign", function(anchor, params) {
		// find what to use as the "position finder". the user may have supplied a String which represents
		// the id of a position finder in jsPlumb.AnchorPositionFinders, or the user may have supplied the
		// position finder as a function.  we find out what to use and then set it on the anchor.
		var pf = params.position || "Fixed";
		anchor.positionFinder = pf.constructor == String ? params.jsPlumbInstance.AnchorPositionFinders[pf] : pf;
		// always set the constructor params; the position finder might need them later (the Grid one does,
		// for example)
		anchor.constructorParams = params;
	});

	// Continuous anchor is just curried through to the 'get' method of the continuous anchor
	// factory.
	jsPlumb.Anchors["Continuous"] = function(params) {
		return params.jsPlumbInstance.continuousAnchorFactory.get(params);
	};

    // these are the default anchor positions finders, which are used by the makeTarget function.  supply
    // a position finder argument to that function allows you to specify where the resulting anchor will
    // be located
	jsPlumb.AnchorPositionFinders = {
		"Fixed": function(dp, ep, es, a) {
			return [ (dp.left - ep.left) / es[0], (dp.top - ep.top) / es[1] ];	
		},
		"Grid":function(dp, ep, es, a) {
			var dx = dp.left - ep.left, dy = dp.top - ep.top,
				gx = es[0] / (a.constructorParams.grid[0]), gy = es[1] / (a.constructorParams.grid[1]),
				mx = Math.floor(dx / gx), my = Math.floor(dy / gy);
			return [ ((mx * gx) + (gx / 2)) / es[0], ((my * gy) + (gy / 2)) / es[1] ];
		}
	};
})();
/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.3.5
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the default Connectors, Endpoint and Overlay definitions.
 *
 * Copyright (c) 2010 - 2012 Simon Porritt (http://jsplumb.org)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */

(function() {	
				
	/**
	 * 
	 * Helper class to consume unused mouse events by components that are DOM elements and
	 * are used by all of the different rendering modes.
	 * 
	 */
	jsPlumb.DOMElementComponent = function(params) {
		jsPlumb.jsPlumbUIComponent.apply(this, arguments);
		// when render mode is canvas, these functions may be called by the canvas mouse handler.  
		// this component is safe to pipe this stuff to /dev/null.
		this.mousemove = 
		this.dblclick  = 
		this.click = 
		this.mousedown = 
		this.mouseup = function(e) { };					
	};
	                                   
    /**
     * Class: Connectors.Straight
     * The Straight connector draws a simple straight line between the two anchor points.  It does not have any constructor parameters.
     */
    jsPlumb.Connectors.Straight = function() {
    	this.type = "Straight";
		var self = this,
		currentPoints = null,
		_m, _m2, _b, _dx, _dy, _theta, _theta2, _sx, _sy, _tx, _ty, _segment, _length;

        /**
         * Computes the new size and position of the canvas.         
         */
        this.compute = function(sourcePos, targetPos, sourceEndpoint, targetEndpoint, sourceAnchor, targetAnchor, lineWidth, minWidth) {
        	var w = Math.abs(sourcePos[0] - targetPos[0]),
            h = Math.abs(sourcePos[1] - targetPos[1]),
            // these are padding to ensure the whole connector line appears
            xo = 0.45 * w, yo = 0.45 * h;
            // these are padding to ensure the whole connector line appears
            w *= 1.9; h *=1.9;
            
            var x = Math.min(sourcePos[0], targetPos[0]) - xo;
            var y = Math.min(sourcePos[1], targetPos[1]) - yo;
            
            // minimum size is 2 * line Width if minWidth was not given.
            var calculatedMinWidth = Math.max(2 * lineWidth, minWidth);
            
            if (w < calculatedMinWidth) { 
        		w = calculatedMinWidth; 
        		x = sourcePos[0]  + ((targetPos[0] - sourcePos[0]) / 2) - (calculatedMinWidth / 2);
        		xo = (w - Math.abs(sourcePos[0]-targetPos[0])) / 2;
        	}
            if (h < calculatedMinWidth) {         
        		h = calculatedMinWidth; 
        		y = sourcePos[1]  + ((targetPos[1] - sourcePos[1]) / 2) - (calculatedMinWidth / 2);
        		yo = (h - Math.abs(sourcePos[1]-targetPos[1])) / 2;
        	}
                            
            _sx = sourcePos[0] < targetPos[0] ?  xo : w-xo;
            _sy = sourcePos[1] < targetPos[1] ? yo:h-yo;
            _tx = sourcePos[0] < targetPos[0] ? w-xo : xo;
            _ty = sourcePos[1] < targetPos[1] ? h-yo : yo;
            currentPoints = [ x, y, w, h, _sx, _sy, _tx, _ty ];                        
            _dx = _tx - _sx, _dy = _ty - _sy;
			//_m = _dy / _dx, _m2 = -1 / _m;
            _m = jsPlumb.util.gradient({x:_sx, y:_sy}, {x:_tx, y:_ty}), _m2 = -1 / _m;
			_b = -1 * ((_m * _sx) - _sy);
			_theta = Math.atan(_m); _theta2 = Math.atan(_m2);
            //_segment = jsPlumb.util.segment({x:_sx, y:_sy}, {x:_tx, y:_ty});
            _length = Math.sqrt((_dx * _dx) + (_dy * _dy));
                             
            return currentPoints;
        };
        
        
        /**
         * returns the point on the connector's path that is 'location' along the length of the path, where 'location' is a decimal from
         * 0 to 1 inclusive. for the straight line connector this is simple maths.  for Bezier, not so much.
         */
        this.pointOnPath = function(location) {
        	if (location == 0)
                return { x:_sx, y:_sy };
            else if (location == 1)
                return { x:_tx, y:_ty };
            else
                return jsPlumb.util.pointOnLine({x:_sx, y:_sy}, {x:_tx, y:_ty}, location * _length);
        };
        
        /**
         * returns the gradient of the connector at the given point - which for us is constant.
         */
        this.gradientAtPoint = function(location) {
            return _m;
        };
        
        /**
         * returns the point on the connector's path that is 'distance' along the length of the path from 'location', where 
         * 'location' is a decimal from 0 to 1 inclusive, and 'distance' is a number of pixels.
         * this hands off to jsPlumb.util to do the maths, supplying our gradient and position and whether or
         * not the coords should be flipped
         */
        this.pointAlongPathFrom = function(location, distance) {
        	var p = self.pointOnPath(location);
			return jsPlumb.util.pointOnLine(p, {x:_tx,y:_ty}, distance);
        };
    };
                
    
    /**
     * Class:Connectors.Bezier
     * This Connector draws a Bezier curve with two control points.  You can provide a 'curviness' value which gets applied to jsPlumb's
     * internal voodoo machine and ends up generating locations for the two control points.  See the constructor documentation below.
     */
    /**
     * Function:Constructor
     * 
     * Parameters:
     * 	curviness - How 'curvy' you want the curve to be! This is a directive for the placement of control points, not endpoints of the curve, so your curve does not 
     * actually touch the given point, but it has the tendency to lean towards it.  The larger this value, the greater the curve is pulled from a straight line.
     * Optional; defaults to 150.
     * 
     */
    jsPlumb.Connectors.Bezier = function(params) {
    	var self = this;
    	params = params || {};
    	this.majorAnchor = params.curviness || 150;
        this.minorAnchor = 10;
        var currentPoints = null;
        this.type = "Bezier";
        
        this._findControlPoint = function(point, sourceAnchorPosition, targetAnchorPosition, sourceEndpoint, targetEndpoint, sourceAnchor, targetAnchor) {
        	// determine if the two anchors are perpendicular to each other in their orientation.  we swap the control 
        	// points around if so (code could be tightened up)
        	var soo = sourceAnchor.getOrientation(sourceEndpoint), 
        		too = targetAnchor.getOrientation(targetEndpoint),
        		perpendicular = soo[0] != too[0] || soo[1] == too[1],
            	p = [],            
            	ma = self.majorAnchor, mi = self.minorAnchor;                
            	
            if (!perpendicular) {
                if (soo[0] == 0) // X
                    p.push(sourceAnchorPosition[0] < targetAnchorPosition[0] ? point[0] + mi : point[0] - mi);
                else p.push(point[0] - (ma * soo[0]));
                                 
                if (soo[1] == 0) // Y
                	p.push(sourceAnchorPosition[1] < targetAnchorPosition[1] ? point[1] + mi : point[1] - mi);
                else p.push(point[1] + (ma * too[1]));
            }
             else {
                if (too[0] == 0) // X
                	p.push(targetAnchorPosition[0] < sourceAnchorPosition[0] ? point[0] + mi : point[0] - mi);
                else p.push(point[0] + (ma * too[0]));
                
                if (too[1] == 0) // Y
                	p.push(targetAnchorPosition[1] < sourceAnchorPosition[1] ? point[1] + mi : point[1] - mi);
                else p.push(point[1] + (ma * soo[1]));
             }

            return p;                
        };        

        var _CP, _CP2, _sx, _tx, _ty, _sx, _sy, _canvasX, _canvasY, _w, _h;

        this.compute = function(sourcePos, targetPos, sourceEndpoint, targetEndpoint, sourceAnchor, targetAnchor, lineWidth, minWidth) {
        	lineWidth = lineWidth || 0;
            _w = Math.abs(sourcePos[0] - targetPos[0]) + lineWidth; 
            _h = Math.abs(sourcePos[1] - targetPos[1]) + lineWidth;
            _canvasX = Math.min(sourcePos[0], targetPos[0])-(lineWidth/2);
            _canvasY = Math.min(sourcePos[1], targetPos[1])-(lineWidth/2);
            _sx = sourcePos[0] < targetPos[0] ? _w - (lineWidth/2): (lineWidth/2);
            _sy = sourcePos[1] < targetPos[1] ? _h - (lineWidth/2) : (lineWidth/2);
            _tx = sourcePos[0] < targetPos[0] ? (lineWidth/2) : _w - (lineWidth/2);
            _ty = sourcePos[1] < targetPos[1] ? (lineWidth/2) : _h - (lineWidth/2);
            _CP = self._findControlPoint([_sx,_sy], sourcePos, targetPos, sourceEndpoint, targetEndpoint, sourceAnchor, targetAnchor);
            _CP2 = self._findControlPoint([_tx,_ty], targetPos, sourcePos, sourceEndpoint, targetEndpoint, targetAnchor, sourceAnchor);                
            var minx1 = Math.min(_sx,_tx), minx2 = Math.min(_CP[0], _CP2[0]), minx = Math.min(minx1,minx2),
            	maxx1 = Math.max(_sx,_tx), maxx2 = Math.max(_CP[0], _CP2[0]), maxx = Math.max(maxx1,maxx2);
            
            if (maxx > _w) _w = maxx;
            if (minx < 0) {
                _canvasX += minx; var ox = Math.abs(minx);
                _w += ox; _CP[0] += ox; _sx += ox; _tx +=ox; _CP2[0] += ox;
            }                

            var miny1 = Math.min(_sy,_ty), miny2 = Math.min(_CP[1], _CP2[1]), miny = Math.min(miny1,miny2),
            	maxy1 = Math.max(_sy,_ty), maxy2 = Math.max(_CP[1], _CP2[1]), maxy = Math.max(maxy1,maxy2);
            	
            if (maxy > _h) _h = maxy;
            if (miny < 0) {
                _canvasY += miny; var oy = Math.abs(miny);
                _h += oy; _CP[1] += oy; _sy += oy; _ty +=oy; _CP2[1] += oy;
            }
            
            if (minWidth && _w < minWidth) {
            	var posAdjust = (minWidth - _w) / 2;
        		_w = minWidth;        		
        		_canvasX -= posAdjust; _sx = _sx + posAdjust ; _tx = _tx + posAdjust; _CP[0] =  _CP[0] + posAdjust; _CP2[0] = _CP2[0] + posAdjust;
        	}
            
            if (minWidth && _h < minWidth) {
            	var posAdjust = (minWidth - _h) / 2;
        		_h = minWidth;        		
        		_canvasY -= posAdjust; _sy = _sy + posAdjust ; _ty = _ty + posAdjust; _CP[1] =  _CP[1] + posAdjust; _CP2[1] = _CP2[1] + posAdjust;
        	}

            currentPoints = [_canvasX, _canvasY, _w, _h, _sx, _sy, _tx, _ty, _CP[0], _CP[1], _CP2[0], _CP2[1] ];            
            return currentPoints;            
        };        
        
        var _makeCurve = function() {
        	return [	
	        	{ x:_sx, y:_sy },
	        	{ x:_CP[0], y:_CP[1] },
	        	{ x:_CP2[0], y:_CP2[1] },
	        	{ x:_tx, y:_ty }
         	];
        };     
        
        /**
         * returns the point on the connector's path that is 'location' along the length of the path, where 'location' is a decimal from
         * 0 to 1 inclusive. for the straight line connector this is simple maths.  for Bezier, not so much.
         */
        this.pointOnPath = function(location) {        	
        	return jsBezier.pointOnCurve(_makeCurve(), location);
        };
        
        /**
         * returns the gradient of the connector at the given point.
         */
        this.gradientAtPoint = function(location) {
        	return jsBezier.gradientAtPoint(_makeCurve(), location);        	
        };	              
        
        /**
         * for Bezier curves this method is a little tricky, cos calculating path distance algebraically is notoriously difficult.
         * this method is iterative, jumping forward .05% of the path at a time and summing the distance between this point and the previous
         * one, until the sum reaches 'distance'. the method may turn out to be computationally expensive; we'll see.
         * another drawback of this method is that if the connector gets quite long, .05% of the length of it is not necessarily smaller
         * than the desired distance, in which case the loop returns immediately and the arrow is mis-shapen. so a better strategy might be to
         * calculate the step as a function of distance/distance between endpoints.  
         */
        this.pointAlongPathFrom = function(location, distance) {        	
        	return jsBezier.pointAlongCurveFrom(_makeCurve(), location, distance);
        };           
    };        
    
    
    /**
     * Class: Connectors.Flowchart
     * Provides 'flowchart' connectors, consisting of vertical and horizontal line segments.
     */
    /**
     * Function: Constructor
     * 
     * Parameters:
     * 	stub - minimum length for the stub at each end of the connector. defaults to 30 pixels. 
     */
    jsPlumb.Connectors.Flowchart = function(params) {
    	this.type = "Flowchart";
    	params = params || {};
		var self = this, 
		minStubLength = params.stub || params.minStubLength /* bwds compat. */ || 30, 
		segments = [],
        totalLength = 0,
		segmentProportions = [],
		segmentProportionalLengths = [],
		points = [],
		swapX, 
		swapY,
		/**
		 * recalculates the points at which the segments begin and end, proportional to the total length travelled
		 * by all the segments that constitute the connector.   we use this to help with pointOnPath calculations.
		 */
		updateSegmentProportions = function(startX, startY, endX, endY) {
			var curLoc = 0;
			for (var i = 0; i < segments.length; i++) {
				segmentProportionalLengths[i] = segments[i][5] / totalLength;
				segmentProportions[i] = [curLoc, (curLoc += (segments[i][5] / totalLength)) ];
			}
		},
		appendSegmentsToPoints = function() {
			points.push(segments.length);
			for (var i = 0; i < segments.length; i++) {
				points.push(segments[i][0]);
				points.push(segments[i][1]);
			}
		},		
		/**
		 * helper method to add a segment.
		 */
		addSegment = function(x, y, sx, sy, tx, ty) {
			var lx = segments.length == 0 ? sx : segments[segments.length - 1][0],
			    ly = segments.length == 0 ? sy : segments[segments.length - 1][1],
                m = x == lx ? Infinity : 0,
				l = Math.abs(x == lx ? y - ly : x - lx);
			segments.push([x, y, lx, ly, m, l]);
            totalLength += l;
		},
		/**
		 * returns [segment, proportion of travel in segment, segment index] for the segment 
		 * that contains the point which is 'location' distance along the entire path, where 
		 * 'location' is a decimal between 0 and 1 inclusive. in this connector type, paths 
		 * are made up of a list of segments, each of which contributes some fraction to
		 * the total length.  
		 */
		findSegmentForLocation = function(location) {
			var idx = segmentProportions.length - 1, inSegmentProportion = 0;
			for (var i = 0; i < segmentProportions.length; i++) {
				if (segmentProportions[i][1] >= location) {
					idx = i;
					inSegmentProportion = (location - segmentProportions[i][0]) / segmentProportionalLengths[i];
 					break;
				}
			}
			return { segment:segments[idx], proportion:inSegmentProportion, index:idx };
		};
		
		this.compute = function(sourcePos, targetPos, sourceEndpoint, targetEndpoint, 
            sourceAnchor, targetAnchor, lineWidth, minWidth, sourceInfo, targetInfo) {
            
            segments = [];
            totalLength = 0;
            segmentProportionalLengths = [];                    
            
            swapX = targetPos[0] < sourcePos[0]; 
            swapY = targetPos[1] < sourcePos[1];
            
            var lw = lineWidth || 1,
                offx = (lw / 2) + (minStubLength * 2), 
                offy = (lw / 2) + (minStubLength * 2),
                so = sourceAnchor.orientation || sourceAnchor.getOrientation(sourceEndpoint), 
                to = targetAnchor.orientation || targetAnchor.getOrientation(targetEndpoint),
                x = swapX ? targetPos[0] : sourcePos[0], 
                y = swapY ? targetPos[1] : sourcePos[1],
                w = Math.abs(targetPos[0] - sourcePos[0]) + 2*offx, 
                h = Math.abs(targetPos[1] - sourcePos[1]) + 2*offy;

            // if either anchor does not have an orientation set, we derive one from their relative
            // positions.  we fix the axis to be the one in which the two elements are further apart, and
            // point each anchor at the other element.  this is also used when dragging a new connection.
            if (so[0] == 0 && so[1] == 0 || to[0] == 0 && to[1] == 0) {
                var index = w > h ? 0 : 1, oIndex = [1,0][index];
                so = []; to = [];
                so[index] = sourcePos[index] > targetPos[index] ? -1 : 1;
                to[index] = sourcePos[index] > targetPos[index] ? 1 : -1;
                so[oIndex] = 0;
                to[oIndex] = 0;
            }

            if (w < minWidth) {      
                offx += (minWidth - w) / 2;
                w = minWidth;
            }
            if (h < minWidth) {             
                offy += (minWidth - h) / 2;
                h = minWidth;
            }

            var sx = swapX ? w-offx  : offx, 
                sy = swapY ? h-offy  : offy, 
                tx = swapX ? offx : w-offx ,
                ty = swapY ? offy : h-offy,
                startStubX = sx + (so[0] * minStubLength), 
                startStubY = sy + (so[1] * minStubLength),
                endStubX = tx + (to[0] * minStubLength), 
                endStubY = ty + (to[1] * minStubLength),
                isXGreaterThanStubTimes2 = Math.abs(sx - tx) > 2 * minStubLength,
                isYGreaterThanStubTimes2 = Math.abs(sy - ty) > 2 * minStubLength,
                midx = startStubX + ((endStubX - startStubX) / 2),
                midy = startStubY + ((endStubY - startStubY) / 2),
                oProduct = ((so[0] * to[0]) + (so[1] * to[1])),
                opposite = oProduct == -1,
                perpendicular = oProduct == 0,
                orthogonal = oProduct == 1; 
            
            x -= offx; y -= offy;
            points = [x, y, w, h, sx, sy, tx, ty];
            var extraPoints = [];
      
            addSegment(startStubX, startStubY, sx, sy, tx, ty);                   
                      
            var sourceAxis = so[0] == 0 ? "y" : "x",
                anchorOrientation = opposite ? "opposite" : orthogonal ? "orthogonal" : "perpendicular",
                segment = jsPlumb.util.segment([sx, sy], [tx, ty]),
                flipSourceSegments = so[sourceAxis == "x" ? 0 : 1] == -1,
                flipSegments = {
                    "x":[null, 4, 3, 2, 1],
                    "y":[null, 2, 1, 4, 3]
                }        
                
            if (flipSourceSegments)                
                segment = flipSegments[sourceAxis][segment];                                    

            var findClearedLine = function(start, mult, anchorPos, dimension) {
                return start + (mult * (( 1 - anchorPos) * dimension) + minStubLength);
                //mx = so[0] == 0 ? startStubX + ((1 - sourceAnchor.x) * sourceInfo.width) + minStubLength : startStubX,
            },

            lineCalculators = {
                oppositex : function() {
                    if (sourceEndpoint.elementId == targetEndpoint.elementId) {
                        var _y = startStubY + ((1 - sourceAnchor.y) * sourceInfo.height) + minStubLength;
                        return [ [ startStubX, _y ], [ endStubX, _y ]];
                    }
                    else if (isXGreaterThanStubTimes2 && (segment == 1 || segment == 2)) {
                        return [[ midx, sy ], [ midx, ty ]];
                    }    
                    else {
                        return [[ startStubX, midy ], [endStubX, midy ]];                
                    }
                },
                orthogonalx : function() {
                    if (segment == 1 || segment == 2) {
                        return [ [ endStubX, startStubY  ]];
                    }
                    else {
                        return [ [ startStubX, endStubY ]];
                    }
                },
                perpendicularx : function() {                
                    var my = (ty + sy) / 2;
                    if ((segment == 1 && to[1] == 1) || (segment == 2 && to[1] == -1)) {                  
                        if (Math.abs(tx - sx) > minStubLength)
                            return [ [endStubX, startStubY ]];            
                        else
                            return [ [startStubX, startStubY ], [ startStubX, my ], [ endStubX, my ]];                                
                    }  
                    else if ((segment == 3 && to[1] == -1) || (segment == 4 && to[1] == 1)) {                    
                        return [ [ startStubX, my ], [ endStubX, my ]];
                    }
                    else if ((segment == 3 && to[1] == 1) || (segment == 4 && to[1] == -1)) {                
                        return [ [ startStubX, endStubY ]];
                    }
                    else if ((segment == 1 && to[1] == -1) || (segment == 2 && to[1] == 1)) {                
                        if (Math.abs(tx - sx) > minStubLength)                    
                            return [ [ midx, startStubY ], [ midx, endStubY ]];                    
                        else
                            return [ [ startStubX, endStubY ]];                                        
                    }
                },
                oppositey : function() {
                    if (sourceEndpoint.elementId == targetEndpoint.elementId) {
                        var _x = startStubX + ((1 - sourceAnchor.x) * sourceInfo.width) + minStubLength;
                        return [ [ _x, startStubY ], [ _x, endStubY ]];
                    }
                    else if (isYGreaterThanStubTimes2 && (segment == 2 || segment == 3)) {
                        return [[ sx, midy ], [ tx, midy ]];
                    }    
                    else {
                        return [[ midx, startStubY ], [midx, endStubY ]];                
                    }
                },
                orthogonaly : function() {
                    if (segment == 2 || segment == 3) {
                        return [ [ startStubX, endStubY  ]];
                    }
                    else {
                        return [ [ endStubX, startStubY ]];
                    }
                },
                perpendiculary : function() {                
                    var mx = (tx + sx) / 2;
                    if ((segment == 2 && to[0] == -1) || (segment == 3 && to[0] == 1)) {                    
                        if (Math.abs(tx - sx) > minStubLength)
                            return [ [startStubX, endStubY ]];                    
                        else
                            return [ [startStubX, midy ], [ endStubX, midy ]];                                        
                    }  
                    else if ((segment == 1 && to[0] == -1) || (segment == 4 && to[0] == 1)) {
                        var mx = (tx + sx) / 2;
                        return [ [ mx, startStubY ], [ mx, endStubY ]];
                    }
                    else if ((segment == 1 && to[0] == 1) || (segment == 4 && to[0] == -1)) {                
                        return [ [ endStubX, startStubY ]];
                    }
                    else if ((segment == 2 && to[0] == 1) || (segment == 3 && to[0] == -1)) {                
                        if (Math.abs(ty - sy) > minStubLength)                    
                            return [ [ startStubX, midy ], [ endStubX, midy ]];                  
                        else
                            return [ [ endStubX, startStubY ]];                                    
                    }
                }
            };
                                     
            

            var pointFinder = lineCalculators[anchorOrientation + sourceAxis];
            var p = pointFinder();
            if (p) {
                for (var i = 0; i < p.length; i++) {
                    addSegment(p[i][0], p[i][1], sx, sy, tx, ty);
                }
            }                       
                             

            addSegment(endStubX, endStubY, sx, sy, tx, ty);
            addSegment(tx, ty, sx, sy, tx, ty);
            
            appendSegmentsToPoints();
            updateSegmentProportions(sx, sy, tx, ty);
            
            return points;
        };
		
		/**
         * returns the point on the connector's path that is 'location' along the length of the path, where 'location' is a decimal from
         * 0 to 1 inclusive. for this connector we must first figure out which segment the given point lies in, and then compute the x,y position
         * from our knowledge of the segment's start and end points.
         */
        this.pointOnPath = function(location) {
        	return self.pointAlongPathFrom(location, 0);
        };
        
        /**
         * returns the gradient of the connector at the given point; the gradient will be either 0 or Infinity, depending on the direction of the
         * segment the point falls in. segment gradients are calculated in the compute method.  
         */
        this.gradientAtPoint = function(location) { 
        	return segments[findSegmentForLocation(location)["index"]][4];
        };
        
        /**
         * returns the point on the connector's path that is 'distance' along the length of the path from 'location', where 
         * 'location' is a decimal from 0 to 1 inclusive, and 'distance' is a number of pixels.  when you consider this concept from the point of view
         * of this connector, it starts to become clear that there's a problem with the overlay paint code: given that this connector makes several
         * 90 degree turns, it's entirely possible that an arrow overlay could be forced to paint itself around a corner, which would look stupid. this is
         * because jsPlumb uses this method (and pointOnPath) so determine the locations of the various points that go to make up an overlay.  a better
         * solution would probably be to just use pointOnPath along with gradientAtPoint, and draw the overlay so that its axis ran along
         * a tangent to the connector.  for straight line connectors this would obviously mean the overlay was painted directly on the connector, since a 
         * tangent to a straight line is the line itself, which is what we want; for this connector, and for beziers, the results would probably be better.  an additional
         * advantage is, of course, that there's less computation involved doing it that way. 
         */
        this.pointAlongPathFrom = function(location, distance) {
        	var s = findSegmentForLocation(location), seg = s.segment, p = s.proportion, sl = segments[s.index][5], m = segments[s.index][4];
        	var e = {         		
        		x 	: m == Infinity ? seg[2] : seg[2] > seg[0] ? seg[0] + ((1 - p) * sl) - distance : seg[2] + (p * sl) + distance,
        		y 	: m == 0 ? seg[3] : seg[3] > seg[1] ? seg[1] + ((1 - p) * sl) - distance  : seg[3] + (p * sl) + distance,
        		segmentInfo : s
        	};
        	
        	return e;
        };
    };

 // ********************************* END OF CONNECTOR TYPES *******************************************************************
    
 // ********************************* ENDPOINT TYPES *******************************************************************
    
    /**
     * Class: Endpoints.Dot
     * A round endpoint, with default radius 10 pixels.
     */    	
    	
	/**
	 * Function: Constructor
	 * 
	 * Parameters:
	 * 
	 * 	radius	-	radius of the endpoint.  defaults to 10 pixels.
	 */
	jsPlumb.Endpoints.Dot = function(params) {
		this.type = "Dot";
		var self = this;
		params = params || {};				
		this.radius = params.radius || 10;
		this.defaultOffset = 0.5 * this.radius;
		this.defaultInnerRadius = this.radius / 3;			
		
		this.compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
			var r = endpointStyle.radius || self.radius,
				x = anchorPoint[0] - r,
				y = anchorPoint[1] - r;
			return [ x, y, r * 2, r * 2, r ];
		};
	};
	
	/**
	 * Class: Endpoints.Rectangle
	 * A Rectangular Endpoint, with default size 20x20.
	 */
	/**
	 * Function: Constructor
	 * 
	 * Parameters:
	 * 
	 * 	width	- width of the endpoint. defaults to 20 pixels.
	 * 	height	- height of the endpoint. defaults to 20 pixels.	
	 */
	jsPlumb.Endpoints.Rectangle = function(params) {
		this.type = "Rectangle";
		var self = this;
		params = params || {};
		this.width = params.width || 20;
		this.height = params.height || 20;
		
		this.compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
			var width = endpointStyle.width || self.width,
				height = endpointStyle.height || self.height,
				x = anchorPoint[0] - (width/2),
				y = anchorPoint[1] - (height/2);
			return [ x, y, width, height];
		};
	};
	

    var DOMElementEndpoint = function(params) {
        jsPlumb.DOMElementComponent.apply(this, arguments);
        var self = this;

        var displayElements = [  ];
        this.getDisplayElements = function() { 
            return displayElements; 
        };
        
        this.appendDisplayElement = function(el) {
            displayElements.push(el);
        };            
    };
	/**
	 * Class: Endpoints.Image
	 * Draws an image as the Endpoint.
	 */
	/**
	 * Function: Constructor
	 * 
	 * Parameters:
	 * 
	 * 	src	-	location of the image to use.
	 */
	jsPlumb.Endpoints.Image = function(params) {
				
		this.type = "Image";
		DOMElementEndpoint.apply(this, arguments);
		
		var self = this, 
			initialized = false,
			widthToUse = params.width,
			heightToUse = params.height,
            _onload = null,
            _endpoint = params.endpoint;
			
		this.img = new Image();
		self.ready = false;

		this.img.onload = function() {
			self.ready = true;
			widthToUse = widthToUse || self.img.width;
			heightToUse = heightToUse || self.img.height;
            if (_onload) {
                _onload(self);
            }
		};

        _endpoint.setImage = function(img, onload) {
            var s = img.constructor == String ? img : img.src;
            _onload = onload;
            self.img.src = img;
        };

        _endpoint.setImage(params.src || params.url, params.onload);

		this.compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
			self.anchorPoint = anchorPoint;
			if (self.ready) return [anchorPoint[0] - widthToUse / 2, anchorPoint[1] - heightToUse / 2, 
									widthToUse, heightToUse];
			else return [0,0,0,0];
		};
		
		self.canvas = document.createElement("img"), initialized = false;
		self.canvas.style["margin"] = 0;
		self.canvas.style["padding"] = 0;
		self.canvas.style["outline"] = 0;
		self.canvas.style["position"] = "absolute";
		var clazz = params.cssClass ? " " + params.cssClass : "";
		self.canvas.className = jsPlumb.endpointClass + clazz;
		if (widthToUse) self.canvas.setAttribute("width", widthToUse);
		if (heightToUse) self.canvas.setAttribute("height", heightToUse);		
		jsPlumb.appendElement(self.canvas, params.parent);
		self.attachListeners(self.canvas, self);
		
		var actuallyPaint = function(d, style, anchor) {
			if (!initialized) {
				self.canvas.setAttribute("src", self.img.src);
				initialized = true;
			}
			var x = self.anchorPoint[0] - (widthToUse / 2),
				y = self.anchorPoint[1] - (heightToUse / 2);
			jsPlumb.sizeCanvas(self.canvas, x, y, widthToUse, heightToUse);
		};
		
		this.paint = function(d, style, anchor) {
			if (self.ready) {
    			actuallyPaint(d, style, anchor);
			}
			else { 
				window.setTimeout(function() {    					
					self.paint(d, style, anchor);
				}, 200);
			}
		};				
	};
	
	/**
	 * Class: Endpoints.Blank
	 * An Endpoint that paints nothing (visible) on the screen.  Supports cssClass and hoverClass parameters like all Endpoints.
	 */
	jsPlumb.Endpoints.Blank = function(params) {
		var self = this;
		this.type = "Blank";
		DOMElementEndpoint.apply(this, arguments);		
		this.compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
			return [anchorPoint[0], anchorPoint[1],10,0];
		};
		
		self.canvas = document.createElement("div");
		self.canvas.style.display = "block";
		self.canvas.style.width = "1px";
		self.canvas.style.height = "1px";
		self.canvas.style.background = "transparent";
		self.canvas.style.position = "absolute";
		self.canvas.className = self._jsPlumb.endpointClass;
		jsPlumb.appendElement(self.canvas, params.parent);
		
		this.paint = function(d, style, anchor) {
			jsPlumb.sizeCanvas(self.canvas, d[0], d[1], d[2], d[3]);	
		};
	};
	
	/**
	 * Class: Endpoints.Triangle
	 * A triangular Endpoint.  
	 */
	/**
	 * Function: Constructor
	 * 
	 * Parameters:
	 * 
	 * 	width	-	width of the triangle's base.  defaults to 55 pixels.
	 * 	height	-	height of the triangle from base to apex.  defaults to 55 pixels.
	 */
	jsPlumb.Endpoints.Triangle = function(params) {
		this.type = "Triangle";
		params = params || {  };
		params.width = params.width || 55;
		params.height = params.height || 55;
		this.width = params.width;
		this.height = params.height;
		this.compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
			var width = endpointStyle.width || self.width,
			height = endpointStyle.height || self.height,
			x = anchorPoint[0] - (width/2),
			y = anchorPoint[1] - (height/2);
			return [ x, y, width, height ];
		};
	};
// ********************************* END OF ENDPOINT TYPES *******************************************************************
	

// ********************************* OVERLAY DEFINITIONS ***********************************************************************    

	var AbstractOverlay = function(params) {
		var visible = true, self = this;
        this.isAppendedAtTopLevel = true;
		this.component = params.component;
		this.loc = params.location == null ? 0.5 : params.location;
        this.endpointLoc = params.endpointLocation == null ? [ 0.5, 0.5] : params.endpointLocation;
		this.setVisible = function(val) { 
			visible = val;
			self.component.repaint();
		};
    	this.isVisible = function() { return visible; };
    	this.hide = function() { self.setVisible(false); };
    	this.show = function() { self.setVisible(true); };
    	
    	this.incrementLocation = function(amount) {
    		self.loc += amount;
    		self.component.repaint();
    	};
    	this.setLocation = function(l) {
    		self.loc = l;
    		self.component.repaint();
    	};
    	this.getLocation = function() {
    		return self.loc;
    	};
	};
	
	
	/**
	 * Class: Overlays.Arrow
	 * 
	 * An arrow overlay, defined by four points: the head, the two sides of the tail, and a 'foldback' point at some distance along the length
	 * of the arrow that lines from each tail point converge into.  The foldback point is defined using a decimal that indicates some fraction
	 * of the length of the arrow and has a default value of 0.623.  A foldback point value of 1 would mean that the arrow had a straight line
	 * across the tail.  
	 */
	/**
	 * Function: Constructor
	 * 
	 * Parameters:
	 * 
	 * 	length - distance in pixels from head to tail baseline. default 20.
	 * 	width - width in pixels of the tail baseline. default 20.
	 * 	fillStyle - style to use when filling the arrow.  defaults to "black".
	 * 	strokeStyle - style to use when stroking the arrow. defaults to null, which means the arrow is not stroked.
	 * 	lineWidth - line width to use when stroking the arrow. defaults to 1, but only used if strokeStyle is not null.
	 * 	foldback - distance (as a decimal from 0 to 1 inclusive) along the length of the arrow marking the point the tail points should fold back to.  defaults to 0.623.
	 * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the arrow should sit on the connector. defaults to 0.5.
	 * 	direction - indicates the direction the arrow points in. valid values are -1 and 1; 1 is default.
	 */
	jsPlumb.Overlays.Arrow = function(params) {
		this.type = "Arrow";
		AbstractOverlay.apply(this, arguments);
        this.isAppendedAtTopLevel = false;
		params = params || {};
		var self = this;
		
    	this.length = params.length || 20;
    	this.width = params.width || 20;
    	this.id = params.id;
    	var direction = (params.direction || 1) < 0 ? -1 : 1,
    	    paintStyle = params.paintStyle || { lineWidth:1 },
    	    // how far along the arrow the lines folding back in come to. default is 62.3%.
    	    foldback = params.foldback || 0.623;

    	    	
    	this.computeMaxSize = function() { return self.width * 1.5; };
    	
    	this.cleanup = function() { };  // nothing to clean up for Arrows
    	
    	this.draw = function(connector, currentConnectionPaintStyle, connectorDimensions) {

            var hxy, mid, txy, tail, cxy;
            if (connector.pointAlongPathFrom) {

                if (self.loc == 1) {
                    hxy = connector.pointOnPath(self.loc);
                    mid = connector.pointAlongPathFrom(self.loc, -1);
                    txy = jsPlumb.util.pointOnLine(hxy, mid, self.length);
                }
                else if (self.loc == 0) {
                    txy = connector.pointOnPath(self.loc);
                    mid = connector.pointAlongPathFrom(self.loc, 1);
                    hxy = jsPlumb.util.pointOnLine(txy, mid, self.length);
                }
                else {
    			    hxy = connector.pointAlongPathFrom(self.loc, direction * self.length / 2),
                    mid = connector.pointOnPath(self.loc),
                    txy = jsPlumb.util.pointOnLine(hxy, mid, self.length);
                }

                tail = jsPlumb.util.perpendicularLineTo(hxy, txy, self.width);
                cxy = jsPlumb.util.pointOnLine(hxy, txy, foldback * self.length);

    			var minx = Math.min(hxy.x, tail[0].x, tail[1].x),
    				maxx = Math.max(hxy.x, tail[0].x, tail[1].x),
    				miny = Math.min(hxy.y, tail[0].y, tail[1].y),
    				maxy = Math.max(hxy.y, tail[0].y, tail[1].y);
    			
    			var d = { hxy:hxy, tail:tail, cxy:cxy },
    			    strokeStyle = paintStyle.strokeStyle || currentConnectionPaintStyle.strokeStyle,
    			    fillStyle = paintStyle.fillStyle || currentConnectionPaintStyle.strokeStyle,
    			    lineWidth = paintStyle.lineWidth || currentConnectionPaintStyle.lineWidth;
    			
    			self.paint(connector, d, lineWidth, strokeStyle, fillStyle, connectorDimensions);							
			
			    return [ minx, maxx, miny, maxy]; 
            }
            else return [0,0,0,0];
    	};
    };          
    
    /**
     * Class: Overlays.PlainArrow
	 * 
	 * A basic arrow.  This is in fact just one instance of the more generic case in which the tail folds back on itself to some
	 * point along the length of the arrow: in this case, that foldback point is the full length of the arrow.  so it just does
	 * a 'call' to Arrow with foldback set appropriately.       
	 */
    /**
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    jsPlumb.Overlays.PlainArrow = function(params) {
    	params = params || {};    	
    	var p = jsPlumb.extend(params, {foldback:1});
    	jsPlumb.Overlays.Arrow.call(this, p);
    	this.type = "PlainArrow";
    };
        
    /**
     * Class: Overlays.Diamond
     * 
	 * A diamond. Like PlainArrow, this is a concrete case of the more generic case of the tail points converging on some point...it just
	 * happens that in this case, that point is greater than the length of the the arrow.    
	 * 
	 *      this could probably do with some help with positioning...due to the way it reuses the Arrow paint code, what Arrow thinks is the
	 *      center is actually 1/4 of the way along for this guy.  but we don't have any knowledge of pixels at this point, so we're kind of
	 *      stuck when it comes to helping out the Arrow class. possibly we could pass in a 'transpose' parameter or something. the value
	 *      would be -l/4 in this case - move along one quarter of the total length.
	 */
    /**
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    jsPlumb.Overlays.Diamond = function(params) {
    	params = params || {};    	
    	var l = params.length || 40,
    	    p = jsPlumb.extend(params, {length:l/2, foldback:2});
    	jsPlumb.Overlays.Arrow.call(this, p);
    	this.type = "Diamond";
    };
    
    
    
    /**
     * Class: Overlays.Label
     * A Label overlay. For all different renderer types (SVG/Canvas/VML), jsPlumb draws a Label overlay as a styled DIV.  Version 1.3.0 of jsPlumb
     * introduced the ability to set css classes on the label; this is now the preferred way for you to style a label.  The 'labelStyle' parameter
     * is still supported in 1.3.0 but its usage is deprecated.  Under the hood, jsPlumb just turns that object into a bunch of CSS directive that it 
     * puts on the Label's 'style' attribute, so the end result is the same. 
     */
    /**
     * Function: Constructor
     * 
     * Parameters:
     * 	cssClass - optional css class string to append to css class. This string is appended "as-is", so you can of course have multiple classes
     *             defined.  This parameter is preferred to using labelStyle, borderWidth and borderStyle.
     * 	label - the label to paint.  May be a string or a function that returns a string.  Nothing will be painted if your label is null or your
     *         label function returns null.  empty strings _will_ be painted.
     * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.
     * 	
     */
    jsPlumb.Overlays.Label = function(params) {
    	this.type = "Label";
    	jsPlumb.DOMElementComponent.apply(this, arguments);
    	AbstractOverlay.apply(this, arguments);
    	this.labelStyle = params.labelStyle || jsPlumb.Defaults.LabelStyle;
        this.id = params.id;
        this.cachedDimensions = null;             // setting on 'this' rather than using closures uses a lot less memory.  just don't monkey with it!
	    var label = params.label || "",
            self = this,
    	    initialised = false,
    	    div = document.createElement("div"),
            labelText = null;
    	div.style["position"] 	= 	"absolute";    	
    	
    	var clazz = params["_jsPlumb"].overlayClass + " " + 
    		(self.labelStyle.cssClass ? self.labelStyle.cssClass : 
    		params.cssClass ? params.cssClass : "");
    	
    	div.className =	clazz;
    	
    	jsPlumb.appendElement(div, params.component.parent);
    	jsPlumb.getId(div);		
    	self.attachListeners(div, self);
    	self.canvas = div;
    	
    	//override setVisible
    	var osv = self.setVisible;
    	self.setVisible = function(state) {
    		osv(state); // call superclass
    		div.style.display = state ? "block" : "none";
    	};
    	
    	this.getElement = function() {
    		return div;
    	};
    	
    	this.cleanup = function() {
    		if (div != null) jsPlumb.CurrentLibrary.removeElement(div);
    	};
    	
    	/*
    	 * Function: setLabel
    	 * sets the label's, um, label.  you would think i'd call this function
    	 * 'setText', but you can pass either a Function or a String to this, so
    	 * it makes more sense as 'setLabel'.
    	 */
    	this.setLabel = function(l) {
    		label = l;
    		labelText = null;
    		self.component.repaint();
    	};
    	
    	this.getLabel = function() {
    		return label;
    	};
    	
    	this.paint = function(component, d, componentDimensions) {
			if (!initialised) {	
				component.appendDisplayElement(div);
				self.attachListeners(div, component);
				initialised = true;
			}
			div.style.left = (componentDimensions[0] + d.minx) + "px";
			div.style.top = (componentDimensions[1] + d.miny) + "px";			
    	};
    	
    	this.getTextDimensions = function() {
    		if (typeof label == "function") {
    			var lt = label(self);
    			div.innerHTML = lt.replace(/\r\n/g, "<br/>");
    		}
    		else {
    			if (labelText == null) {
    				labelText = label;
    				div.innerHTML = labelText.replace(/\r\n/g, "<br/>");
    			}
    		}
    		var de = jsPlumb.CurrentLibrary.getElementObject(div),
    		s = jsPlumb.CurrentLibrary.getSize(de);
    		return {width:s[0], height:s[1]};
    	};
    	
    	this.computeMaxSize = function(connector) {
    		var td = self.getTextDimensions(connector);
    		return td.width ? Math.max(td.width, td.height) * 1.5 : 0;
    	};    	
    	
	    this.draw = function(component, currentConnectionPaintStyle, componentDimensions) {
	    	var td = self.getTextDimensions(component);
	    	if (td.width !=  null) {
				var cxy = {x:0,y:0};
                if (component.pointOnPath)
                    cxy = component.pointOnPath(self.loc);  // a connection
                else {
                    var locToUse = self.loc.constructor == Array ? self.loc : self.endpointLoc;
                    cxy = { x:locToUse[0] * componentDimensions[2],
                            y:locToUse[1] * componentDimensions[3] };      
                } 
                           
				minx = cxy.x - (td.width / 2),
				miny = cxy.y - (td.height / 2);
				
				self.paint(component, {
					minx:minx,
					miny:miny,
					td:td,
					cxy:cxy
				}, componentDimensions);
				
				return [minx, minx+td.width, miny, miny+td.height];
        	}
	    	else return [0,0,0,0];
	    };
	    
	    this.reattachListeners = function(connector) {
	    	if (div) {
	    		self.reattachListenersForElement(div, self, connector);
	    	}
	    };
    };

    // this is really just a test overlay, so its undocumented and doesnt take any parameters. but i was loth to delete it.
    jsPlumb.Overlays.GuideLines = function() {
        var self = this;
        self.length = 50;
        self.lineWidth = 5;
        this.type = "GuideLines";
		AbstractOverlay.apply(this, arguments);
        jsPlumb.jsPlumbUIComponent.apply(this, arguments);
        this.draw = function(connector, currentConnectionPaintStyle, connectorDimensions) {

            var head = connector.pointAlongPathFrom(self.loc, self.length / 2),
                mid = connector.pointOnPath(self.loc),
                tail = jsPlumb.util.pointOnLine(head, mid, self.length),
                tailLine = jsPlumb.util.perpendicularLineTo(head, tail, 40),
                headLine = jsPlumb.util.perpendicularLineTo(tail, head, 20);

            self.paint(connector, [head, tail, tailLine, headLine], self.lineWidth, "red", null, connectorDimensions);

            return [Math.min(head.x, tail.x), Math.min(head.y, tail.y), Math.max(head.x, tail.x), Math.max(head.y,tail.y)];
        };

        this.computeMaxSize = function() { return 50; };

    	this.cleanup = function() { };  // nothing to clean up for GuideLines
    };

 // ********************************* END OF OVERLAY DEFINITIONS ***********************************************************************
    
 // ********************************* OVERLAY CANVAS RENDERERS***********************************************************************
    
 // ********************************* END OF OVERLAY CANVAS RENDERERS ***********************************************************************
})();/*
 * jsPlumb
 *
 * Title:jsPlumb 1.3.5
 *
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.
 *
 * This file contains the state machine connectors.
 *
 * Thanks to Brainstorm Mobile Solutions for supporting the development of these.
 *
 * Copyright (c) 2010 - 2012 Simon Porritt (simon.porritt@gmail.com)
 *
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */

;(function() {

	var Line = function(x1, y1, x2, y2) {

		this.m = (y2 - y1) / (x2 - x1);
		this.b = -1 * ((this.m * x1) - y1);
	
		this.rectIntersect = function(x,y,w,h) {
			var results = [];
		
			// 	try top face
			// 	the equation of the top face is y = (0 * x) + b; y = b.
			var xInt = (y - this.b) / this.m;
			// test that the X value is in the line's range.
			if (xInt >= x && xInt <= (x + w)) results.push([ xInt, (this.m * xInt) + this.b ]);
		
			// try right face
			var yInt = (this.m * (x + w)) + this.b;
			if (yInt >= y && yInt <= (y + h)) results.push([ (yInt - this.b) / this.m, yInt ]);
		
			// 	bottom face
			var xInt = ((y + h) - this.b) / this.m;
			// test that the X value is in the line's range.
			if (xInt >= x && xInt <= (x + w)) results.push([ xInt, (this.m * xInt) + this.b ]);
		
			// try left face
			var yInt = (this.m * x) + this.b;
			if (yInt >= y && yInt <= (y + h)) results.push([ (yInt - this.b) / this.m, yInt ]);

			if (results.length == 2) {
				var midx = (results[0][0] + results[1][0]) / 2, midy = (results[0][1] + results[1][1]) / 2;
				results.push([ midx,midy ]);
				// now calculate the segment inside the rectangle where the midpoint lies.
				var xseg = midx <= x + (w / 2) ? -1 : 1,
					yseg = midy <= y + (h / 2) ? -1 : 1;
				results.push([xseg, yseg]);
				return results;
			}
		
			return null;

		};
	},
	_segment = function(x1, y1, x2, y2) {
		if (x1 <= x2 && y2 <= y1) return 1;
		else if (x1 <= x2 && y1 <= y2) return 2;
		else if (x2 <= x1 && y2 >= y1) return 3;
		return 4;
	},
		
		// the control point we will use depends on the faces to which each end of the connection is assigned, specifically whether or not the
		// two faces are parallel or perpendicular.  if they are parallel then the control point lies on the midpoint of the axis in which they
		// are parellel and varies only in the other axis; this variation is proportional to the distance that the anchor points lie from the
		// center of that face.  if the two faces are perpendicular then the control point is at some distance from both the midpoints; the amount and
		// direction are dependent on the orientation of the two elements. 'seg', passed in to this method, tells you which segment the target element
		// lies in with respect to the source: 1 is top right, 2 is bottom right, 3 is bottom left, 4 is top left.
		//
		// sourcePos and targetPos are arrays of info about where on the source and target each anchor is located.  their contents are:
		//
		// 0 - absolute x
		// 1 - absolute y
		// 2 - proportional x in element (0 is left edge, 1 is right edge)
		// 3 - proportional y in element (0 is top edge, 1 is bottom edge)
		// 	
	_findControlPoint = function(midx, midy, segment, sourceEdge, targetEdge, dx, dy, distance, proximityLimit) {

        // TODO (maybe)
        // - if anchor pos is 0.5, make the control point take into account the relative position of the elements.
        if (distance <= proximityLimit) return [midx, midy];

        if (segment == 1) {
            if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
            else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
            else return [ midx + (-1 * dx) , midy + (-1 * dy) ];
        }
        else if (segment == 2) {
            if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
            else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
            else return [ midx + (1 * dx) , midy + (-1 * dy) ];
        }
        else if (segment == 3) {
            if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
            else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
            else return [ midx + (-1 * dx) , midy + (-1 * dy) ];
        }
        else if (segment == 4) {
            if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
            else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
            else return [ midx + (1 * dx) , midy + (-1 * dy) ];
        }
	};

	/*
		Function: StateMachine constructor
		
		Allowed parameters:
			curviness 		-	measure of how "curvy" the connectors will be.  this is translated as the distance that the
								Bezier curve's control point is from the midpoint of the straight line connecting the two
								endpoints, and does not mean that the connector is this wide.  The Bezier curve never reaches
								its control points; they act as gravitational masses. defaults to 10.
			margin			-	distance from element to start and end connectors, in pixels.  defaults to 5.
			proximityLimit  -   sets the distance beneath which the elements are consider too close together to bother with fancy
			                    curves. by default this is 80 pixels.
			loopbackRadius	-	the radius of a loopback connector.  optional; defaults to 25.
	*/
	jsPlumb.Connectors.StateMachine = function(params) {
		var self = this,
		currentPoints = null,
		_sx, _sy, _tx, _ty, _controlPoint = [],
		curviness = params.curviness || 10,
		margin = params.margin || 5,
		proximityLimit = params.proximityLimit || 80,
		clockwise = params.orientation && params.orientation == "clockwise",
		loopbackRadius = params.loopbackRadius || 25,
		isLoopback = false;

		this.type = "StateMachine";
		params = params || {};		
		
		this.compute = function(sourcePos, targetPos, sourceEndpoint, targetEndpoint, sourceAnchor, targetAnchor, lineWidth, minWidth) {

			var w = Math.abs(sourcePos[0] - targetPos[0]),
   	 	       	h = Math.abs(sourcePos[1] - targetPos[1]),
	   	     	// these are padding to ensure the whole connector line appears
   	   	   		xo = 0.45 * w, yo = 0.45 * h;
   		   		// these are padding to ensure the whole connector line appears
            	w *= 1.9; h *= 1.9;
                //ensure at least one pixel width
                lineWidth = lineWidth || 1;
            	var x = Math.min(sourcePos[0], targetPos[0]) - xo,
        		    y = Math.min(sourcePos[1], targetPos[1]) - yo;
		
			if (sourceEndpoint.elementId != targetEndpoint.elementId) {
                            
                isLoopback = false;
                            
        		_sx = sourcePos[0] < targetPos[0] ?  xo : w-xo;
            	_sy = sourcePos[1] < targetPos[1] ? yo:h-yo;
            	_tx = sourcePos[0] < targetPos[0] ? w-xo : xo;
            	_ty = sourcePos[1] < targetPos[1] ? h-yo : yo;
            
            	// now adjust for the margin
            	if (sourcePos[2] == 0) _sx -= margin;
            	if (sourcePos[2] == 1) _sx += margin;
            	if (sourcePos[3] == 0) _sy -= margin;
            	if (sourcePos[3] == 1) _sy += margin;
            	if (targetPos[2] == 0) _tx -= margin;
            	if (targetPos[2] == 1) _tx += margin;
            	if (targetPos[3] == 0) _ty -= margin;
            	if (targetPos[3] == 1) _ty += margin;

            	//
	            // these connectors are quadratic bezier curves, having a single control point. if both anchors 
    	        // are located at 0.5 on their respective faces, the control point is set to the midpoint and you
        	    // get a straight line.  this is also the case if the two anchors are within 'proximityLimit', since
           	 	// it seems to make good aesthetic sense to do that. outside of that, the control point is positioned 
           	 	// at 'curviness' pixels away along the normal to the straight line connecting the two anchors.
	            // 
   	        	// there may be two improvements to this.  firstly, we might actually support the notion of avoiding nodes
            	// in the UI, or at least making a good effort at doing so.  if a connection would pass underneath some node,
            	// for example, we might increase the distance the control point is away from the midpoint in a bid to
            	// steer it around that node.  this will work within limits, but i think those limits would also be the likely
            	// limits for, once again, aesthetic good sense in the layout of a chart using these connectors.
            	//
            	// the second possible change is actually two possible changes: firstly, it is possible we should gradually
            	// decrease the 'curviness' as the distance between the anchors decreases; start tailing it off to 0 at some
            	// point (which should be configurable).  secondly, we might slightly increase the 'curviness' for connectors
            	// with respect to how far their anchor is from the center of its respective face. this could either look cool,
            	// or stupid, and may indeed work only in a way that is so subtle as to have been a waste of time.
            	//

				var _midx = (_sx + _tx) / 2, _midy = (_sy + _ty) / 2, 
            	    m2 = (-1 * _midx) / _midy, theta2 = Math.atan(m2),
            	    dy =  (m2 == Infinity || m2 == -Infinity) ? 0 : Math.abs(curviness / 2 * Math.sin(theta2)),
				    dx =  (m2 == Infinity || m2 == -Infinity) ? 0 : Math.abs(curviness / 2 * Math.cos(theta2)),
				    segment = _segment(_sx, _sy, _tx, _ty),
				    distance = Math.sqrt(Math.pow(_tx - _sx, 2) + Math.pow(_ty - _sy, 2));
			
            	// calculate the control point.  this code will be where we'll put in a rudimentary element avoidance scheme; it
            	// will work by extending the control point to force the curve to be, um, curvier.
				_controlPoint = _findControlPoint(_midx,
                                                  _midy,
                                                  segment,
                                                  sourcePos,
                                                  targetPos,
                                                  curviness, curviness,
                                                  distance,
                                                  proximityLimit);

	            	
            	var requiredWidth = Math.max(Math.abs(_controlPoint[0] - _sx) * 3, Math.abs(_controlPoint[0] - _tx) * 3, Math.abs(_tx-_sx), 2 * lineWidth, minWidth),
            		requiredHeight = Math.max(Math.abs(_controlPoint[1] - _sy) * 3, Math.abs(_controlPoint[1] - _ty) * 3, Math.abs(_ty-_sy), 2 * lineWidth, minWidth);

            	if (w < requiredWidth) {      	
            		var dw = requiredWidth - w;            		
            		x -= (dw / 2);
            		_sx += (dw / 2);
            		_tx  += (dw / 2);
            		w = requiredWidth;
                    _controlPoint[0] += (dw / 2);
            	}
            	
            	if (h < requiredHeight) {
            		var dh = requiredHeight - h;
            		y -= (dh / 2);
            		_sy += (dh / 2);
            		_ty += (dh / 2);
            		h = requiredHeight;
                    _controlPoint[1] += (dh / 2);
            	}
            	currentPoints = [ x, y, w, h, _sx, _sy, _tx, _ty, _controlPoint[0], _controlPoint[1] ];                                        
            }
            else {
            	isLoopback = true;
            	// a loopback connector.  draw an arc from one anchor to the other.
            	// i guess we'll do this the same way as the others.  just the control point will be a fair distance away.
        		var x1 = sourcePos[0], x2 = sourcePos[0], y1 = sourcePos[1] - margin, y2 = sourcePos[1] - margin, 				
					cx = x1, cy = y1 - loopbackRadius;
				
				// canvas sizing stuff, to ensure the whole painted area is visible.
				w = ((2 * lineWidth) + (4 * loopbackRadius)), h = ((2 * lineWidth) + (4 * loopbackRadius));
				x = cx - loopbackRadius - lineWidth - loopbackRadius, y = cy - loopbackRadius - lineWidth - loopbackRadius;
				currentPoints = [ x, y, w, h, cx-x, cy-y, loopbackRadius, clockwise, x1-x, y1-y, x2-x, y2-y];
            }
                
            return currentPoints;
        };
        
        var _makeCurve = function() {
        	return [	
	        	{ x:_tx, y:_ty },
	        	{ x:_controlPoint[0], y:_controlPoint[1] },
	        	{ x:_controlPoint[0] + 1, y:_controlPoint[1] + 1},	        	
	        	{ x:_sx, y:_sy }
         	];
        };     
        
        /**
         * returns the point on the connector's path that is 'location' along the length of the path, where 'location' is a decimal from
         * 0 to 1 inclusive. for the straight line connector this is simple maths.  for Bezier, not so much.
         */
        this.pointOnPath = function(location) {   
			if (isLoopback) {

                if (location > 0 && location < 1) location = 1- location;
                
// current points are [ x, y, width, height, center x, center y, radius, clockwise, startx, starty, endx, endy ]				
				// so the path length is the circumference of the circle
				//var len = 2 * Math.PI * currentPoints[6],
				// map 'location' to an angle. 0 is PI/2 when the connector is on the top face; if we
				// support other faces it will have to be calculated for each one. 1 is also PI/2.
				// 0.5 is -PI/2.
				var startAngle = (location * 2 * Math.PI) + (Math.PI / 2),
					startX = currentPoints[4] + (currentPoints[6] * Math.cos(startAngle)),
					startY = currentPoints[5] + (currentPoints[6] * Math.sin(startAngle));					

                return {x:startX, y:startY};
					
			}
        	else return jsBezier.pointOnCurve(_makeCurve(), location);
        };
        
        /**
         * returns the gradient of the connector at the given point.
         */
        this.gradientAtPoint = function(location) {
			if (isLoopback)
				return Math.atan(location * 2 * Math.PI);
        	else
                return jsBezier.gradientAtPoint(_makeCurve(), location);
        };	        
        
        /**
         * for Bezier curves this method is a little tricky, cos calculating path distance algebraically is notoriously difficult.
         * this method is iterative, jumping forward .05% of the path at a time and summing the distance between this point and the previous
         * one, until the sum reaches 'distance'. the method may turn out to be computationally expensive; we'll see.
         * another drawback of this method is that if the connector gets quite long, .05% of the length of it is not necessarily smaller
         * than the desired distance, in which case the loop returns immediately and the arrow is mis-shapen. so a better strategy might be to
         * calculate the step as a function of distance/distance between endpoints.  
         */
        this.pointAlongPathFrom = function(location, distance) {        	
			if (isLoopback) {

                if (location > 0 && location < 1) location = 1- location;

				var circumference = 2 * Math.PI * currentPoints[6],
					arcSpan = distance / circumference * 2 * Math.PI,
					startAngle = (location * 2 * Math.PI) - arcSpan + (Math.PI / 2),	
					
					startX = currentPoints[4] + (currentPoints[6] * Math.cos(startAngle)),
					startY = currentPoints[5] + (currentPoints[6] * Math.sin(startAngle));	

				return {x:startX, y:startY};
			}
        	return jsBezier.pointAlongCurveFrom(_makeCurve(), location, distance);
        };                       
	
	};
	
	/*
     * Canvas state machine renderer. 
     */
    jsPlumb.Connectors.canvas.StateMachine = function(params) {   	 
    	params = params || {};
		var self = this, drawGuideline = params.drawGuideline || true, avoidSelector = params.avoidSelector;
		jsPlumb.Connectors.StateMachine.apply(this, arguments);
		jsPlumb.CanvasConnector.apply(this, arguments);
	
		
		this._paint = function(dimensions) {
			
			if (dimensions.length == 10) {
		        self.ctx.beginPath();
				self.ctx.moveTo(dimensions[4], dimensions[5]);
				self.ctx.quadraticCurveTo(dimensions[8], dimensions[9], dimensions[6], dimensions[7]);
				self.ctx.stroke();            
				
				/*/ draw the guideline
				if (drawGuideline) {
					self.ctx.save();
					self.ctx.beginPath();
					self.ctx.strokeStyle = "silver";
					self.ctx.lineWidth = 1;
					self.ctx.moveTo(dimensions[4], dimensions[5]);
					self.ctx.lineTo(dimensions[6], dimensions[7]);
					self.ctx.stroke();            
					self.ctx.restore();
				}
				//*/
			}
			else {
				// a loopback connector
				self.ctx.save();
				self.ctx.beginPath();        	
	        	var startAngle = 0,                     // Starting point on circle
	        	endAngle   = 2 * Math.PI, // End point on circle
	        	clockwise  = dimensions[7]; // clockwise or anticlockwise 
	        	self.ctx.arc(dimensions[4],dimensions[5],dimensions[6],0, endAngle, clockwise);
				self.ctx.stroke();
				self.ctx.closePath();
				self.ctx.restore();
			}
	    };	    
	    
	    this.createGradient = function(dim, ctx) {
        	return ctx.createLinearGradient(dim[4], dim[5], dim[6], dim[7]);
        };
    };
    
    /*
     * SVG State Machine renderer
     */
    jsPlumb.Connectors.svg.StateMachine = function() {   	 
		var self = this;
		jsPlumb.Connectors.StateMachine.apply(this, arguments);
		jsPlumb.SvgConnector.apply(this, arguments);
		this.getPath = function(d) { 	
				
			if (d.length == 10) 
				return "M " + d[4] + " " + d[5] + " C " + d[8] + " " + d[9] + " " + d[8] + " " + d[9] + " " + d[6] + " " + d[7]; 
			else {
				// loopback
				return "M" + (d[8] + 4) + " " + d[9] + " A " + d[6] + " " + d[6] + " 0 1,0 " + (d[8]-4) + " " + d[9];			
			}
		};	    	    
    };
    
    /*
     * VML state machine renderer
     */
    jsPlumb.Connectors.vml.StateMachine = function() {
		jsPlumb.Connectors.StateMachine.apply(this, arguments);	
		jsPlumb.VmlConnector.apply(this, arguments);
		var _conv = jsPlumb.vml.convertValue;
		this.getPath = function(d) {	
			if (d.length == 10) {
				return "m" + _conv(d[4]) + "," + _conv(d[5]) + 
					   " c" + _conv(d[8]) + "," + _conv(d[9]) + "," + _conv(d[8]) + "," + _conv(d[9]) + "," + _conv(d[6]) + "," + _conv(d[7]) + " e";
			}
			else {
				// loopback
				var left = _conv(d[8] - d[6]),
					top = _conv(d[9] - (2 * d[6])),
					right = left + _conv(2 * d[6]),
					bottom = top + _conv(2 * d[6]),
					posString = left + "," + top + "," + right + "," + bottom;
					
				var o = "ar " + posString + "," + _conv(d[8]) + ","
						+ _conv(d[9]) + "," + _conv(d[8]) + "," + _conv(d[9]) + " e";
				
				 return o;
			}
		};
	};

})();

/*
    	// now for a rudimentary avoidance scheme. TODO: how to set this in a cross-library way?
        //      if (avoidSelector) {
		//		    var testLine = new Line(sourcePos[0] + _sx,sourcePos[1] + _sy,sourcePos[0] + _tx,sourcePos[1] + _ty);
		//		    var sel = jsPlumb.getSelector(avoidSelector);
		//		    for (var i = 0; i < sel.length; i++) {
		//			    var id = jsPlumb.getId(sel[i]);
		//			    if (id != sourceEndpoint.elementId && id != targetEndpoint.elementId) {
		//				    o = jsPlumb.getOffset(id), s = jsPlumb.getSize(id);
//
//						    if (o && s) {
//							    var collision = testLine.rectIntersect(o.left,o.top,s[0],s[1]);
//							    if (collision) {
								    // set the control point to be a certain distance from the midpoint of the two points that
								    // the line crosses on the rectangle.
								    // TODO where will this 75 number come from?
					//			    _controlX = collision[2][0] + (75 * collision[3][0]);
				//	/			    _controlY = collision[2][1] + (75 * collision[3][1]);
//							    }
//						    }
					//  }
	//			    }
              //}
    *//*
 * jsPlumb
 * 
 * Title:jsPlumb 1.3.5
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the VML renderers.
 *
 * Copyright (c) 2010 - 2012 Simon Porritt (http://jsplumb.org)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */

;(function() {
	
	// http://ajaxian.com/archives/the-vml-changes-in-ie-8
	// http://www.nczonline.net/blog/2010/01/19/internet-explorer-8-document-and-browser-modes/
	// http://www.louisremi.com/2009/03/30/changes-in-vml-for-ie8-or-what-feature-can-the-ie-dev-team-break-for-you-today/
	
	var vmlAttributeMap = {
		"stroke-linejoin":"joinstyle",
		"joinstyle":"joinstyle",		
		"endcap":"endcap",
		"miterlimit":"miterlimit"
	};
	
	if (document.createStyleSheet) {			
		
		// this is the style rule for IE7/6: it uses a CSS class, tidy.
		document.createStyleSheet().addRule(".jsplumb_vml", "behavior:url(#default#VML);position:absolute;");
		
		// these are for VML in IE8.  you have to explicitly call out which elements
		// you're going to expect to support VML!  
		//
		document.createStyleSheet().addRule("jsplumb\\:textbox", "behavior:url(#default#VML);position:absolute;");
		document.createStyleSheet().addRule("jsplumb\\:oval", "behavior:url(#default#VML);position:absolute;");
		document.createStyleSheet().addRule("jsplumb\\:rect", "behavior:url(#default#VML);position:absolute;");
		document.createStyleSheet().addRule("jsplumb\\:stroke", "behavior:url(#default#VML);position:absolute;");
		document.createStyleSheet().addRule("jsplumb\\:shape", "behavior:url(#default#VML);position:absolute;");
        document.createStyleSheet().addRule("jsplumb\\:group", "behavior:url(#default#VML);position:absolute;");
		
		// in this page it is also mentioned that IE requires the extra arg to the namespace
		// http://www.louisremi.com/2009/03/30/changes-in-vml-for-ie8-or-what-feature-can-the-ie-dev-team-break-for-you-today/
		// but someone commented saying they didn't need it, and it seems jsPlumb doesnt need it either.
		// var iev = document.documentMode;
		//if (!iev || iev < 8)
			document.namespaces.add("jsplumb", "urn:schemas-microsoft-com:vml");
		//else
		//	document.namespaces.add("jsplumb", "urn:schemas-microsoft-com:vml", "#default#VML");
	}
	
	jsPlumb.vml = {};
	
	var scale = 1000,

    _groupMap = {},
    _getGroup = function(container, connectorClass) {
        var id = jsPlumb.getId(container),
            g = _groupMap[id];
        if(!g) {
            g = _node("group", [0,0,scale, scale], {"class":connectorClass});
            //g.style.position=absolute;
            //g["coordsize"] = "1000,1000";
            g.style.backgroundColor="red";
            _groupMap[id] = g;
            jsPlumb.appendElement(g, container);
            //document.body.appendChild(g);
        }
        return g;
    },
	_atts = function(o, atts) {
		for (var i in atts) { 
			// IE8 fix: setattribute does not work after an element has been added to the dom!
			// http://www.louisremi.com/2009/03/30/changes-in-vml-for-ie8-or-what-feature-can-the-ie-dev-team-break-for-you-today/
			//o.setAttribute(i, atts[i]);
			
			o[i] = atts[i];
		}
	},
	_node = function(name, d, atts) {
		atts = atts || {};
		var o = document.createElement("jsplumb:" + name);
		o.className = (atts["class"] ? atts["class"] + " " : "") + "jsplumb_vml";
		_pos(o, d);
		_atts(o, atts);
		return o;
	},
	_pos = function(o,d) {
		o.style.left = d[0] + "px";		
		o.style.top =  d[1] + "px";
		o.style.width= d[2] + "px";
		o.style.height= d[3] + "px";
		o.style.position = "absolute";
	},
	_conv = jsPlumb.vml.convertValue = function(v) {
		return Math.floor(v * scale);
	},	
	// tests if the given style is "transparent" and then sets the appropriate opacity node to 0 if so,
	// or 1 if not.  TODO in the future, support variable opacity.
	_maybeSetOpacity = function(styleToWrite, styleToCheck, type, component) {
		if ("transparent" === styleToCheck)
			component.setOpacity(type, "0.0");
		else
			component.setOpacity(type, "1.0");
	},
	_applyStyles = function(node, style, component) {
		var styleToWrite = {};
		if (style.strokeStyle) {
			styleToWrite["stroked"] = "true";
			var strokeColor = jsPlumb.util.convertStyle(style.strokeStyle, true);
			styleToWrite["strokecolor"] = strokeColor;
			_maybeSetOpacity(styleToWrite, strokeColor, "stroke", component);
			styleToWrite["strokeweight"] = style.lineWidth + "px";
		}
		else styleToWrite["stroked"] = "false";
		
		if (style.fillStyle) {
			styleToWrite["filled"] = "true";
			var fillColor = jsPlumb.util.convertStyle(style.fillStyle, true);
			styleToWrite["fillcolor"] = fillColor;
			_maybeSetOpacity(styleToWrite, fillColor, "fill", component);
		}
		else styleToWrite["filled"] = "false";
		
		if(style["dashstyle"]) {
			if (component.strokeNode == null) {
				component.strokeNode = _node("stroke", [0,0,0,0], { dashstyle:style["dashstyle"] });
				node.appendChild(component.strokeNode);
			}
			else
				component.strokeNode.dashstyle = style["dashstyle"];
		}					
		else if (style["stroke-dasharray"] && style["lineWidth"]) {
			var sep = style["stroke-dasharray"].indexOf(",") == -1 ? " " : ",",
			parts = style["stroke-dasharray"].split(sep),
			styleToUse = "";
			for(var i = 0; i < parts.length; i++) {
				styleToUse += (Math.floor(parts[i] / style.lineWidth) + sep);
			}
			if (component.strokeNode == null) {
				component.strokeNode = _node("stroke", [0,0,0,0], { dashstyle:styleToUse });
				node.appendChild(component.strokeNode);
			}
			else
				component.strokeNode.dashstyle = styleToUse;
		}
		
		_atts(node, styleToWrite);
	},
	/*
	 * Base class for Vml endpoints and connectors. Extends jsPlumbUIComponent. 
	 */
	VmlComponent = function() {				
		var self = this;
		jsPlumb.jsPlumbUIComponent.apply(this, arguments);		
		this.opacityNodes = {
			"stroke":null,
			"fill":null
		};
		this.initOpacityNodes = function(vml) {
			self.opacityNodes["stroke"] = _node("stroke", [0,0,1,1], {opacity:"0.0"});
			self.opacityNodes["fill"] = _node("fill", [0,0,1,1], {opacity:"0.0"});				
			vml.appendChild(self.opacityNodes["stroke"]);
			vml.appendChild(self.opacityNodes["fill"]);	
		};
		this.setOpacity = function(type, value) {
			var node = self.opacityNodes[type];
			if (node) node["opacity"] = "" + value;
		};
		var displayElements = [ ];
		this.getDisplayElements = function() { 
			return displayElements; 
		};
		
		this.appendDisplayElement = function(el, doNotAppendToCanvas) {
			if (!doNotAppendToCanvas) self.canvas.parentNode.appendChild(el);
			displayElements.push(el);
		};
	},	
	/*
	 * Base class for Vml connectors. extends VmlComponent.
	 */
	VmlConnector = jsPlumb.VmlConnector = function(params) {
		var self = this;
		self.strokeNode = null;
		self.canvas = null;
		VmlComponent.apply(this, arguments);
		var clazz = self._jsPlumb.connectorClass + (params.cssClass ? (" " + params.cssClass) : "");
		this.paint = function(d, style, anchor) {
			if (style != null) {				
				var path = self.getPath(d), p = { "path":path };				

                //*
				if (style.outlineColor) {
					var outlineWidth = style.outlineWidth || 1,
					outlineStrokeWidth = style.lineWidth + (2 * outlineWidth),
					outlineStyle = {
						strokeStyle : jsPlumb.util.convertStyle(style.outlineColor),
						lineWidth : outlineStrokeWidth
					};
					for (var aa in vmlAttributeMap) outlineStyle[aa] = style[aa];
					
					if (self.bgCanvas == null) {						
						p["class"] = clazz;
						p["coordsize"] = (d[2] * scale) + "," + (d[3] * scale);
						self.bgCanvas = _node("shape", d, p);
						jsPlumb.appendElement(self.bgCanvas, params.parent);
						_pos(self.bgCanvas, d);
						self.appendDisplayElement(self.bgCanvas, true);	
					}
					else {
						p["coordsize"] = (d[2] * scale) + "," + (d[3] * scale);
						_pos(self.bgCanvas, d);
						_atts(self.bgCanvas, p);
					}
					
					_applyStyles(self.bgCanvas, outlineStyle, self);
				}
				//*/
				
				if (self.canvas == null) {										
					p["class"] = clazz;
					p["coordsize"] = (d[2] * scale) + "," + (d[3] * scale);
					if (self.tooltip) p["label"] = self.tooltip;
					self.canvas = _node("shape", d, p);
                    
                    //var group = _getGroup(params.parent);                   // test of append everything to a group
                    //group.appendChild(self.canvas);                           // sort of works but not exactly;
					jsPlumb.appendElement(self.canvas, params.parent);    //before introduction of groups

					self.appendDisplayElement(self.canvas, true);					
					
					self.attachListeners(self.canvas, self);
					
					self.initOpacityNodes(self.canvas, ["stroke"]);		
				}
				else {
					p["coordsize"] = (d[2] * scale) + "," + (d[3] * scale);
					_pos(self.canvas, d);
					_atts(self.canvas, p);
				}
				
				_applyStyles(self.canvas, style, self);
			}
		};
		
		//self.appendDisplayElement(self.canvas);
		
		this.reattachListeners = function() {
			if (self.canvas) self.reattachListenersForElement(self.canvas, self);
		};
	},		
	/*
	 * 
	 * Base class for Vml Endpoints. extends VmlComponent.
	 * 
	 */
	VmlEndpoint = function(params) {
		VmlComponent.apply(this, arguments);
		var vml = null, self = this, opacityStrokeNode = null, opacityFillNode = null;
		self.canvas = document.createElement("div");
		self.canvas.style["position"] = "absolute";

		//var group = _getGroup(params.parent);
        //group.appendChild(self.canvas);
		jsPlumb.appendElement(self.canvas, params.parent);

        if (self.tooltip) self.canvas.setAttribute("label", self.tooltip);
		
		this.paint = function(d, style, anchor) {
			var p = { };						
			
			jsPlumb.sizeCanvas(self.canvas, d[0], d[1], d[2], d[3]);
			if (vml == null) {
				p["class"] = jsPlumb.endpointClass;
				vml = self.getVml([0,0, d[2], d[3]], p, anchor);				
				self.canvas.appendChild(vml);
				self.attachListeners(vml, self);

				self.appendDisplayElement(vml, true);
				self.appendDisplayElement(self.canvas, true);
				
				self.initOpacityNodes(vml, ["fill"]);			
			}
			else {
				//p["coordsize"] = "1,1";//(d[2] * scale) + "," + (d[3] * scale); again, unsure.
				_pos(vml, [0,0, d[2], d[3]]);
				_atts(vml, p);
			}
			
			_applyStyles(vml, style, self);
		};
		
		this.reattachListeners = function() {
			if (vml) self.reattachListenersForElement(vml, self);
		};
	};
	
	jsPlumb.Connectors.vml.Bezier = function() {
		jsPlumb.Connectors.Bezier.apply(this, arguments);	
		VmlConnector.apply(this, arguments);
		this.getPath = function(d) {			
			return "m" + _conv(d[4]) + "," + _conv(d[5]) + 
				   " c" + _conv(d[8]) + "," + _conv(d[9]) + "," + _conv(d[10]) + "," + _conv(d[11]) + "," + _conv(d[6]) + "," + _conv(d[7]) + " e";
		};
	};
	
	jsPlumb.Connectors.vml.Straight = function() {
		jsPlumb.Connectors.Straight.apply(this, arguments);	
		VmlConnector.apply(this, arguments);
		this.getPath = function(d) {
			return "m" + _conv(d[4]) + "," + _conv(d[5]) + " l" + _conv(d[6]) + "," + _conv(d[7]) + " e";
		};
	};
	
	jsPlumb.Connectors.vml.Flowchart = function() {
    	jsPlumb.Connectors.Flowchart.apply(this, arguments);
		VmlConnector.apply(this, arguments);
    	this.getPath = function(dimensions) {
    		var p = "m " + _conv(dimensions[4]) + "," + _conv(dimensions[5]) + " l";
	        // loop through extra points
	        for (var i = 0; i < dimensions[8]; i++) {
	        	p = p + " " + _conv(dimensions[9 + (i*2)]) + "," + _conv(dimensions[10 + (i*2)]);
	        }
	        // finally draw a line to the end
	        p = p  + " " + _conv(dimensions[6]) + "," +  _conv(dimensions[7]) + " e";
	        return p;
    	};
    };
	
	jsPlumb.Endpoints.vml.Dot = function() {
		jsPlumb.Endpoints.Dot.apply(this, arguments);
		VmlEndpoint.apply(this, arguments);
		this.getVml = function(d, atts, anchor) { return _node("oval", d, atts); };
	};
	
	jsPlumb.Endpoints.vml.Rectangle = function() {
		jsPlumb.Endpoints.Rectangle.apply(this, arguments);
		VmlEndpoint.apply(this, arguments);
		this.getVml = function(d, atts, anchor) { return _node("rect", d, atts); };
	};
	
	/*
	 * VML Image Endpoint is the same as the default image endpoint.
	 */
	jsPlumb.Endpoints.vml.Image = jsPlumb.Endpoints.Image;
	
	/**
	 * placeholder for Blank endpoint in vml renderer.
	 */
	jsPlumb.Endpoints.vml.Blank = jsPlumb.Endpoints.Blank;
	
	/**
	 * VML Label renderer. uses the default label renderer (which adds an element to the DOM)
	 */
	jsPlumb.Overlays.vml.Label  = jsPlumb.Overlays.Label;
	
	var AbstractVmlArrowOverlay = function(superclass, originalArgs) {
    	superclass.apply(this, originalArgs);
    	VmlComponent.apply(this, arguments);
    	var self = this, path = null;
    	self.canvas = null; 
    	var getPath = function(d, connectorDimensions) {    		
    		return "m " + _conv(d.hxy.x) + "," + _conv(d.hxy.y) +
    		       " l " + _conv(d.tail[0].x) + "," + _conv(d.tail[0].y) + 
    		       " " + _conv(d.cxy.x) + "," + _conv(d.cxy.y) + 
    		       " " + _conv(d.tail[1].x) + "," + _conv(d.tail[1].y) + 
    		       " x e";
    	};
    	this.paint = function(connector, d, lineWidth, strokeStyle, fillStyle, connectorDimensions) {
    		var p = {};
			if (strokeStyle) {
				p["stroked"] = "true";
				p["strokecolor"] = jsPlumb.util.convertStyle(strokeStyle, true);    				
			}
			if (lineWidth) p["strokeweight"] = lineWidth + "px";
			if (fillStyle) {
				p["filled"] = "true";
				p["fillcolor"] = fillStyle;
			}
			var xmin = Math.min(d.hxy.x, d.tail[0].x, d.tail[1].x, d.cxy.x),
			ymin = Math.min(d.hxy.y, d.tail[0].y, d.tail[1].y, d.cxy.y),
			xmax = Math.max(d.hxy.x, d.tail[0].x, d.tail[1].x, d.cxy.x),
			ymax = Math.max(d.hxy.y, d.tail[0].y, d.tail[1].y, d.cxy.y),
			w = Math.abs(xmax - xmin),
			h = Math.abs(ymax - ymin),
			dim = [xmin, ymin, w, h];
			
			// for VML, we create overlays using shapes that have the same dimensions and
			// coordsize as their connector - overlays calculate themselves relative to the
			// connector (it's how it's been done since the original canvas implementation, because
			// for canvas that makes sense).
			p["path"] = getPath(d, connectorDimensions);
			p["coordsize"] = (connectorDimensions[2] * scale) + "," + (connectorDimensions[3] * scale);
			
			dim[0] = connectorDimensions[0];
			dim[1] = connectorDimensions[1];
			dim[2] = connectorDimensions[2];
			dim[3] = connectorDimensions[3];
			
    		if (self.canvas == null) {
    			//p["class"] = jsPlumb.overlayClass; // TODO currentInstance?
				self.canvas = _node("shape", dim, p);				
				connector.appendDisplayElement(self.canvas);
				self.attachListeners(self.canvas, connector);
			}
			else {				
				_pos(self.canvas, dim);
				_atts(self.canvas, p);
			}    		
    	};
    	
    	this.reattachListeners = function() {
			if (self.canvas) self.reattachListenersForElement(self.canvas, self);
		};
    };
	
	jsPlumb.Overlays.vml.Arrow = function() {
    	AbstractVmlArrowOverlay.apply(this, [jsPlumb.Overlays.Arrow, arguments]);    	
    };
    
    jsPlumb.Overlays.vml.PlainArrow = function() {
    	AbstractVmlArrowOverlay.apply(this, [jsPlumb.Overlays.PlainArrow, arguments]);    	
    };
    
    jsPlumb.Overlays.vml.Diamond = function() {
    	AbstractVmlArrowOverlay.apply(this, [jsPlumb.Overlays.Diamond, arguments]);    	
    };
})();/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.3.5
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the SVG renderers.
 *
 * Copyright (c) 2010 - 2012 Simon Porritt (http://jsplumb.org)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */

/**
 * SVG support for jsPlumb.
 * 
 * things to investigate:
 * 
 * gradients:  https://developer.mozilla.org/en/svg_in_html_introduction
 * css:http://tutorials.jenkov.com/svg/svg-and-css.html
 * text on a path: http://www.w3.org/TR/SVG/text.html#TextOnAPath
 * pointer events: https://developer.mozilla.org/en/css/pointer-events
 *
 * IE9 hover jquery: http://forum.jquery.com/topic/1-6-2-broke-svg-hover-events
 *
 */
;(function() {
	
	var svgAttributeMap = {
		"joinstyle":"stroke-linejoin",
		"stroke-linejoin":"stroke-linejoin",		
		"stroke-dashoffset":"stroke-dashoffset",
		"stroke-linecap":"stroke-linecap"
	},
	STROKE_DASHARRAY = "stroke-dasharray",
	DASHSTYLE = "dashstyle",
	LINEAR_GRADIENT = "linearGradient",
	RADIAL_GRADIENT = "radialGradient",
	FILL = "fill",
	STOP = "stop",
	STROKE = "stroke",
	STROKE_WIDTH = "stroke-width",
	STYLE = "style",
	NONE = "none",
	JSPLUMB_GRADIENT = "jsplumb_gradient_",
	LINE_WIDTH = "lineWidth",
	ns = {
		svg:"http://www.w3.org/2000/svg",
		xhtml:"http://www.w3.org/1999/xhtml"
	},
	_attr = function(node, attributes) {
		for (var i in attributes)
			node.setAttribute(i, "" + attributes[i]);
	},	
	_node = function(name, attributes) {
		var n = document.createElementNS(ns.svg, name);
		attributes = attributes || {};
		attributes["version"] = "1.1";
		attributes["xmnls"] = ns.xhtml;
		_attr(n, attributes);
		return n;
	},
	_pos = function(d) { return "position:absolute;left:" + d[0] + "px;top:" + d[1] + "px"; },	
	_clearGradient = function(parent) {
		for (var i = 0; i < parent.childNodes.length; i++) {
			if (parent.childNodes[i].tagName == LINEAR_GRADIENT || parent.childNodes[i].tagName == RADIAL_GRADIENT)
				parent.removeChild(parent.childNodes[i]);
		}
	},		
	_updateGradient = function(parent, node, style, dimensions, uiComponent) {
		var id = JSPLUMB_GRADIENT + uiComponent._jsPlumb.idstamp();
		// first clear out any existing gradient
		_clearGradient(parent);
		// this checks for an 'offset' property in the gradient, and in the absence of it, assumes
		// we want a linear gradient. if it's there, we create a radial gradient.
		// it is possible that a more explicit means of defining the gradient type would be
		// better. relying on 'offset' means that we can never have a radial gradient that uses
		// some default offset, for instance.
		if (!style.gradient.offset) {
			var g = _node(LINEAR_GRADIENT, {id:id});
			parent.appendChild(g);
		}
		else {
			var g = _node(RADIAL_GRADIENT, {
				id:id
			});
			parent.appendChild(g);
		}
		
		// the svg radial gradient seems to treat stops in the reverse 
		// order to how canvas does it.  so we want to keep all the maths the same, but
		// iterate the actual style declarations in reverse order, if the x indexes are not in order.
		for (var i = 0; i < style.gradient.stops.length; i++) {
			// Straight Connectors and Bezier connectors act slightly differently; this code is a bit of a kludge.  but next version of
			// jsplumb will be replacing both Straight and Bezier to be generic instances of 'Connector', which has a list of segments.
			// so, not too concerned about leaving this in for now.
			var styleToUse = i;
			if (dimensions.length == 8) 
				styleToUse = dimensions[4] < dimensions[6] ? i: style.gradient.stops.length - 1 - i;
			else
				styleToUse = dimensions[4] < dimensions[6] ? style.gradient.stops.length - 1 - i : i;
			var stopColor = jsPlumb.util.convertStyle(style.gradient.stops[styleToUse][1], true);
			var s = _node(STOP, {"offset":Math.floor(style.gradient.stops[i][0] * 100) + "%", "stop-color":stopColor});
			g.appendChild(s);
		}
		var applyGradientTo = style.strokeStyle ? STROKE : FILL;
		node.setAttribute(STYLE, applyGradientTo + ":url(#" + id + ")");
	},
	_applyStyles = function(parent, node, style, dimensions, uiComponent) {
		
		if (style.gradient) {
			_updateGradient(parent, node, style, dimensions, uiComponent);			
		}
		else {
			// make sure we clear any existing gradient
			_clearGradient(parent);
			node.setAttribute(STYLE, "");
		}
		
		node.setAttribute(FILL, style.fillStyle ? jsPlumb.util.convertStyle(style.fillStyle, true) : NONE);
		node.setAttribute(STROKE, style.strokeStyle ? jsPlumb.util.convertStyle(style.strokeStyle, true) : NONE);		
		if (style.lineWidth) {
			node.setAttribute(STROKE_WIDTH, style.lineWidth);
		}
	
		// in SVG there is a stroke-dasharray attribute we can set, and its syntax looks like
		// the syntax in VML but is actually kind of nasty: values are given in the pixel
		// coordinate space, whereas in VML they are multiples of the width of the stroked
		// line, which makes a lot more sense.  for that reason, jsPlumb is supporting both
		// the native svg 'stroke-dasharray' attribute, and also the 'dashstyle' concept from
		// VML, which will be the preferred method.  the code below this converts a dashstyle
		// attribute given in terms of stroke width into a pixel representation, by using the
		// stroke's lineWidth. 
		if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {
			var sep = style[DASHSTYLE].indexOf(",") == -1 ? " " : ",",
			parts = style[DASHSTYLE].split(sep),
			styleToUse = "";
			parts.forEach(function(p) {
				styleToUse += (Math.floor(p * style.lineWidth) + sep);
			});
			node.setAttribute(STROKE_DASHARRAY, styleToUse);
		}		
		else if(style[STROKE_DASHARRAY]) {
			node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);
		}
		
		// extra attributes such as join type, dash offset.
		for (var i in svgAttributeMap) {
			if (style[i]) {
				node.setAttribute(svgAttributeMap[i], style[i]);
			}
		}
	},
	_decodeFont = function(f) {
		var r = /([0-9].)(p[xt])\s(.*)/;
		var bits = f.match(r);
		return {size:bits[1] + bits[2], font:bits[3]};		
	},
	_classManip = function(el, add, clazz) {
		var classesToAddOrRemove = clazz.split(" "),
			className = el.className,
			curClasses = className.baseVal.split(" ");
			
		for (var i = 0; i < classesToAddOrRemove.length; i++) {
			if (add) {
				if (curClasses.indexOf(classesToAddOrRemove[i]) == -1)
					curClasses.push(classesToAddOrRemove[i]);
			}
			else {
				var idx = curClasses.indexOf(classesToAddOrRemove[i]);
				if (idx != -1)
					curClasses.splice(idx, 1);
			}
		}
		
		el.className.baseVal = curClasses.join(" ");
	},
	_addClass = function(el, clazz) {
		_classManip(el, true, clazz);
	},
	_removeClass = function(el, clazz) {
		_classManip(el, false, clazz);
	};
	
	/**
		utility methods for other objects to use.
	*/
	jsPlumb.util.svg = {
		addClass:_addClass,
		removeClass:_removeClass
	};
	
	/*
	 * Base class for SVG components.
	 */
	//var SvgComponent = function(cssClass, originalArgs, pointerEventsSpec) {
	var SvgComponent = function(params) {
		var self = this,
		pointerEventsSpec = params.pointerEventsSpec || "all";
		jsPlumb.jsPlumbUIComponent.apply(this, params.originalArgs);
		self.canvas = null, self.path = null, self.svg = null; 
	
		var clazz = params.cssClass + " " + (params.originalArgs[0].cssClass || ""),		
			svgParams = {
				"style":"",
				"width":0,
				"height":0,
				"pointer-events":pointerEventsSpec,
				"position":"absolute"
			};
		if (self.tooltip) svgParams["title"] = self.tooltip;
		self.svg = _node("svg", svgParams);
		if (params.useDivWrapper) {
			self.canvas = document.createElement("div");
			self.canvas.style["position"] = "absolute";
			jsPlumb.sizeCanvas(self.canvas,0,0,1,1);
			self.canvas.className = clazz;
			if (self.tooltip) self.canvas.setAttribute("title", self.tooltip);
		}
		else {
			_attr(self.svg, { "class":clazz });
			self.canvas = self.svg;
		}
			
		params._jsPlumb.appendElement(self.canvas, params.originalArgs[0]["parent"]);
		if (params.useDivWrapper) self.canvas.appendChild(self.svg);
		
		// TODO this displayElement stuff is common between all components, across all
		// renderers.  would be best moved to jsPlumbUIComponent.
		var displayElements = [ self.canvas ];
		this.getDisplayElements = function() { 
			return displayElements; 
		};
		
		this.appendDisplayElement = function(el) {
			displayElements.push(el);
		};
		
		this.paint = function(d, style, anchor) {	   
			if (style != null) {
				var x = d[0], y = d[1];
				if (params.useDivWrapper) {
					jsPlumb.sizeCanvas(self.canvas, d[0], d[1], d[2], d[3]);
					x = 0, y = 0;
				}
		    	_attr(self.svg, {
	    			"style":_pos([x, y, d[2], d[3]]),
	    			"width": d[2],
	    			"height": d[3]
	    		});
		    	self._paint.apply(this, arguments);		    			    	
			}
	    };	
	};
	
	/*
	 * Base class for SVG connectors.
	 */
	var SvgConnector = jsPlumb.SvgConnector = function(params) {
		var self = this;
		SvgComponent.apply(this, [ { 
			cssClass:params["_jsPlumb"].connectorClass, 
			originalArgs:arguments, 
			pointerEventsSpec:"none", 
			tooltip:params.tooltip,
			_jsPlumb:params["_jsPlumb"] 
		} ]);
		this._paint = function(d, style) {
			var p = self.getPath(d), a = { "d":p }, outlineStyle = null;									
			a["pointer-events"] = "all";
			
			// outline style.  actually means drawing an svg object underneath the main one.
			if (style.outlineColor) {
				var outlineWidth = style.outlineWidth || 1,
				outlineStrokeWidth = style.lineWidth + (2 * outlineWidth),
				outlineStyle = jsPlumb.CurrentLibrary.extend({}, style);
				outlineStyle.strokeStyle = jsPlumb.util.convertStyle(style.outlineColor);
				outlineStyle.lineWidth = outlineStrokeWidth;
				
				if (self.bgPath == null) {
					self.bgPath = _node("path", a);
			    	self.svg.appendChild(self.bgPath);
		    		self.attachListeners(self.bgPath, self);
				}
				else {
					_attr(self.bgPath, a);
				}
				
				_applyStyles(self.svg, self.bgPath, outlineStyle, d, self);
			}
			
			
			// test - see below
	    	//	a["clip-path"]= "url(#testClip)"; 
			
	    	if (self.path == null) {
		    	self.path = _node("path", a);
		    	self.svg.appendChild(self.path);
	    		self.attachListeners(self.path, self);
	    		
	    		/*
	    		this is a test of a clip path.  i'm looking into using one of these to animate a jsplumb connection.
	    		you could do this by walking along the line, stepping along a little at a time, and setting the clip
	    		path to extend as far as that point.
	    		
	    		self.clip = _node("clipPath", {id:"testClip", clipPathUnits:"objectBoundingBox"});
	    		self.svg.appendChild(self.clip);
	    		self.clip.appendChild(_node("rect", {
	    			x:"0",y:"0",width:"0.5",height:"1" 
	    		}));
	    		*/
	    	}
	    	else {
	    		_attr(self.path, a);
	    	}
	    		    	
	    	_applyStyles(self.svg, self.path, style, d, self);
		};
		
		this.reattachListeners = function() {
			if (self.bgPath) self.reattachListenersForElement(self.bgPath, self);
			if (self.path) self.reattachListenersForElement(self.path, self);
		};
			
	};		

	/*
	 * SVG Bezier Connector
	 */
	jsPlumb.Connectors.svg.Bezier = function(params) {	
		jsPlumb.Connectors.Bezier.apply(this, arguments);
		SvgConnector.apply(this, arguments);	
		this.getPath = function(d) { return "M " + d[4] + " " + d[5] + " C " + d[8] + " " + d[9] + " " + d[10] + " " + d[11] + " " + d[6] + " " + d[7]; };	    	    
	};
	
	/*
	 * SVG straight line Connector
	 */
	jsPlumb.Connectors.svg.Straight = function(params) {			
		jsPlumb.Connectors.Straight.apply(this, arguments);
		SvgConnector.apply(this, arguments);	    		    
	    this.getPath = function(d) { return "M " + d[4] + " " + d[5] + " L " + d[6] + " " + d[7]; };	    
	};
	
	jsPlumb.Connectors.svg.Flowchart = function() {
    	var self = this;
    	jsPlumb.Connectors.Flowchart.apply(this, arguments);
		SvgConnector.apply(this, arguments);
    	this.getPath = function(dimensions) {
    		var p = "M " + dimensions[4] + "," + dimensions[5];
	        // loop through extra points
	        for (var i = 0; i < dimensions[8]; i++) {
	        	p = p + " L " + dimensions[9 + (i*2)] + " " + dimensions[10 + (i*2)];
	        }
	        // finally draw a line to the end
	        p = p  + " " + dimensions[6] + "," +  dimensions[7];
	        return p;
    	};
    };
    
    /*
	 * Base class for SVG endpoints.
	 */
	var SvgEndpoint = function(params) {
		var self = this;
		SvgComponent.apply(this, [ {
			cssClass:params["_jsPlumb"].endpointClass, 
			originalArgs:arguments, 
			pointerEventsSpec:"all",
			useDivWrapper:true,
			_jsPlumb:params["_jsPlumb"]
		} ]);
		this._paint = function(d, style) {
			var s = jsPlumb.extend({}, style);
			if (s.outlineColor) {
				s.strokeWidth = s.outlineWidth;
				s.strokeStyle = jsPlumb.util.convertStyle(s.outlineColor, true);
			}
			
			if (self.node == null) {
				self.node = self.makeNode(d, s);
				self.svg.appendChild(self.node);
				self.attachListeners(self.node, self);
			}
			_applyStyles(self.svg, self.node, s, d, self);
			_pos(self.node, d);
		};
		
		this.reattachListeners = function() {
			if (self.node) self.reattachListenersForElement(self.node, self);
		};
	};
	
	/*
	 * SVG Dot Endpoint
	 */
	jsPlumb.Endpoints.svg.Dot = function() {
		jsPlumb.Endpoints.Dot.apply(this, arguments);
		SvgEndpoint.apply(this, arguments);		
		this.makeNode = function(d, style) { 
			return _node("circle", {
					"cx"	:	d[2] / 2,
					"cy"	:	d[3] / 2,
					"r"		:	d[2] / 2
				});			
		};
	};
	
	/*
	 * SVG Rectangle Endpoint 
	 */
	jsPlumb.Endpoints.svg.Rectangle = function() {
		jsPlumb.Endpoints.Rectangle.apply(this, arguments);
		SvgEndpoint.apply(this, arguments);		
		this.makeNode = function(d, style) {
			return _node("rect", {
				"width":d[2],
				"height":d[3]
			});
		};			
	};		
	
	/*
	 * SVG Image Endpoint is the default image endpoint.
	 */
	jsPlumb.Endpoints.svg.Image = jsPlumb.Endpoints.Image;
	/*
	 * Blank endpoint in svg renderer is the default Blank endpoint.
	 */
	jsPlumb.Endpoints.svg.Blank = jsPlumb.Endpoints.Blank;	
	/*
	 * Label endpoint in svg renderer is the default Label endpoint.
	 */
	jsPlumb.Overlays.svg.Label = jsPlumb.Overlays.Label;
		
	var AbstractSvgArrowOverlay = function(superclass, originalArgs) {
    	superclass.apply(this, originalArgs);
    	jsPlumb.jsPlumbUIComponent.apply(this, originalArgs);
        this.isAppendedAtTopLevel = false;
    	var self = this, path =null;
    	this.paint = function(connector, d, lineWidth, strokeStyle, fillStyle) {
    		if (path == null) {
    			path = _node("path");
    			connector.svg.appendChild(path);
    			self.attachListeners(path, connector);
    			self.attachListeners(path, self);
    		}
    		var clazz = originalArgs && (originalArgs.length == 1) ? (originalArgs[0].cssClass || "") : "";
    		
    		_attr(path, { 
    			"d"		:	makePath(d),
    			"class" :	clazz,
    			stroke 	: 	strokeStyle ? strokeStyle : null,
    			fill 	: 	fillStyle ? fillStyle : null
    		});    		
    	};
    	var makePath = function(d) {
    		return "M" + d.hxy.x + "," + d.hxy.y +
    				" L" + d.tail[0].x + "," + d.tail[0].y + 
    				" L" + d.cxy.x + "," + d.cxy.y + 
    				" L" + d.tail[1].x + "," + d.tail[1].y + 
    				" L" + d.hxy.x + "," + d.hxy.y;
    	};
    	this.reattachListeners = function() {
			if (path) self.reattachListenersForElement(path, self);
		};
    };
    
    jsPlumb.Overlays.svg.Arrow = function() {
    	AbstractSvgArrowOverlay.apply(this, [jsPlumb.Overlays.Arrow, arguments]);    	
    };
    
    jsPlumb.Overlays.svg.PlainArrow = function() {
    	AbstractSvgArrowOverlay.apply(this, [jsPlumb.Overlays.PlainArrow, arguments]);    	
    };
    
    jsPlumb.Overlays.svg.Diamond = function() {
    	AbstractSvgArrowOverlay.apply(this, [jsPlumb.Overlays.Diamond, arguments]);    	
    };

    // a test
    jsPlumb.Overlays.svg.GuideLines = function() {
        var path = null, self = this, path2 = null, p1_1, p1_2;
        jsPlumb.Overlays.GuideLines.apply(this, arguments);
        this.paint = function(connector, d, lineWidth, strokeStyle, fillStyle) {
    		if (path == null) {
    			path = _node("path");
    			connector.svg.appendChild(path);
    			self.attachListeners(path, connector);
    			self.attachListeners(path, self);

                p1_1 = _node("path");
    			connector.svg.appendChild(p1_1);
    			self.attachListeners(p1_1, connector);
    			self.attachListeners(p1_1, self);

                p1_2 = _node("path");
    			connector.svg.appendChild(p1_2);
    			self.attachListeners(p1_2, connector);
    			self.attachListeners(p1_2, self);

    		}

    		_attr(path, {
    			"d"		:	makePath(d[0], d[1]),
    			stroke 	: 	"red",
    			fill 	: 	null
    		});

            _attr(p1_1, {
    			"d"		:	makePath(d[2][0], d[2][1]),
    			stroke 	: 	"blue",
    			fill 	: 	null
    		});

            _attr(p1_2, {
    			"d"		:	makePath(d[3][0], d[3][1]),
    			stroke 	: 	"green",
    			fill 	: 	null
    		});
    	};

        var makePath = function(d1, d2) {
            return "M " + d1.x + "," + d1.y +
                   " L" + d2.x + "," + d2.y;
        };

    };
})();/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.3.5
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the HTML5 canvas renderers.
 *
 * Copyright (c) 2010 - 2012 Simon Porritt (http://jsplumb.org)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */

;(function() {
	
// ********************************* CANVAS RENDERERS FOR CONNECTORS AND ENDPOINTS *******************************************************************
		
	// TODO refactor to renderer common script.  put a ref to jsPlumb.sizeCanvas in there too.
	var _connectionBeingDragged = null,
	    _hasClass = function(el, clazz) { return jsPlumb.CurrentLibrary.hasClass(_getElementObject(el), clazz); },
	    _getElementObject = function(el) { return jsPlumb.CurrentLibrary.getElementObject(el); },
	    _getOffset = function(el) { return jsPlumb.CurrentLibrary.getOffset(_getElementObject(el)); },
	    _pageXY = function(el) { return jsPlumb.CurrentLibrary.getPageXY(el); },
	    _clientXY = function(el) { return jsPlumb.CurrentLibrary.getClientXY(el); };
	
	/*
	 * Class:CanvasMouseAdapter
	 * Provides support for mouse events on canvases.  
	 */
	var CanvasMouseAdapter = function() {
		var self = this;
		self.overlayPlacements = [];
		jsPlumb.jsPlumbUIComponent.apply(this, arguments);
		jsPlumb.EventGenerator.apply(this, arguments);
		/**
		 * returns whether or not the given event is ojver a painted area of the canvas. 
		 */
	    this._over = function(e) {		    			  		    	
	    	var o = _getOffset(_getElementObject(self.canvas)),
	    	pageXY = _pageXY(e),
	    	x = pageXY[0] - o.left, y = pageXY[1] - o.top;
	    	if (x > 0 && y > 0 && x < self.canvas.width && y < self.canvas.height) {
		    	// first check overlays
		    	for ( var i = 0; i < self.overlayPlacements.length; i++) {
		    		var p = self.overlayPlacements[i];
		    		if (p && (p[0] <= x && p[1] >= x && p[2] <= y && p[3] >= y))
		    			return true;
		    	}
		    	
		    	// then the canvas
		    	var d = self.canvas.getContext("2d").getImageData(parseInt(x), parseInt(y), 1, 1);
		    	return d.data[0] != 0 || d.data[1] != 0 || d.data[2] != 0 || d.data[3] != 0;		  
	    	}
	    	return false;
	    };
	    
	    var _mouseover = false, _mouseDown = false, _posWhenMouseDown = null, _mouseWasDown = false,
	    _nullSafeHasClass = function(el, clazz) {
	    	return el != null && _hasClass(el, clazz);
	    };
	    this.mousemove = function(e) {		    
	    	var pageXY = _pageXY(e), clientXY = _clientXY(e),	   
	    	ee = document.elementFromPoint(clientXY[0], clientXY[1]),
	    	eventSourceWasOverlay = _nullSafeHasClass(ee, "_jsPlumb_overlay");	    	
			var _continue = _connectionBeingDragged == null && (_nullSafeHasClass(ee, "_jsPlumb_endpoint") || _nullSafeHasClass(ee, "_jsPlumb_connector"));
			if (!_mouseover && _continue && self._over(e)) {
				_mouseover = true;
				self.fire("mouseenter", self, e);		
				return true;
			}
			// TODO here there is a remote chance that the overlay the mouse moved onto
			// is actually not an overlay for the current component. a more thorough check would
			// be to ensure the overlay belonged to the current component.  
			else if (_mouseover && (!self._over(e) || !_continue) && !eventSourceWasOverlay) {
				_mouseover = false;
				self.fire("mouseexit", self, e);				
			}
			self.fire("mousemove", self, e);
	    };
	    		    		    
	    this.click = function(e) {	    		
	    	if (_mouseover && self._over(e) && !_mouseWasDown) 
	    		self.fire("click", self, e);		    	
	    	_mouseWasDown = false;
	    };
	    
	    this.dblclick = function(e) {
	    	if (_mouseover && self._over(e) && !_mouseWasDown) 
	    		self.fire("dblclick", self, e);		    	
	    	_mouseWasDown = false;
	    };
	    
	    this.mousedown = function(e) {
	    	if(self._over(e) && !_mouseDown) {
	    		_mouseDown = true;	    		
	    		_posWhenMouseDown = _getOffset(_getElementObject(self.canvas));
	    		self.fire("mousedown", self, e);
	    	}
	    };
	    
	    this.mouseup = function(e) {
	    	_mouseDown = false;
	    	self.fire("mouseup", self, e);
	    };

        this.contextmenu = function(e) {
          if (_mouseover && self._over(e) && !_mouseWasDown)
            self.fire("contextmenu", self, e);
          _mouseWasDown = false;
        };
	};
	
	var _newCanvas = function(params) {
		var canvas = document.createElement("canvas");
		jsPlumb.appendElement(canvas, params.parent);
		canvas.style.position = "absolute";
		if (params["class"]) canvas.className = params["class"];
		// set an id. if no id on the element and if uuid was supplied it
		// will be used, otherwise we'll create one.
		params["_jsPlumb"].getId(canvas, params.uuid);
		if (params.tooltip) canvas.setAttribute("title", params.tooltip);

		return canvas;
	};	

	var CanvasComponent = function(params) {
		CanvasMouseAdapter.apply(this, arguments);

		var displayElements = [ ];
		this.getDisplayElements = function() { return displayElements; };
		this.appendDisplayElement = function(el) { displayElements.push(el); };
	}
	
	/**
	 * Class:CanvasConnector
	 * Superclass for Canvas Connector renderers.
	 */
	var CanvasConnector = jsPlumb.CanvasConnector = function(params) {
		
		CanvasComponent.apply(this, arguments);
		
		var _paintOneStyle = function(dim, aStyle) {
			self.ctx.save();
			jsPlumb.extend(self.ctx, aStyle);
			if (aStyle.gradient) {
				var g = self.createGradient(dim, self.ctx);
				for ( var i = 0; i < aStyle.gradient.stops.length; i++)
					g.addColorStop(aStyle.gradient.stops[i][0], aStyle.gradient.stops[i][1]);
				self.ctx.strokeStyle = g;
			}
			self._paint(dim);
			self.ctx.restore();
		};

		var self = this,
		clazz = self._jsPlumb.connectorClass + " " + (params.cssClass || "");
		self.canvas = _newCanvas({ 
			"class":clazz, 
			_jsPlumb:self._jsPlumb,
			parent:params.parent,
			tooltip:params.tooltip
		});	
		self.ctx = self.canvas.getContext("2d");
		
		self.appendDisplayElement(self.canvas);
		
		self.paint = function(dim, style) {						
			if (style != null) {																				
				jsPlumb.sizeCanvas(self.canvas, dim[0], dim[1], dim[2], dim[3]);				
				if (style.outlineColor != null) {
					var outlineWidth = style.outlineWidth || 1,
					outlineStrokeWidth = style.lineWidth + (2 * outlineWidth),
					outlineStyle = {
						strokeStyle:style.outlineColor,
						lineWidth:outlineStrokeWidth
					};
					_paintOneStyle(dim, outlineStyle);
				}
				_paintOneStyle(dim, style);
			}
		};				
	};		
	
	/**
	 * Class:CanvasEndpoint
	 * Superclass for Canvas Endpoint renderers.
	 */
	var CanvasEndpoint = function(params) {
		var self = this;				
		CanvasComponent.apply(this, arguments);		
		var clazz = self._jsPlumb.endpointClass + " " + (params.cssClass || ""),
			canvasParams = { 
			"class":clazz, 
			_jsPlumb:self._jsPlumb,
			parent:params.parent,
			tooltip:self.tooltip
		};
		self.canvas = _newCanvas(canvasParams);	
		self.ctx = self.canvas.getContext("2d");

		self.appendDisplayElement(self.canvas);
		
		this.paint = function(d, style, anchor) {
			jsPlumb.sizeCanvas(self.canvas, d[0], d[1], d[2], d[3]);			
			if (style.outlineColor != null) {
				var outlineWidth = style.outlineWidth || 1,
				outlineStrokeWidth = style.lineWidth + (2 * outlineWidth);
				var outlineStyle = {
					strokeStyle:style.outlineColor,
					lineWidth:outlineStrokeWidth
				};
			}
			
			self._paint.apply(this, arguments);
		};
	};
	
	jsPlumb.Endpoints.canvas.Dot = function(params) {		
		jsPlumb.Endpoints.Dot.apply(this, arguments);
		CanvasEndpoint.apply(this, arguments);
		var self = this,		
		parseValue = function(value) {
			try { return parseInt(value); }
			catch(e) {
				if (value.substring(value.length - 1) == '%')
					return parseInt(value.substring(0, value - 1));
			}
		},					    	
		calculateAdjustments = function(gradient) {
			var offsetAdjustment = self.defaultOffset, innerRadius = self.defaultInnerRadius;
			gradient.offset && (offsetAdjustment = parseValue(gradient.offset));
        	gradient.innerRadius && (innerRadius = parseValue(gradient.innerRadius));
        	return [offsetAdjustment, innerRadius];
		};
		this._paint = function(d, style, anchor) {
			if (style != null) {			
				var ctx = self.canvas.getContext('2d'), orientation = anchor.getOrientation(self);
				jsPlumb.extend(ctx, style);							
	            if (style.gradient) {            	
	            	var adjustments = calculateAdjustments(style.gradient), 
	            	yAdjust = orientation[1] == 1 ? adjustments[0] * -1 : adjustments[0],
	            	xAdjust = orientation[0] == 1 ? adjustments[0] * -1:  adjustments[0],
	            	g = ctx.createRadialGradient(d[4], d[4], d[4], d[4] + xAdjust, d[4] + yAdjust, adjustments[1]);
		            for (var i = 0; i < style.gradient.stops.length; i++)
		            	g.addColorStop(style.gradient.stops[i][0], style.gradient.stops[i][1]);
		            ctx.fillStyle = g;
	            }				
				ctx.beginPath();    		
				ctx.arc(d[4], d[4], d[4], 0, Math.PI*2, true);
				ctx.closePath();				
				if (style.fillStyle || style.gradient) ctx.fill();
				if (style.strokeStyle) ctx.stroke();
			}
    	};
	};	
		
	jsPlumb.Endpoints.canvas.Rectangle = function(params) {
		
		var self = this;
		jsPlumb.Endpoints.Rectangle.apply(this, arguments);
		CanvasEndpoint.apply(this, arguments);				
		
    	this._paint = function(d, style, anchor) {
				
			var ctx = self.canvas.getContext("2d"), orientation = anchor.getOrientation(self);
			jsPlumb.extend(ctx, style);
			
			/* canvas gradient */
		    if (style.gradient) {
		    	// first figure out which direction to run the gradient in (it depends on the orientation of the anchors)
		    	var y1 = orientation[1] == 1 ? d[3] : orientation[1] == 0 ? d[3] / 2 : 0;
				var y2 = orientation[1] == -1 ? d[3] : orientation[1] == 0 ? d[3] / 2 : 0;
				var x1 = orientation[0] == 1 ? d[2] : orientation[0] == 0 ? d[2] / 2 : 0;
				var x2 = orientation[0] == -1 ? d[2] : orientation[0] == 0 ? d[2] / 2 : 0;
			    var g = ctx.createLinearGradient(x1,y1,x2,y2);
			    for (var i = 0; i < style.gradient.stops.length; i++)
	            	g.addColorStop(style.gradient.stops[i][0], style.gradient.stops[i][1]);
	            ctx.fillStyle = g;
		    }
			
			ctx.beginPath();
			ctx.rect(0, 0, d[2], d[3]);
			ctx.closePath();				
			if (style.fillStyle || style.gradient) ctx.fill();
			if (style.strokeStyle) ctx.stroke();
    	};
	};		
	
	jsPlumb.Endpoints.canvas.Triangle = function(params) {
	        			
		var self = this;
		jsPlumb.Endpoints.Triangle.apply(this, arguments);
		CanvasEndpoint.apply(this, arguments);			
		
    	this._paint = function(d, style, anchor)
		{    		
			var width = d[2], height = d[3], x = d[0], y = d[1],			
			ctx = self.canvas.getContext('2d'),
			offsetX = 0, offsetY = 0, angle = 0,
			orientation = anchor.getOrientation(self);
			
			if( orientation[0] == 1 ) {
				offsetX = width;
				offsetY = height;
				angle = 180;
			}
			if( orientation[1] == -1 ) {
				offsetX = width;
				angle = 90;
			}
			if( orientation[1] == 1 ) {
				offsetY = height;
				angle = -90;
			}
			
			ctx.fillStyle = style.fillStyle;
			
			ctx.translate(offsetX, offsetY);
			ctx.rotate(angle * Math.PI/180);

			ctx.beginPath();
			ctx.moveTo(0, 0);
			ctx.lineTo(width/2, height/2);
			ctx.lineTo(0, height);
			ctx.closePath();
			if (style.fillStyle || style.gradient) ctx.fill();
			if (style.strokeStyle) ctx.stroke();				
    	};
	};	
	
	/*
	 * Canvas Image Endpoint: uses the default version, which creates an <img> tag.
	 */
	jsPlumb.Endpoints.canvas.Image = jsPlumb.Endpoints.Image;
	
	/*
	 * Blank endpoint in all renderers is just the default Blank endpoint.
	 */
	jsPlumb.Endpoints.canvas.Blank = jsPlumb.Endpoints.Blank;
	
	/*
     * Canvas Bezier Connector. Draws a Bezier curve onto a Canvas element.
     */
    jsPlumb.Connectors.canvas.Bezier = function() {
    	var self = this;
    	jsPlumb.Connectors.Bezier.apply(this, arguments); 
    	CanvasConnector.apply(this, arguments);
    	this._paint = function(dimensions) {
        	self.ctx.beginPath();
        	self.ctx.moveTo(dimensions[4], dimensions[5]);
        	self.ctx.bezierCurveTo(dimensions[8], dimensions[9], dimensions[10], dimensions[11], dimensions[6], dimensions[7]);	            
        	self.ctx.stroke();            
        };
        
        // TODO i doubt this handles the case that source and target are swapped.
        this.createGradient = function(dim, ctx, swap) {
        	return /*(swap) ? self.ctx.createLinearGradient(dim[4], dim[5], dim[6], dim[7]) : */self.ctx.createLinearGradient(dim[6], dim[7], dim[4], dim[5]);
        };
    };
    
    /*
     * Canvas straight line Connector. Draws a straight line onto a Canvas element.
     */
    jsPlumb.Connectors.canvas.Straight = function() {   	 
		var self = this;
		jsPlumb.Connectors.Straight.apply(this, arguments);
		CanvasConnector.apply(this, arguments);
		this._paint = function(dimensions) {
	        self.ctx.beginPath();
	        self.ctx.moveTo(dimensions[4], dimensions[5]);
	        self.ctx.lineTo(dimensions[6], dimensions[7]);
	        self.ctx.stroke();            
	    };
	    
	    // TODO this does not handle the case that src and target are swapped.
	    this.createGradient = function(dim, ctx) {
        	return ctx.createLinearGradient(dim[4], dim[5], dim[6], dim[7]);
        };
    };
    
    jsPlumb.Connectors.canvas.Flowchart = function() {
    	var self = this;
    	jsPlumb.Connectors.Flowchart.apply(this, arguments);
		CanvasConnector.apply(this, arguments);
    	this._paint = function(dimensions) {
	        self.ctx.beginPath();
	        self.ctx.moveTo(dimensions[4], dimensions[5]);
	        // loop through extra points
	        for (var i = 0; i < dimensions[8]; i++) {
	        	self.ctx.lineTo(dimensions[9 + (i*2)], dimensions[10 + (i*2)]);
	        }
	        // finally draw a line to the end
	        self.ctx.lineTo(dimensions[6], dimensions[7]);
	        self.ctx.stroke();
    	};
    	
    	this.createGradient = function(dim, ctx) {
        	return ctx.createLinearGradient(dim[4], dim[5], dim[6], dim[7]);
        };
    };
    
// ********************************* END OF CANVAS RENDERERS *******************************************************************    
    
    jsPlumb.Overlays.canvas.Label = jsPlumb.Overlays.Label;
    
    /**
     * a placeholder right now, really just exists to mirror the fact that there are SVG and VML versions of this. 
     */
    var CanvasOverlay = function() { 
    	jsPlumb.jsPlumbUIComponent.apply(this, arguments);
    };
    
    var AbstractCanvasArrowOverlay = function(superclass, originalArgs) {
    	superclass.apply(this, originalArgs);
    	CanvasOverlay.apply(this, arguments);
    	this.paint = function(connector, d, lineWidth, strokeStyle, fillStyle) {
    		var ctx = connector.ctx;
    		
			ctx.lineWidth = lineWidth;
			ctx.beginPath();
			ctx.moveTo(d.hxy.x, d.hxy.y);
			ctx.lineTo(d.tail[0].x, d.tail[0].y);
			ctx.lineTo(d.cxy.x, d.cxy.y);
			ctx.lineTo(d.tail[1].x, d.tail[1].y);
			ctx.lineTo(d.hxy.x, d.hxy.y);
			ctx.closePath();						
						
			if (strokeStyle) {
				ctx.strokeStyle = strokeStyle;
				ctx.stroke();
			}
			if (fillStyle) {
				ctx.fillStyle = fillStyle;			
				ctx.fill();
			}
    	};
    }; 
    
    jsPlumb.Overlays.canvas.Arrow = function() {
    	AbstractCanvasArrowOverlay.apply(this, [jsPlumb.Overlays.Arrow, arguments]);    	
    };
    
    jsPlumb.Overlays.canvas.PlainArrow = function() {
    	AbstractCanvasArrowOverlay.apply(this, [jsPlumb.Overlays.PlainArrow, arguments]);    	
    };
    
    jsPlumb.Overlays.canvas.Diamond = function() {
    	AbstractCanvasArrowOverlay.apply(this, [jsPlumb.Overlays.Diamond, arguments]);    	
    };		
})();/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.3.5
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the jQuery adapter.
 *
 * Copyright (c) 2010 - 2012 Simon Porritt (http://jsplumb.org)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */ 
/* 
 * the library specific functions, such as find offset, get id, get attribute, extend etc.  
 * the full list is:
 * 
 * addClass				adds a class to the given element
 * animate				calls the underlying library's animate functionality
 * appendElement		appends a child element to a parent element.
 * bind					binds some event to an element
 * dragEvents			a dictionary of event names
 * extend				extend some js object with another.  probably not overly necessary; jsPlumb could just do this internally.
 * getAttribute			gets some attribute from an element
 * getDragObject		gets the object that is being dragged, by extracting it from the arguments passed to a drag callback
 * getDragScope			gets the drag scope for a given element.
 * getDropScope			gets the drop scope for a given element.
 * getElementObject		turns an id or dom element into an element object of the underlying library's type.
 * getOffset			gets an element's offset
 * getPageXY			gets the page event's xy location.
 * getParent			gets the parent of some element.
 * getScrollLeft		gets an element's scroll left.  TODO: is this actually used?  will it be?
 * getScrollTop			gets an element's scroll top.  TODO: is this actually used?  will it be?
 * getSize				gets an element's size.
 * getUIPosition		gets the position of some element that is currently being dragged, by extracting it from the arguments passed to a drag callback.
 * hasClass				returns whether or not the given element has the given class.
 * initDraggable		initializes an element to be draggable 
 * initDroppable		initializes an element to be droppable
 * isDragSupported		returns whether or not drag is supported for some element.
 * isDropSupported		returns whether or not drop is supported for some element.
 * removeClass			removes a class from a given element.
 * removeElement		removes some element completely from the DOM.
 * setAttribute			sets an attribute on some element.
 * setDraggable			sets whether or not some element should be draggable.
 * setDragScope			sets the drag scope for a given element.
 * setOffset			sets the offset of some element.
 * trigger				triggers some event on an element.
 * unbind				unbinds some listener from some element.
 */
(function($) {	
	
	//var getBoundingClientRectSupported = "getBoundingClientRect" in document.documentElement;

	jsPlumb.CurrentLibrary = {					        
		
		/**
		 * adds the given class to the element object.
		 */
		addClass : function(el, clazz) {
			el = jsPlumb.CurrentLibrary.getElementObject(el);
			try {
				if (el[0].className.constructor == SVGAnimatedString) {
					jsPlumb.util.svg.addClass(el[0], clazz);
				}
			}
			catch (e) {
				// SVGAnimatedString not supported; no problem.
			}
			el.addClass(clazz);
		},
		
		/**
		 * animates the given element.
		 */
		animate : function(el, properties, options) {
			el.animate(properties, options);
		},				
		
		/**
		 * appends the given child to the given parent.
		 */
		appendElement : function(child, parent) {
			jsPlumb.CurrentLibrary.getElementObject(parent).append(child);			
		},   
		
		/**
		 * event binding wrapper.  it just so happens that jQuery uses 'bind' also.  yui3, for example,
		 * uses 'on'.
		 */
		bind : function(el, event, callback) {
			el = jsPlumb.CurrentLibrary.getElementObject(el);
			el.bind(event, callback);
		},
		
		/**
         * mapping of drag events for jQuery
         */
		dragEvents : {
			'start':'start', 'stop':'stop', 'drag':'drag', 'step':'step',
			'over':'over', 'out':'out', 'drop':'drop', 'complete':'complete'
		},
				
		/**
		 * wrapper around the library's 'extend' functionality (which it hopefully has.
		 * otherwise you'll have to do it yourself). perhaps jsPlumb could do this for you
		 * instead.  it's not like its hard.
		 */
		extend : function(o1, o2) {
			return $.extend(o1, o2);
		},
		
		/**
		 * gets the named attribute from the given element object.  
		 */
		getAttribute : function(el, attName) {
			return el.attr(attName);
		},
		
		getClientXY : function(eventObject) {
			return [eventObject.clientX, eventObject.clientY];
		},
		
		getDocumentElement : function() { return document; },
		
		/**
		 * takes the args passed to an event function and returns you an object representing that which is being dragged.
		 */
		getDragObject : function(eventArgs) {
			return eventArgs[1].draggable;
		},
		
		getDragScope : function(el) {
			return el.draggable("option", "scope");
		},
		
		getDropScope : function(el) {
			return el.droppable("option", "scope");		
		},

		/**
		* gets a DOM element from the given input, which might be a string (in which case we just do document.getElementById),
		* a selector (in which case we return el[0]), or a DOM element already (we assume this if it's not either of the other
		* two cases).  this is the opposite of getElementObject below.
		*/
		getDOMElement : function(el) {
			if (typeof(el) == "string") return document.getElementById(el);
			else if (el.context) return el[0];
			else return el;
		},
	
		/**
		 * gets an "element object" from the given input.  this means an object that is used by the
		 * underlying library on which jsPlumb is running.  'el' may already be one of these objects,
		 * in which case it is returned as-is.  otherwise, 'el' is a String, the library's lookup 
		 * function is used to find the element, using the given String as the element's id.
		 * 
		 */		
		getElementObject : function(el) {			
			return typeof(el) == "string" ? $("#" + el) : $(el);
		},
		
		/**
		  * gets the offset for the element object.  this should return a js object like this:
		  *
		  * { left:xxx, top: xxx }
		 */
		getOffset : function(el) {
			return el.offset();
		},
		
		getPageXY : function(eventObject) {
			return [eventObject.pageX, eventObject.pageY];
		},
		
		getParent : function(el) {
			return jsPlumb.CurrentLibrary.getElementObject(el).parent();
		},
														
		getScrollLeft : function(el) {
			return el.scrollLeft();
		},
		
		getScrollTop : function(el) {
			return el.scrollTop();
		},
		
		getSelector : function(spec) {
			return $(spec);
		},
		
		/**
		 * gets the size for the element object, in an array : [ width, height ].
		 */
		getSize : function(el) {
			return [el.outerWidth(), el.outerHeight()];
		},

        getTagName : function(el) {
            var e = jsPlumb.CurrentLibrary.getElementObject(el);
            return e.length > 0 ? e[0].tagName : null;
        },
		
		/**
		 * takes the args passed to an event function and returns you an object that gives the
		 * position of the object being moved, as a js object with the same params as the result of
		 * getOffset, ie: { left: xxx, top: xxx }.
		 * 
		 * different libraries have different signatures for their event callbacks.  
		 * see getDragObject as well
		 */
		getUIPosition : function(eventArgs) {
			
			// this code is a workaround for the case that the element being dragged has a margin set on it. jquery UI passes
			// in the wrong offset if the element has a margin (it doesn't take the margin into account).  the getBoundingClientRect
			// method, which is in pretty much all browsers now, reports the right numbers.  but it introduces a noticeable lag, which
			// i don't like.
            
			/*if ( getBoundingClientRectSupported ) {
				var r = eventArgs[1].helper[0].getBoundingClientRect();
				return { left : r.left, top: r.top };
			} else {*/
			if (eventArgs.length == 1) {
				ret = { left: eventArgs[0].pageX, top:eventArgs[0].pageY };
			}
			else {
				var ui = eventArgs[1], _offset = ui.offset;			
				ret = _offset || ui.absolutePosition;
			}
            return ret;
		},		
		
		hasClass : function(el, clazz) {
			return el.hasClass(clazz);
		},
		
		/**
		 * initialises the given element to be draggable.
		 */
		initDraggable : function(el, options) {
			options = options || {};
			// remove helper directive if present.  
			options.helper = null;
			options['scope'] = options['scope'] || jsPlumb.Defaults.Scope;
			el.draggable(options);
		},
		
		/**
		 * initialises the given element to be droppable.
		 */
		initDroppable : function(el, options) {
			options['scope'] = options['scope'] || jsPlumb.Defaults.Scope;
			el.droppable(options);
		},
		
		isAlreadyDraggable : function(el) {
			el = jsPlumb.CurrentLibrary.getElementObject(el);
			return el.hasClass("ui-draggable");
		},
		
		/**
		 * returns whether or not drag is supported (by the library, not whether or not it is disabled) for the given element.
		 */
		isDragSupported : function(el, options) {
			return el.draggable;
		},				
						
		/**
		 * returns whether or not drop is supported (by the library, not whether or not it is disabled) for the given element.
		 */
		isDropSupported : function(el, options) {
			return el.droppable;
		},							
		
		/**
		 * removes the given class from the element object.
		 */
		removeClass : function(el, clazz) {
			el = jsPlumb.CurrentLibrary.getElementObject(el);
			try {
				if (el[0].className.constructor == SVGAnimatedString) {
					jsPlumb.util.svg.removeClass(el[0], clazz);
				}
			}
			catch (e) {
				// SVGAnimatedString not supported; no problem.
			}
			el.removeClass(clazz);
		},
		
		removeElement : function(element, parent) {			
			jsPlumb.CurrentLibrary.getElementObject(element).remove();
		},
		
		/**
		 * sets the named attribute on the given element object.  
		 */
		setAttribute : function(el, attName, attValue) {
			el.attr(attName, attValue);
		},
		
		/**
		 * sets the draggable state for the given element
		 */
		setDraggable : function(el, draggable) {
			el.draggable("option", "disabled", !draggable);
		},
		
		/**
		 * sets the drag scope.  probably time for a setDragOption method (roll this and the one above together)
		 * @param el
		 * @param scope
		 */
		setDragScope : function(el, scope) {
			el.draggable("option", "scope", scope);
		},
		
		setOffset : function(el, o) {
			jsPlumb.CurrentLibrary.getElementObject(el).offset(o);
		},
		
		/**
		 * note that jquery ignores the name of the event you wanted to trigger, and figures it out for itself.
		 * the other libraries do not.  yui, in fact, cannot even pass an original event.  we have to pull out stuff
		 * from the originalEvent to put in an options object for YUI. 
		 * @param el
		 * @param event
		 * @param originalEvent
		 */
		trigger : function(el, event, originalEvent) {
			//originalEvent.stopPropagation();
			//jsPlumb.CurrentLibrary.getElementObject(el).trigger(originalEvent);
            var h = jQuery._data(jsPlumb.CurrentLibrary.getElementObject(el)[0], "handle");
            h(originalEvent);
            //originalEvent.stopPropagation();
		},
		
		/**
		 * event unbinding wrapper.  it just so happens that jQuery uses 'unbind' also.  yui3, for example,
		 * uses..something else.
		 */
		unbind : function(el, event, callback) {
			el = jsPlumb.CurrentLibrary.getElementObject(el);
			el.unbind(event, callback);
		}
	};
	
	$(document).ready(jsPlumb.init);
	
})(jQuery);

(function(){if("undefined"==typeof Math.sgn)Math.sgn=function(a){return 0==a?0:0<a?1:-1};var l={subtract:function(a,b){return{x:a.x-b.x,y:a.y-b.y}},dotProduct:function(a,b){return a.x*b.x+a.y*b.y},square:function(a){return Math.sqrt(a.x*a.x+a.y*a.y)},scale:function(a,b){return{x:a.x*b,y:a.y*b}}},w=Math.pow(2,-65),u=function(a,b){for(var f=[],d=b.length-1,h=2*d-1,g=[],c=[],k=[],i=[],m=[[1,0.6,0.3,0.1],[0.4,0.6,0.6,0.4],[0.1,0.3,0.6,1]],e=0;e<=d;e++)g[e]=l.subtract(b[e],a);for(e=0;e<=d-1;e++)c[e]=l.subtract(b[e+
1],b[e]),c[e]=l.scale(c[e],3);for(e=0;e<=d-1;e++)for(var n=0;n<=d;n++)k[e]||(k[e]=[]),k[e][n]=l.dotProduct(c[e],g[n]);for(e=0;e<=h;e++)i[e]||(i[e]=[]),i[e].y=0,i[e].x=parseFloat(e)/h;h=d-1;for(g=0;g<=d+h;g++){e=Math.max(0,g-h);for(c=Math.min(g,d);e<=c;e++)j=g-e,i[e+j].y+=k[j][e]*m[j][e]}d=b.length-1;i=q(i,2*d-1,f,0);h=l.subtract(a,b[0]);k=l.square(h);for(e=m=0;e<i;e++)h=l.subtract(a,r(b,d,f[e],null,null)),h=l.square(h),h<k&&(k=h,m=f[e]);h=l.subtract(a,b[d]);h=l.square(h);h<k&&(k=h,m=1);return{location:m,
distance:k}},q=function(a,b,f,d){var h=[],g=[],c=[],k=[],i=0,m,e;e=Math.sgn(a[0].y);for(var n=1;n<=b;n++)m=Math.sgn(a[n].y),m!=e&&i++,e=m;switch(i){case 0:return 0;case 1:if(64<=d)return f[0]=(a[0].x+a[b].x)/2,1;var o,i=a[0].y-a[b].y;m=a[b].x-a[0].x;e=a[0].x*a[b].y-a[b].x*a[0].y;n=max_distance_below=0;for(o=1;o<b;o++){var l=i*a[o].x+m*a[o].y+e;l>n?n=l:l<max_distance_below&&(max_distance_below=l)}o=m;n=(1*(e-n)-0*o)*(1/(0*o-1*i));o=m;i=(1*(e-max_distance_below)-0*o)*(1/(0*o-1*i));m=Math.min(n,i);if(Math.max(n,
i)-m<w)return c=a[b].x-a[0].x,k=a[b].y-a[0].y,f[0]=0+1*(c*(a[0].y-0)-k*(a[0].x-0))*(1/(0*c-1*k)),1}r(a,b,0.5,h,g);a=q(h,b,c,d+1);b=q(g,b,k,d+1);for(d=0;d<a;d++)f[d]=c[d];for(d=0;d<b;d++)f[d+a]=k[d];return a+b},r=function(a,b,f,d,h){for(var g=[[]],c=0;c<=b;c++)g[0][c]=a[c];for(a=1;a<=b;a++)for(c=0;c<=b-a;c++)g[a]||(g[a]=[]),g[a][c]||(g[a][c]={}),g[a][c].x=(1-f)*g[a-1][c].x+f*g[a-1][c+1].x,g[a][c].y=(1-f)*g[a-1][c].y+f*g[a-1][c+1].y;if(null!=d)for(c=0;c<=b;c++)d[c]=g[c][0];if(null!=h)for(c=0;c<=b;c++)h[c]=
g[b-c][c];return g[b][0]},v={},x=function(a){var b=v[a];if(!b){var b=[],f=function(a){return function(){return a}},d=function(){return function(a){return a}},h=function(){return function(a){return 1-a}},g=function(a){return function(b){for(var c=1,d=0;d<a.length;d++)c*=a[d](b);return c}};b.push(new function(){return function(b){return Math.pow(b,a)}});for(var c=1;c<a;c++){for(var k=[new f(a)],i=0;i<a-c;i++)k.push(new d);for(i=0;i<c;i++)k.push(new h);b.push(new g(k))}b.push(new function(){return function(b){return Math.pow(1-
b,a)}});v[a]=b}return b},p=function(a,b){for(var f=x(a.length-1),d=0,h=0,g=0;g<a.length;g++)d+=a[g].x*f[g](b),h+=a[g].y*f[g](b);return{x:d,y:h}},s=function(a,b,f){for(var d=p(a,b),h=0,g=0<f?1:-1,c=null;h<Math.abs(f);)b+=0.005*g,c=p(a,b),h+=Math.sqrt(Math.pow(c.x-d.x,2)+Math.pow(c.y-d.y,2)),d=c;return{point:c,location:b}},t=function(a,b){var f=p(a,b),d=p(a.slice(0,a.length-1),b),h=d.y-f.y,f=d.x-f.x;return 0==h?Infinity:Math.atan(h/f)};window.jsBezier={distanceFromCurve:u,gradientAtPoint:t,gradientAtPointAlongCurveFrom:function(a,
b,f){b=s(a,b,f);if(1<b.location)b.location=1;if(0>b.location)b.location=0;return t(a,b.location)},nearestPointOnCurve:function(a,b){var f=u(a,b);return{point:r(b,b.length-1,f.location,null,null),location:f.location}},pointOnCurve:p,pointAlongCurveFrom:function(a,b,f){return s(a,b,f).point},perpendicularToCurveAt:function(a,b,f,d){b=s(a,b,null==d?0:d);a=t(a,b.location);d=Math.atan(-1/a);a=f/2*Math.sin(d);f=f/2*Math.cos(d);return[{x:b.point.x+f,y:b.point.y+a},{x:b.point.x-f,y:b.point.y-a}]}}})();
/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 * 
 * Requires: 1.2.2+
 */

(function($) {

var types = ['DOMMouseScroll', 'mousewheel'];

if ($.event.fixHooks) {
    for ( var i=types.length; i; ) {
        $.event.fixHooks[ types[--i] ] = $.event.mouseHooks;
    }
}

$.event.special.mousewheel = {
    setup: function() {
        if ( this.addEventListener ) {
            for ( var i=types.length; i; ) {
                this.addEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = handler;
        }
    },
    
    teardown: function() {
        if ( this.removeEventListener ) {
            for ( var i=types.length; i; ) {
                this.removeEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = null;
        }
    }
};

$.fn.extend({
    mousewheel: function(fn) {
        return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
    },
    
    unmousewheel: function(fn) {
        return this.unbind("mousewheel", fn);
    }
});


function handler(event) {
    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
    event = $.event.fix(orgEvent);
    event.type = "mousewheel";
    
    // Old school scrollwheel delta
    if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta/120; }
    if ( orgEvent.detail     ) { delta = -orgEvent.detail/3; }
    
    // New school multidimensional scroll (touchpads) deltas
    deltaY = delta;
    
    // Gecko
    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
        deltaY = 0;
        deltaX = -1*delta;
    }
    
    // Webkit
    if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120; }
    if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX/120; }
    
    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);
    
    return ($.event.dispatch || $.event.handle).apply(this, args);
}

})(jQuery);

/*
 * SimpleModal 1.4.2 - jQuery Plugin
 * http://simplemodal.com/
 * Copyright (c) 2011 Eric Martin
 * Licensed under MIT and GPL
 * Date: Sat, Dec 17 2011 15:35:38 -0800
 */

/**
 * SimpleModal is a lightweight jQuery plugin that provides a simple
 * interface to create a modal dialog.
 *
 * The goal of SimpleModal is to provide developers with a cross-browser
 * overlay and container that will be populated with data provided to
 * SimpleModal.
 *
 * There are two ways to call SimpleModal:
 * 1) As a chained function on a jQuery object, like $('#myDiv').modal();.
 * This call would place the DOM object, #myDiv, inside a modal dialog.
 * Chaining requires a jQuery object. An optional options object can be
 * passed as a parameter.
 *
 * @example $('<div>my data</div>').modal({options});
 * @example $('#myDiv').modal({options});
 * @example jQueryObject.modal({options});
 *
 * 2) As a stand-alone function, like $.modal(data). The data parameter
 * is required and an optional options object can be passed as a second
 * parameter. This method provides more flexibility in the types of data
 * that are allowed. The data could be a DOM object, a jQuery object, HTML
 * or a string.
 *
 * @example $.modal('<div>my data</div>', {options});
 * @example $.modal('my data', {options});
 * @example $.modal($('#myDiv'), {options});
 * @example $.modal(jQueryObject, {options});
 * @example $.modal(document.getElementById('myDiv'), {options});
 *
 * A SimpleModal call can contain multiple elements, but only one modal
 * dialog can be created at a time. Which means that all of the matched
 * elements will be displayed within the modal container.
 *
 * SimpleModal internally sets the CSS needed to display the modal dialog
 * properly in all browsers, yet provides the developer with the flexibility
 * to easily control the look and feel. The styling for SimpleModal can be
 * done through external stylesheets, or through SimpleModal, using the
 * overlayCss, containerCss, and dataCss options.
 *
 * SimpleModal has been tested in the following browsers:
 * - IE 6+
 * - Firefox 2+
 * - Opera 9+
 * - Safari 3+
 * - Chrome 1+
 *
 * @name SimpleModal
 * @type jQuery
 * @requires jQuery v1.2.4
 * @cat Plugins/Windows and Overlays
 * @author Eric Martin (http://ericmmartin.com)
 * @version 1.4.2
 */

;(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['jquery'], factory);
	} else {
		// Browser globals
		factory(jQuery);
	}
}
(function ($) {
	var d = [],
		doc = $(document),
		ie6 = $.browser.msie && parseInt($.browser.version) === 6 && typeof window['XMLHttpRequest'] !== 'object',
		ie7 = $.browser.msie && parseInt($.browser.version) === 7,
		ieQuirks = null,
		wndw = $(window),
		w = [];

	/*
	 * Create and display a modal dialog.
	 *
	 * @param {string, object} data A string, jQuery object or DOM object
	 * @param {object} [options] An optional object containing options overrides
	 */
	$.modal = function (data, options) {
		return $.modal.impl.init(data, options);
	};

	/*
	 * Close the modal dialog.
	 */
	$.modal.close = function () {
		$.modal.impl.close();
	};

	/*
	 * Set focus on first or last visible input in the modal dialog. To focus on the last
	 * element, call $.modal.focus('last'). If no input elements are found, focus is placed
	 * on the data wrapper element.
	 */
	$.modal.focus = function (pos) {
		$.modal.impl.focus(pos);
	};

	/*
	 * Determine and set the dimensions of the modal dialog container.
	 * setPosition() is called if the autoPosition option is true.
	 */
	$.modal.setContainerDimensions = function () {
		$.modal.impl.setContainerDimensions();
	};

	/*
	 * Re-position the modal dialog.
	 */
	$.modal.setPosition = function () {
		$.modal.impl.setPosition();
	};

	/*
	 * Update the modal dialog. If new dimensions are passed, they will be used to determine
	 * the dimensions of the container.
	 *
	 * setContainerDimensions() is called, which in turn calls setPosition(), if enabled.
	 * Lastly, focus() is called is the focus option is true.
	 */
	$.modal.update = function (height, width) {
		$.modal.impl.update(height, width);
	};

	/*
	 * Chained function to create a modal dialog.
	 *
	 * @param {object} [options] An optional object containing options overrides
	 */
	$.fn.modal = function (options) {
		return $.modal.impl.init(this, options);
	};

	/*
	 * SimpleModal default options
	 *
	 * appendTo:		(String:'body') The jQuery selector to append the elements to. For .NET, use 'form'.
	 * focus:			(Boolean:true) Focus in the first visible, enabled element?
	 * opacity:			(Number:50) The opacity value for the overlay div, from 0 - 100
	 * overlayId:		(String:'simplemodal-overlay') The DOM element id for the overlay div
	 * overlayCss:		(Object:{}) The CSS styling for the overlay div
	 * containerId:		(String:'simplemodal-container') The DOM element id for the container div
	 * containerCss:	(Object:{}) The CSS styling for the container div
	 * dataId:			(String:'simplemodal-data') The DOM element id for the data div
	 * dataCss:			(Object:{}) The CSS styling for the data div
	 * minHeight:		(Number:null) The minimum height for the container
	 * minWidth:		(Number:null) The minimum width for the container
	 * maxHeight:		(Number:null) The maximum height for the container. If not specified, the window height is used.
	 * maxWidth:		(Number:null) The maximum width for the container. If not specified, the window width is used.
	 * autoResize:		(Boolean:false) Automatically resize the container if it exceeds the browser window dimensions?
	 * autoPosition:	(Boolean:true) Automatically position the container upon creation and on window resize?
	 * zIndex:			(Number: 1000) Starting z-index value
	 * close:			(Boolean:true) If true, closeHTML, escClose and overClose will be used if set.
	 							If false, none of them will be used.
	 * closeHTML:		(String:'<a class="modalCloseImg" title="Close"></a>') The HTML for the default close link.
								SimpleModal will automatically add the closeClass to this element.
	 * closeClass:		(String:'simplemodal-close') The CSS class used to bind to the close event
	 * escClose:		(Boolean:true) Allow Esc keypress to close the dialog?
	 * overlayClose:	(Boolean:false) Allow click on overlay to close the dialog?
	 * fixed:			(Boolean:true) If true, the container will use a fixed position. If false, it will use a
								absolute position (the dialog will scroll with the page)
	 * position:		(Array:null) Position of container [top, left]. Can be number of pixels or percentage
	 * persist:			(Boolean:false) Persist the data across modal calls? Only used for existing
								DOM elements. If true, the data will be maintained across modal calls, if false,
								the data will be reverted to its original state.
	 * modal:			(Boolean:true) User will be unable to interact with the page below the modal or tab away from the dialog.
								If false, the overlay, iframe, and certain events will be disabled allowing the user to interact
								with the page below the dialog.
	 * onOpen:			(Function:null) The callback function used in place of SimpleModal's open
	 * onShow:			(Function:null) The callback function used after the modal dialog has opened
	 * onClose:			(Function:null) The callback function used in place of SimpleModal's close
	 */
	$.modal.defaults = {
		appendTo: 'body',
		focus: true,
		opacity: 50,
		overlayId: 'simplemodal-overlay',
		overlayCss: {},
		containerId: 'simplemodal-container',
		containerCss: {},
		dataId: 'simplemodal-data',
		dataCss: {},
		minHeight: null,
		minWidth: null,
		maxHeight: null,
		maxWidth: null,
		autoResize: false,
		autoPosition: true,
		zIndex: 1000,
		close: true,
		closeHTML: '<a class="modalCloseImg" title="Close"></a>',
		closeClass: 'simplemodal-close',
		escClose: true,
		overlayClose: false,
		fixed: true,
		position: null,
		persist: false,
		modal: true,
		onOpen: null,
		onShow: null,
		onClose: null
	};

	/*
	 * Main modal object
	 * o = options
	 */
	$.modal.impl = {
		/*
		 * Contains the modal dialog elements and is the object passed
		 * back to the callback (onOpen, onShow, onClose) functions
		 */
		d: {},
		/*
		 * Initialize the modal dialog
		 */
		init: function (data, options) {
			var s = this;

			// don't allow multiple calls
			if (s.d.data) {
				return false;
			}

			// $.boxModel is undefined if checked earlier
			ieQuirks = $.browser.msie && !$.boxModel;

			// merge defaults and user options
			s.o = $.extend({}, $.modal.defaults, options);

			// keep track of z-index
			s.zIndex = s.o.zIndex;

			// set the onClose callback flag
			s.occb = false;

			// determine how to handle the data based on its type
			if (typeof data === 'object') {
				// convert DOM object to a jQuery object
				data = data instanceof jQuery ? data : $(data);
				s.d.placeholder = false;

				// if the object came from the DOM, keep track of its parent
				if (data.parent().parent().size() > 0) {
					data.before($('<span></span>')
						.attr('id', 'simplemodal-placeholder')
						.css({display: 'none'}));

					s.d.placeholder = true;
					s.display = data.css('display');

					// persist changes? if not, make a clone of the element
					if (!s.o.persist) {
						s.d.orig = data.clone(true);
					}
				}
			}
			else if (typeof data === 'string' || typeof data === 'number') {
				// just insert the data as innerHTML
				data = $('<div></div>').html(data);
			}
			else {
				// unsupported data type!
				alert('SimpleModal Error: Unsupported data type: ' + typeof data);
				return s;
			}

			// create the modal overlay, container and, if necessary, iframe
			s.create(data);
			data = null;

			// display the modal dialog
			s.open();

			// useful for adding events/manipulating data in the modal dialog
			if ($.isFunction(s.o.onShow)) {
				s.o.onShow.apply(s, [s.d]);
			}

			// don't break the chain =)
			return s;
		},
		/*
		 * Create and add the modal overlay and container to the page
		 */
		create: function (data) {
			var s = this;

			// get the window properties
			s.getDimensions();

			// add an iframe to prevent select options from bleeding through
			if (s.o.modal && ie6) {
				s.d.iframe = $('<iframe src="javascript:false;"></iframe>')
					.css($.extend(s.o.iframeCss, {
						display: 'none',
						opacity: 0,
						position: 'fixed',
						height: w[0],
						width: w[1],
						zIndex: s.o.zIndex,
						top: 0,
						left: 0
					}))
					.appendTo(s.o.appendTo);
			}

			// create the overlay
			s.d.overlay = $('<div></div>')
				.attr('id', s.o.overlayId)
				.addClass('simplemodal-overlay')
				.css($.extend(s.o.overlayCss, {
					display: 'none',
					opacity: s.o.opacity / 100,
					height: s.o.modal ? d[0] : 0,
					width: s.o.modal ? d[1] : 0,
					position: 'fixed',
					left: 0,
					top: 0,
					zIndex: s.o.zIndex + 1
				}))
				.appendTo(s.o.appendTo);

			// create the container
			s.d.container = $('<div></div>')
				.attr('id', s.o.containerId)
				.addClass('simplemodal-container')
				.css($.extend(
					{position: s.o.fixed ? 'fixed' : 'absolute'},
					s.o.containerCss,
					{display: 'none', zIndex: s.o.zIndex + 2}
				))
				.append(s.o.close && s.o.closeHTML
					? $(s.o.closeHTML).addClass(s.o.closeClass)
					: '')
				.appendTo(s.o.appendTo);

			s.d.wrap = $('<div></div>')
				.attr('tabIndex', -1)
				.addClass('simplemodal-wrap')
				.css({height: '100%', outline: 0, width: '100%'})
				.appendTo(s.d.container);

			// add styling and attributes to the data
			// append to body to get correct dimensions, then move to wrap
			s.d.data = data
				.attr('id', data.attr('id') || s.o.dataId)
				.addClass('simplemodal-data')
				.css($.extend(s.o.dataCss, {
						display: 'none'
				}))
				.appendTo('body');
			data = null;

			s.setContainerDimensions();
			s.d.data.appendTo(s.d.wrap);

			// fix issues with IE
			if (ie6 || ieQuirks) {
				s.fixIE();
			}
		},
		/*
		 * Bind events
		 */
		bindEvents: function () {
			var s = this;

			// bind the close event to any element with the closeClass class
			$('.' + s.o.closeClass).bind('click.simplemodal', function (e) {
				e.preventDefault();
				s.close();
			});

			// bind the overlay click to the close function, if enabled
			if (s.o.modal && s.o.close && s.o.overlayClose) {
				s.d.overlay.bind('click.simplemodal', function (e) {
					e.preventDefault();
					s.close();
				});
			}

			// bind keydown events
			doc.bind('keydown.simplemodal', function (e) {
				if (s.o.modal && e.keyCode === 9) { // TAB
					s.watchTab(e);
				}
				else if ((s.o.close && s.o.escClose) && e.keyCode === 27) { // ESC
					e.preventDefault();
					s.close();
				}
			});

			// update window size
			wndw.bind('resize.simplemodal orientationchange.simplemodal', function () {
				// redetermine the window width/height
				s.getDimensions();

				// reposition the dialog
				s.o.autoResize ? s.setContainerDimensions() : s.o.autoPosition && s.setPosition();

				if (ie6 || ieQuirks) {
					s.fixIE();
				}
				else if (s.o.modal) {
					// update the iframe & overlay
					s.d.iframe && s.d.iframe.css({height: w[0], width: w[1]});
					s.d.overlay.css({height: d[0], width: d[1]});
				}
			});
		},
		/*
		 * Unbind events
		 */
		unbindEvents: function () {
			$('.' + this.o.closeClass).unbind('click.simplemodal');
			doc.unbind('keydown.simplemodal');
			wndw.unbind('.simplemodal');
			this.d.overlay.unbind('click.simplemodal');
		},
		/*
		 * Fix issues in IE6 and IE7 in quirks mode
		 */
		fixIE: function () {
			var s = this, p = s.o.position;

			// simulate fixed position - adapted from BlockUI
			$.each([s.d.iframe || null, !s.o.modal ? null : s.d.overlay, s.d.container.css('position') === 'fixed' ? s.d.container : null], function (i, el) {
				if (el) {
					var bch = 'document.body.clientHeight', bcw = 'document.body.clientWidth',
						bsh = 'document.body.scrollHeight', bsl = 'document.body.scrollLeft',
						bst = 'document.body.scrollTop', bsw = 'document.body.scrollWidth',
						ch = 'document.documentElement.clientHeight', cw = 'document.documentElement.clientWidth',
						sl = 'document.documentElement.scrollLeft', st = 'document.documentElement.scrollTop',
						s = el[0].style;

					s.position = 'absolute';
					if (i < 2) {
						s.removeExpression('height');
						s.removeExpression('width');
						s.setExpression('height','' + bsh + ' > ' + bch + ' ? ' + bsh + ' : ' + bch + ' + "px"');
						s.setExpression('width','' + bsw + ' > ' + bcw + ' ? ' + bsw + ' : ' + bcw + ' + "px"');
					}
					else {
						var te, le;
						if (p && p.constructor === Array) {
							var top = p[0]
								? typeof p[0] === 'number' ? p[0].toString() : p[0].replace(/px/, '')
								: el.css('top').replace(/px/, '');
							te = top.indexOf('%') === -1
								? top + ' + (t = ' + st + ' ? ' + st + ' : ' + bst + ') + "px"'
								: parseInt(top.replace(/%/, '')) + ' * ((' + ch + ' || ' + bch + ') / 100) + (t = ' + st + ' ? ' + st + ' : ' + bst + ') + "px"';

							if (p[1]) {
								var left = typeof p[1] === 'number' ? p[1].toString() : p[1].replace(/px/, '');
								le = left.indexOf('%') === -1
									? left + ' + (t = ' + sl + ' ? ' + sl + ' : ' + bsl + ') + "px"'
									: parseInt(left.replace(/%/, '')) + ' * ((' + cw + ' || ' + bcw + ') / 100) + (t = ' + sl + ' ? ' + sl + ' : ' + bsl + ') + "px"';
							}
						}
						else {
							te = '(' + ch + ' || ' + bch + ') / 2 - (this.offsetHeight / 2) + (t = ' + st + ' ? ' + st + ' : ' + bst + ') + "px"';
							le = '(' + cw + ' || ' + bcw + ') / 2 - (this.offsetWidth / 2) + (t = ' + sl + ' ? ' + sl + ' : ' + bsl + ') + "px"';
						}
						s.removeExpression('top');
						s.removeExpression('left');
						s.setExpression('top', te);
						s.setExpression('left', le);
					}
				}
			});
		},
		/*
		 * Place focus on the first or last visible input
		 */
		focus: function (pos) {
			var s = this, p = pos && $.inArray(pos, ['first', 'last']) !== -1 ? pos : 'first';

			// focus on dialog or the first visible/enabled input element
			var input = $(':input:enabled:visible:' + p, s.d.wrap);
			setTimeout(function () {
				input.length > 0 ? input.focus() : s.d.wrap.focus();
			}, 10);
		},
		getDimensions: function () {
			// fix a jQuery/Opera bug with determining the window height
			var s = this,
				h = $.browser.opera && $.browser.version > '9.5' && $.fn.jquery < '1.3'
						|| $.browser.opera && $.browser.version < '9.5' && $.fn.jquery > '1.2.6'
				? wndw[0].innerHeight : wndw.height();

			d = [doc.height(), doc.width()];
			w = [h, wndw.width()];
		},
		getVal: function (v, d) {
			return v ? (typeof v === 'number' ? v
					: v === 'auto' ? 0
					: v.indexOf('%') > 0 ? ((parseInt(v.replace(/%/, '')) / 100) * (d === 'h' ? w[0] : w[1]))
					: parseInt(v.replace(/px/, '')))
				: null;
		},
		/*
		 * Update the container. Set new dimensions, if provided.
		 * Focus, if enabled. Re-bind events.
		 */
		update: function (height, width) {
			var s = this;

			// prevent update if dialog does not exist
			if (!s.d.data) {
				return false;
			}

			// reset orig values
			s.d.origHeight = s.getVal(height, 'h');
			s.d.origWidth = s.getVal(width, 'w');

			// hide data to prevent screen flicker
			s.d.data.hide();
			height && s.d.container.css('height', height);
			width && s.d.container.css('width', width);
			s.setContainerDimensions();
			s.d.data.show();
			s.o.focus && s.focus();

			// rebind events
			s.unbindEvents();
			s.bindEvents();
		},
		setContainerDimensions: function () {
			var s = this,
				badIE = ie6 || ie7;

			// get the dimensions for the container and data
			var ch = s.d.origHeight ? s.d.origHeight : $.browser.opera ? s.d.container.height() : s.getVal(badIE ? s.d.container[0].currentStyle['height'] : s.d.container.css('height'), 'h'),
				cw = s.d.origWidth ? s.d.origWidth : $.browser.opera ? s.d.container.width() : s.getVal(badIE ? s.d.container[0].currentStyle['width'] : s.d.container.css('width'), 'w'),
				dh = s.d.data.outerHeight(true), dw = s.d.data.outerWidth(true);

			s.d.origHeight = s.d.origHeight || ch;
			s.d.origWidth = s.d.origWidth || cw;

			// mxoh = max option height, mxow = max option width
			var mxoh = s.o.maxHeight ? s.getVal(s.o.maxHeight, 'h') : null,
				mxow = s.o.maxWidth ? s.getVal(s.o.maxWidth, 'w') : null,
				mh = mxoh && mxoh < w[0] ? mxoh : w[0],
				mw = mxow && mxow < w[1] ? mxow : w[1];

			// moh = min option height
			var moh = s.o.minHeight ? s.getVal(s.o.minHeight, 'h') : 'auto';
			if (!ch) {
				if (!dh) {ch = moh;}
				else {
					if (dh > mh) {ch = mh;}
					else if (s.o.minHeight && moh !== 'auto' && dh < moh) {ch = moh;}
					else {ch = dh;}
				}
			}
			else {
				ch = s.o.autoResize && ch > mh ? mh : ch < moh ? moh : ch;
			}

			// mow = min option width
			var mow = s.o.minWidth ? s.getVal(s.o.minWidth, 'w') : 'auto';
			if (!cw) {
				if (!dw) {cw = mow;}
				else {
					if (dw > mw) {cw = mw;}
					else if (s.o.minWidth && mow !== 'auto' && dw < mow) {cw = mow;}
					else {cw = dw;}
				}
			}
			else {
				cw = s.o.autoResize && cw > mw ? mw : cw < mow ? mow : cw;
			}

			s.d.container.css({height: ch, width: cw});
			s.d.wrap.css({overflow: (dh > ch || dw > cw) ? 'auto' : 'visible'});
			s.o.autoPosition && s.setPosition();
		},
		setPosition: function () {
			var s = this, top, left,
				hc = (w[0]/2) - (s.d.container.outerHeight(true)/2),
				vc = (w[1]/2) - (s.d.container.outerWidth(true)/2),
				st = s.d.container.css('position') !== 'fixed' ? wndw.scrollTop() : 0;

			if (s.o.position && Object.prototype.toString.call(s.o.position) === '[object Array]') {
				top = st + (s.o.position[0] || hc);
				left = s.o.position[1] || vc;
			} else {
				top = st + hc;
				left = vc;
			}
			s.d.container.css({left: left, top: top});
		},
		watchTab: function (e) {
			var s = this;

			if ($(e.target).parents('.simplemodal-container').length > 0) {
				// save the list of inputs
				s.inputs = $(':input:enabled:visible:first, :input:enabled:visible:last', s.d.data[0]);

				// if it's the first or last tabbable element, refocus
				if ((!e.shiftKey && e.target === s.inputs[s.inputs.length -1]) ||
						(e.shiftKey && e.target === s.inputs[0]) ||
						s.inputs.length === 0) {
					e.preventDefault();
					var pos = e.shiftKey ? 'last' : 'first';
					s.focus(pos);
				}
			}
			else {
				// might be necessary when custom onShow callback is used
				e.preventDefault();
				s.focus();
			}
		},
		/*
		 * Open the modal dialog elements
		 * - Note: If you use the onOpen callback, you must "show" the
		 *			overlay and container elements manually
		 *		 (the iframe will be handled by SimpleModal)
		 */
		open: function () {
			var s = this;
			// display the iframe
			s.d.iframe && s.d.iframe.show();

			if ($.isFunction(s.o.onOpen)) {
				// execute the onOpen callback
				s.o.onOpen.apply(s, [s.d]);
			}
			else {
				// display the remaining elements
				s.d.overlay.show();
				s.d.container.show();
				s.d.data.show();
			}

			s.o.focus && s.focus();

			// bind default events
			s.bindEvents();
		},
		/*
		 * Close the modal dialog
		 * - Note: If you use an onClose callback, you must remove the
		 *         overlay, container and iframe elements manually
		 *
		 * @param {boolean} external Indicates whether the call to this
		 *     function was internal or external. If it was external, the
		 *     onClose callback will be ignored
		 */
		close: function () {
			var s = this;

			// prevent close when dialog does not exist
			if (!s.d.data) {
				return false;
			}

			// remove the default events
			s.unbindEvents();

			if ($.isFunction(s.o.onClose) && !s.occb) {
				// set the onClose callback flag
				s.occb = true;

				// execute the onClose callback
				s.o.onClose.apply(s, [s.d]);
			}
			else {
				// if the data came from the DOM, put it back
				if (s.d.placeholder) {
					var ph = $('#simplemodal-placeholder');
					// save changes to the data?
					if (s.o.persist) {
						// insert the (possibly) modified data back into the DOM
						ph.replaceWith(s.d.data.removeClass('simplemodal-data').css('display', s.display));
					}
					else {
						// remove the current and insert the original,
						// unmodified data back into the DOM
						s.d.data.hide().remove();
						ph.replaceWith(s.d.orig);
					}
				}
				else {
					// otherwise, remove it
					s.d.data.hide().remove();
				}

				// remove the remaining elements
				s.d.container.hide().remove();
				s.d.overlay.hide();
				s.d.iframe && s.d.iframe.hide().remove();
				s.d.overlay.remove();

				// reset the dialog object
				s.d = {};
			}
		}
	};
}));

/*
 ### jQuery Star Rating Plugin v3.13 - 2009-03-26 ###
 * Home: http://www.fyneworks.com/jquery/wgt-rating/
 * Code: http://code.google.com/p/jquery-wgt-rating-plugin/
 *
  * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 ###
*/


(function($){

  
  // IE6 Background Image Fix
  /* FUCK IE6!
  if ($.browser.msie) 
  {
    try 
    { 
      document.execCommand("BackgroundImageCache", false, true)
    } 
    catch(e) 
    { };
  }
  */
  
  // plugin initialization
  $.fn.rating = function(options){
    
    if(this.length==0) 
      return this; // quick fail
    
    // Handle API methods
    if(typeof arguments[0]=='string'){
      
      // Perform API methods on individual elements
      if(this.length>1){
        
        var args = arguments;
        return this.each(function(){
          
          $.fn.rating.apply($(this), args);
        });
      };
      
      // Invoke API method handler
      $.fn.rating[arguments[0]].apply(this, $.makeArray(arguments).slice(1) || []);
      // Quick exit...
      return this;
    };
    
    // Initialize options for this call
    var options = $.extend(
      {}/* new object */,
      $.fn.rating.options/* default options */,
      options || {} /* just-in-time options */
    );
    
    // Allow multiple controls with the same name by making each call unique
    $.fn.rating.calls++;
    
    // loop through each matched element
    this
    .not('.wgt-rating-applied')
    .addClass('wgt-rating-applied')
    .each(function(){
      
      // Load control parameters / find context / etc
      var control, input = $(this);
      var eid = (this.name || 'unnamed-rating').replace(/\[|\]/g, '_').replace(/^\_+|\_+$/g,'');
      var context = $(this.form || document.body);
    
      // FIX: http://code.google.com/p/jquery-wgt-rating-plugin/issues/detail?id=23
      var raters = context.data('rating');
      if(!raters || raters.call!=$.fn.rating.calls) raters = {
        count:0, 
        call:$.fn.rating.calls
      };
      var rater = raters[eid];
      
      // if rater is available, verify that the control still exists
      if(rater) 
        control = rater.data('rating');
      
      if(rater && control)//{// save a byte!
        // add star to control if rater is available and the same control still exists
        control.count++;
        
      //}// save a byte!
      else{
        // create new control if first star or control element was removed/replaced
        
        // Initialize options for this raters
        control = $.extend(
          {}/* new object */,
          options || {} /* current call options */,
          ( $.metadata? input.metadata(): ($.meta?input.data():null)) || {},{ /* metadata options */
            count:0, 
            stars: [], 
            inputs: []
          });
        
        // increment number of rating controls
        control.serial = raters.count++;
        
        // create rating element
        rater = $('<span class="wgt-rating-control"/>');
        input.before(rater);
        
        // Mark element for initialization (once all stars are ready)
        rater.addClass('rating-to-be-drawn');
        
        // Accept readOnly setting from 'disabled' property
        if(input.attr('disabled')) 
          control.readOnly = true;
        
        // Create 'cancel' button
        rater.append(
          control.cancel = $('<div class="rating-cancel"><a title="' + control.cancel + '">' + control.cancelValue + '</a></div>')
          .mouseover(function(){
            $(this).rating('drain');
            $(this).addClass('wgt-rating-hover');
          //$(this).rating('focus');
          })
          .mouseout(function(){
            $(this).rating('draw');
            $(this).removeClass('wgt-rating-hover');
          //$(this).rating('blur');
          })
          .click(function(){
            $(this).rating('select');
          })
          .data('rating', control)
          );
        
      }; // first element of group
      
      // insert rating star
      var star = $('<div class="wgt-rating rater-'+ control.serial +'"><a title="' + (this.title || this.value) + '">' + this.value + '</a></div>');
      rater.append(star);
      
      // inherit attributes from input element
      if(this.id) star.attr('id', this.id);
      if(this.className) star.addClass(this.className);
      
      // Half-stars?
      if(control.half) 
        control.split = 2;
      
      // Prepare division control
      if(typeof control.split=='number' && control.split>0){
        var stw = ($.fn.width ? star.width() : 0) || control.starWidth;
        var spi = (control.count % control.split), spw = Math.floor(stw/control.split);
        star
        // restrict star's width and hide overflow (already in CSS)
        .width(spw)
        // move the star left by using a negative margin
        // this is work-around to IE's stupid box model (position:relative doesn't work)
        .find('a').css({
          'margin-left':'-'+ (spi*spw) +'px'
        })
      };
      
      // readOnly?
      if(control.readOnly)//{ //save a byte!
        // Mark star as readOnly so user can customize display
        star.addClass('wgt-rating-readonly');
      //}  //save a byte!
      else//{ //save a byte!
        // Enable hover css effects
        star.addClass('wgt-rating-live')
        // Attach mouse events
        .mouseover(function(){
          $(this).rating('fill');
          $(this).rating('focus');
        })
        .mouseout(function(){
          $(this).rating('draw');
          $(this).rating('blur');
        })
        .click(function(){
          $(this).rating('select');
          $(this).trigger('wgt.rated')
        })
      ;
      //}; //save a byte!
      
      // set current selection
      if(this.checked)  
        control.current = star;
      
      // hide input element
      input.hide();
      
      // backward compatibility, form element to plugin
      input.change(function(){
        $(this).rating('select');
      });
      
      // attach reference to star to input element and vice-versa
      star.data('rating.input', input.data('rating.star', star));
      
      // store control information in form (or body when form not available)
      control.stars[control.stars.length] = star[0];
      control.inputs[control.inputs.length] = input[0];
      control.rater = raters[eid] = rater;
      control.context = context;
      
      input.data('rating', control);
      rater.data('rating', control);
      star.data('rating', control);
      context.data('rating', raters);
    }); // each element
    
    // Initialize ratings (first draw)
    $('.rating-to-be-drawn').rating('draw').removeClass('rating-to-be-drawn');
    
    return this; // don't break the chain...
  };
  
  /*--------------------------------------------------------*/
  
  /*
    ### Core functionality and API ###
  */
  $.extend($.fn.rating, {
    // Used to append a unique serial number to internal control ID
    // each time the plugin is invoked so same name controls can co-exist
    calls: 0,
    
    focus: function(){
      var control = this.data('rating');
      if(!control) return this;
      if(!control.focus) return this; // quick fail if not required
      // find data for event
      var input = $(this).data('rating.input') || $( this.tagName=='INPUT' ? this : null );
      // focus handler, as requested by focusdigital.co.uk
      if(control.focus) control.focus.apply(input[0], [input.val(), $('a', input.data('rating.star'))[0]]);
    }, // $.fn.rating.focus
    
    blur: function(){
      var control = this.data('rating');
      if(!control) return this;
      if(!control.blur) return this; // quick fail if not required
      // find data for event
      var input = $(this).data('rating.input') || $( this.tagName=='INPUT' ? this : null );
      // blur handler, as requested by focusdigital.co.uk
      if(control.blur) control.blur.apply(input[0], [input.val(), $('a', input.data('rating.star'))[0]]);
    }, // $.fn.rating.blur
    
    fill: function(){ // fill to the current mouse position.
      var control = this.data('rating');
      if(!control) return this;
      // do not execute when control is in read-only mode
      if(control.readOnly) return;
      // Reset all stars and highlight them up to this element
      this.rating('drain');
      this.prevAll().andSelf().filter('.rater-'+ control.serial).addClass('wgt-rating-hover');
    },// $.fn.rating.fill
    
    drain: function() { // drain all the stars.
      var control = this.data('rating');
      if(!control) return this;
      // do not execute when control is in read-only mode
      if(control.readOnly) return;
      // Reset all stars
      control.rater.children().filter('.rater-'+ control.serial).removeClass('wgt-rating-on').removeClass('wgt-rating-hover');
    },// $.fn.rating.drain
    
    draw: function(){ // set value and stars to reflect current selection
      var control = this.data('rating');
      if(!control) 
        return this;
      // Clear all stars
      this.rating('drain');
      // Set control value
      if(control.current){
        control.current.data('rating.input').attr('checked','checked');
        control.current.prevAll().andSelf().filter('.rater-'+ control.serial).addClass('wgt-rating-on');
      }
      else
        $(control.inputs).removeAttr('checked');
      // Show/hide 'cancel' button
      control.cancel[control.readOnly || control.required?'hide':'show']();
      // Add/remove read-only classes to remove hand pointer
      this.siblings()[control.readOnly?'addClass':'removeClass']('wgt-rating-readonly');
    },// $.fn.rating.draw
    
    
    
    
    
    select: function(value,wantCallBack){ // select a value
          
      // ***** MODIFICATION *****
      // Thanks to faivre.thomas - http://code.google.com/p/jquery-wgt-rating-plugin/issues/detail?id=27
      //
      // ***** LIST OF MODIFICATION *****
      // ***** added Parameter wantCallBack : false if you don't want a callback. true or undefined if you want postback to be performed at the end of this method'
      // ***** recursive calls to this method were like : ... .rating('select') it's now like .rating('select',undefined,wantCallBack); (parameters are set.)
      // ***** line which is calling callback
      // ***** /LIST OF MODIFICATION *****
      
      var control = this.data('rating');
      if(!control) return this;
      // do not execute when control is in read-only mode
      if(control.readOnly) 
        return;
      // clear selection
      control.current = null;
      // programmatically (based on user input)
      if(typeof value!='undefined'){
        // select by index (0 based)
        if(typeof value=='number')
          return $(control.stars[value]).rating('select',undefined,wantCallBack);
        // select by literal value (must be passed as a string
        if(typeof value=='string')
          //return
          $.each(control.stars, function(){
            if($(this).data('rating.input').val()==value) $(this).rating('select',undefined,wantCallBack);
          });
      }
      else
        control.current = this[0].tagName=='INPUT' ?
        this.data('rating.star') :
        (this.is('.rater-'+ control.serial) ? this : null);

      // Update rating control state
      this.data('rating', control);
      // Update display
      this.rating('draw');
      // find data for event
      var input = $( control.current ? control.current.data('rating.input') : null );
      // click callback, as requested here: http://plugins.jquery.com/node/1655
          
      // **** MODIFICATION *****
      // Thanks to faivre.thomas - http://code.google.com/p/jquery-wgt-rating-plugin/issues/detail?id=27
      //
      //old line doing the callback :
      //if(control.callback) control.callback.apply(input[0], [input.val(), $('a', control.current)[0]]);// callback event
      //
      //new line doing the callback (if i want :)
      if((wantCallBack ||wantCallBack == undefined) && control.callback) control.callback.apply(input[0], [input.val(), $('a', control.current)[0]]);// callback event
    //to ensure retro-compatibility, wantCallBack must be considered as true by default
    // **** /MODIFICATION *****
          
    },// $.fn.rating.select
    
    
    
    
    
    readOnly: function(toggle, disable){ // make the control read-only (still submits value)
      var control = this.data('rating');
      if(!control) return this;
      // setread-only status
      control.readOnly = toggle || toggle==undefined ? true : false;
      // enable/disable control value submission
      if(disable) $(control.inputs).attr("disabled", "disabled");
      else           $(control.inputs).removeAttr("disabled");
      // Update rating control state
      this.data('rating', control);
      // Update display
      this.rating('draw');
    },// $.fn.rating.readOnly
    
    disable: function(){ // make read-only and never submit value
      this.rating('readOnly', true, true);
    },// $.fn.rating.disable
    
    enable: function(){ // make read/write and submit value
      this.rating('readOnly', false, false);
    }// $.fn.rating.select
    
  });

  /*--------------------------------------------------------*/
  
  /*
       ### Default Settings ###
       eg.: You can override default control like this:
       $.fn.rating.options.cancel = 'Clear';
  */
  $.fn.rating.options = { //$.extend($.fn.rating, { options: {
    cancel: 'Cancel Rating',   // advisory title for the 'cancel' link
    cancelValue: '',           // value to submit when user click the 'cancel' link
    split: 0,                  // split the star into how many parts?
      
    // Width of star image in case the plugin can't work it out. This can happen if
    // the jQuery.dimensions plugin is not available OR the image is hidden at installation
    starWidth: 16//,
      
  //NB.: These don't need to be pre-defined (can be undefined/null) so let's save some code!
  //half:     false,         // just a shortcut to control.split = 2
  //required: false,         // disables the 'cancel' button so user can only select one of the specified values
  //readOnly: false,         // disable rating plugin interaction/ values cannot be changed
  //focus:    function(){},  // executed when stars are focused
  //blur:     function(){},  // executed when stars are focused
  //callback: function(){},  // executed when a star is clicked
  }; //} });

})(jQuery);


/**
 *
 * Color picker
 * Author: Stefan Petre www.eyecon.ro
 * 
 * Dual licensed under the MIT and GPL licenses
 * 
 */
(function ($) {
  
  var ColorPicker = function () {
    var
      ids = {},
      inAction,
      charMin = 65,
      visible,
      tpl = '<div class="colorpicker"><div class="colorpicker_color"><div><div></div></div></div><div class="colorpicker_hue"><div></div></div><div class="colorpicker_new_color"></div><div class="colorpicker_current_color"></div><div class="colorpicker_hex"><input type="text" maxlength="6" size="6" /></div><div class="colorpicker_rgb_r colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_g colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_h colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_s colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_submit"></div></div>',
      defaults = {
        eventName: 'click',
        onShow: function () {},
        onBeforeShow: function(){},
        onHide: function () {},
        onChange: function () {},
        onSubmit: function () {},
        color: 'ff0000',
        livePreview: true,
        flat: false
	},
	fillRGBFields = function  (hsb, cal) {
       var rgb = HSBToRGB(hsb);
				$(cal).data('colorpicker').fields
					.eq(1).val(rgb.r).end()
					.eq(2).val(rgb.g).end()
					.eq(3).val(rgb.b).end();
			},
			fillHSBFields = function  (hsb, cal) {
				$(cal).data('colorpicker').fields
					.eq(4).val(hsb.h).end()
					.eq(5).val(hsb.s).end()
					.eq(6).val(hsb.b).end();
			},
			fillHexFields = function (hsb, cal) {
				$(cal).data('colorpicker').fields
					.eq(0).val(HSBToHex(hsb)).end();
			},
			setSelector = function (hsb, cal) {
			     $(cal).data('colorpicker').selector.css('backgroundColor', '#' + HSBToHex({h: hsb.h, s: 100, b: 100}));
				$(cal).data('colorpicker').selectorIndic.css({
				  left: parseInt(150 * hsb.s/100, 10),
				  top: parseInt(150 * (100-hsb.b)/100, 10)
				});
			},
			setHue = function (hsb, cal) {
			  $(cal).data('colorpicker').hue.css('top', parseInt(150 - 150 * hsb.h/360, 10));
			},
			setCurrentColor = function (hsb, cal) {
			  $(cal).data('colorpicker').currentColor.css('backgroundColor', '#' + HSBToHex(hsb));
			},
			setNewColor = function (hsb, cal) {
			  $(cal).data('colorpicker').newColor.css('backgroundColor', '#' + HSBToHex(hsb));
			},
			keyDown = function (ev) {
				var pressedKey = ev.charCode || ev.keyCode || -1;
				if ((pressedKey > charMin && pressedKey <= 90) || pressedKey == 32) {
					return false;
				}
				var cal = $(this).parent().parent();
				if (cal.data('colorpicker').livePreview === true) {
					change.apply(this);
				}
				
				return true;
			},
			change = function (ev) {
				var cal = $(this).parent().parent(), col;
				if (this.parentNode.className.indexOf('_hex') > 0) {
					cal.data('colorpicker').color = col = HexToHSB(fixHex(this.value));
				} else if (this.parentNode.className.indexOf('_hsb') > 0) {
					cal.data('colorpicker').color = col = fixHSB({
						h: parseInt(cal.data('colorpicker').fields.eq(4).val(), 10),
						s: parseInt(cal.data('colorpicker').fields.eq(5).val(), 10),
						b: parseInt(cal.data('colorpicker').fields.eq(6).val(), 10)
					});
				} else {
					cal.data('colorpicker').color = col = RGBToHSB(fixRGB({
						r: parseInt(cal.data('colorpicker').fields.eq(1).val(), 10),
						g: parseInt(cal.data('colorpicker').fields.eq(2).val(), 10),
						b: parseInt(cal.data('colorpicker').fields.eq(3).val(), 10)
					}));
				}
				if (ev) {
					fillRGBFields(col, cal.get(0));
					fillHexFields(col, cal.get(0));
					fillHSBFields(col, cal.get(0));
				}
				setSelector(col, cal.get(0));
				setHue(col, cal.get(0));
				setNewColor(col, cal.get(0));
				cal.data('colorpicker').onChange.apply(cal, [col, HSBToHex(col), HSBToRGB(col)]);
			},
			blur = function (ev) {
				var cal = $(this).parent().parent();
				cal.data('colorpicker').fields.parent().removeClass('colorpicker_focus');
			},
			focus = function () {
				charMin = this.parentNode.className.indexOf('_hex') > 0 ? 70 : 65;
				$(this).parent().parent().data('colorpicker').fields.parent().removeClass('colorpicker_focus');
				$(this).parent().addClass('colorpicker_focus');
			},
			downIncrement = function (ev) {
				var field = $(this).parent().find('input').focus();
				var current = {
					el: $(this).parent().addClass('colorpicker_slider'),
					max: this.parentNode.className.indexOf('_hsb_h') > 0 ? 360 : (this.parentNode.className.indexOf('_hsb') > 0 ? 100 : 255),
					y: ev.pageY,
					field: field,
					val: parseInt(field.val(), 10),
					preview: $(this).parent().parent().data('colorpicker').livePreview					
				};
				$(document).bind('mouseup', current, upIncrement);
				$(document).bind('mousemove', current, moveIncrement);
			},
			moveIncrement = function (ev) {
				ev.data.field.val(Math.max(0, Math.min(ev.data.max, parseInt(ev.data.val + ev.pageY - ev.data.y, 10))));
				if (ev.data.preview) {
					change.apply(ev.data.field.get(0), [true]);
				}
				return false;
			},
			upIncrement = function (ev) {
				change.apply(ev.data.field.get(0), [true]);
				ev.data.el.removeClass('colorpicker_slider').find('input').focus();
				$(document).unbind('mouseup', upIncrement);
				$(document).unbind('mousemove', moveIncrement);
				return false;
			},
			downHue = function (ev) {
				var current = {
					cal: $(this).parent(),
					y: $(this).offset().top
				};
				current.preview = current.cal.data('colorpicker').livePreview;
				$(document).bind('mouseup', current, upHue);
				$(document).bind('mousemove', current, moveHue);
			},
			moveHue = function (ev) {
				change.apply(
					ev.data.cal.data('colorpicker')
						.fields
						.eq(4)
						.val(parseInt(360*(150 - Math.max(0,Math.min(150,(ev.pageY - ev.data.y))))/150, 10))
						.get(0),
					[ev.data.preview]
				);
				return false;
			},
			upHue = function (ev) {
				fillRGBFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				fillHexFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				$(document).unbind('mouseup', upHue);
				$(document).unbind('mousemove', moveHue);
				return false;
			},
			downSelector = function (ev) {
				var current = {
					cal: $(this).parent(),
					pos: $(this).offset()
				};
				current.preview = current.cal.data('colorpicker').livePreview;
				$(document).bind('mouseup', current, upSelector);
				$(document).bind('mousemove', current, moveSelector);
			},
			moveSelector = function (ev) {
				change.apply(
					ev.data.cal.data('colorpicker')
						.fields
						.eq(6)
						.val(parseInt(100*(150 - Math.max(0,Math.min(150,(ev.pageY - ev.data.pos.top))))/150, 10))
						.end()
						.eq(5)
						.val(parseInt(100*(Math.max(0,Math.min(150,(ev.pageX - ev.data.pos.left))))/150, 10))
						.get(0),
					[ev.data.preview]
				);
				return false;
			},
			upSelector = function (ev) {
				fillRGBFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				fillHexFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				$(document).unbind('mouseup', upSelector);
				$(document).unbind('mousemove', moveSelector);
				return false;
			},
			enterSubmit = function (ev) {
				$(this).addClass('colorpicker_focus');
			},
			leaveSubmit = function (ev) {
				$(this).removeClass('colorpicker_focus');
			},
			clickSubmit = function (ev) {
				var cal = $(this).parent();
				var col = cal.data('colorpicker').color;
				cal.data('colorpicker').origColor = col;
				setCurrentColor(col, cal.get(0));
				cal.data('colorpicker').onSubmit(col, HSBToHex(col), HSBToRGB(col), cal.data('colorpicker').el);
			},
			show = function (ev) {
				var cal = $('#' + $(this).data('colorpickerId'));
				cal.data('colorpicker').onBeforeShow.apply(this, [cal.get(0)]);
				var pos = $(this).offset();
				var viewPort = getViewport();
				var top = pos.top + this.offsetHeight;
				var left = pos.left;
				if (top + 176 > viewPort.t + viewPort.h) {
					top -= this.offsetHeight + 176;
				}
				if (left + 356 > viewPort.l + viewPort.w) {
					left -= 356;
				}
				cal.css({left: left + 'px', top: top + 'px'});
				if (cal.data('colorpicker').onShow.apply(this, [cal.get(0)]) != false) {
					cal.show();
				}
				$(document).bind('mousedown', {cal: cal}, hide);
				return false;
			},
			hide = function (ev) {
				if (!isChildOf(ev.data.cal.get(0), ev.target, ev.data.cal.get(0))) {
					if (ev.data.cal.data('colorpicker').onHide.apply(this, [ev.data.cal.get(0)]) != false) {
						ev.data.cal.hide();
					}
					$(document).unbind('mousedown', hide);
				}
			},
			isChildOf = function(parentEl, el, container) {
				if (parentEl == el) {
					return true;
				}
				if (parentEl.contains) {
					return parentEl.contains(el);
				}
				if ( parentEl.compareDocumentPosition ) {
					return !!(parentEl.compareDocumentPosition(el) & 16);
				}
				var prEl = el.parentNode;
				while(prEl && prEl != container) {
					if (prEl == parentEl)
						return true;
					prEl = prEl.parentNode;
				}
				return false;
			},
			getViewport = function () {
				var m = document.compatMode == 'CSS1Compat';
				return {
					l : window.pageXOffset || (m ? document.documentElement.scrollLeft : document.body.scrollLeft),
					t : window.pageYOffset || (m ? document.documentElement.scrollTop : document.body.scrollTop),
					w : window.innerWidth || (m ? document.documentElement.clientWidth : document.body.clientWidth),
					h : window.innerHeight || (m ? document.documentElement.clientHeight : document.body.clientHeight)
				};
			},
			fixHSB = function (hsb) {
				return {
					h: Math.min(360, Math.max(0, hsb.h)),
					s: Math.min(100, Math.max(0, hsb.s)),
					b: Math.min(100, Math.max(0, hsb.b))
				};
			}, 
			fixRGB = function (rgb) {
				return {
					r: Math.min(255, Math.max(0, rgb.r)),
					g: Math.min(255, Math.max(0, rgb.g)),
					b: Math.min(255, Math.max(0, rgb.b))
				};
			},
			fixHex = function (hex) {
				var len = 6 - hex.length;
				if (len > 0) {
					var o = [];
					for (var i=0; i<len; i++) {
						o.push('0');
					}
					o.push(hex);
					hex = o.join('');
				}
				return hex;
			}, 
			HexToRGB = function (hex) {
				hex = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
				return {r: hex >> 16, g: (hex & 0x00FF00) >> 8, b: (hex & 0x0000FF)};
			},
			HexToHSB = function (hex) {
				return RGBToHSB(HexToRGB(hex));
			},
			RGBToHSB = function (rgb) {
				var hsb = {
					h: 0,
					s: 0,
					b: 0
				};
				var min = Math.min(rgb.r, rgb.g, rgb.b);
				var max = Math.max(rgb.r, rgb.g, rgb.b);
				var delta = max - min;
				hsb.b = max;
				if (max != 0) {
					
				}
				hsb.s = max != 0 ? 255 * delta / max : 0;
				if (hsb.s != 0) {
					if (rgb.r == max) {
						hsb.h = (rgb.g - rgb.b) / delta;
					} else if (rgb.g == max) {
						hsb.h = 2 + (rgb.b - rgb.r) / delta;
					} else {
						hsb.h = 4 + (rgb.r - rgb.g) / delta;
					}
				} else {
					hsb.h = -1;
				}
				hsb.h *= 60;
				if (hsb.h < 0) {
					hsb.h += 360;
				}
				hsb.s *= 100/255;
				hsb.b *= 100/255;
				return hsb;
			},
			HSBToRGB = function (hsb) {
				var rgb = {};
				var h = Math.round(hsb.h);
				var s = Math.round(hsb.s*255/100);
				var v = Math.round(hsb.b*255/100);
				if(s == 0) {
					rgb.r = rgb.g = rgb.b = v;
				} else {
					var t1 = v;
					var t2 = (255-s)*v/255;
					var t3 = (t1-t2)*(h%60)/60;
					if(h==360) h = 0;
					if(h<60) {rgb.r=t1;	rgb.b=t2; rgb.g=t2+t3}
					else if(h<120) {rgb.g=t1; rgb.b=t2;	rgb.r=t1-t3}
					else if(h<180) {rgb.g=t1; rgb.r=t2;	rgb.b=t2+t3}
					else if(h<240) {rgb.b=t1; rgb.r=t2;	rgb.g=t1-t3}
					else if(h<300) {rgb.b=t1; rgb.g=t2;	rgb.r=t2+t3}
					else if(h<360) {rgb.r=t1; rgb.g=t2;	rgb.b=t1-t3}
					else {rgb.r=0; rgb.g=0;	rgb.b=0}
				}
				return {r:Math.round(rgb.r), g:Math.round(rgb.g), b:Math.round(rgb.b)};
			},
			RGBToHex = function (rgb) {
				var hex = [
					rgb.r.toString(16),
					rgb.g.toString(16),
					rgb.b.toString(16)
				];
				$.each(hex, function (nr, val) {
					if (val.length == 1) {
						hex[nr] = '0' + val;
					}
				});
				return hex.join('');
			},
			HSBToHex = function (hsb) {
				return RGBToHex(HSBToRGB(hsb));
			},
			restoreOriginal = function () {
				var cal = $(this).parent();
				var col = cal.data('colorpicker').origColor;
				cal.data('colorpicker').color = col;
				fillRGBFields(col, cal.get(0));
				fillHexFields(col, cal.get(0));
				fillHSBFields(col, cal.get(0));
				setSelector(col, cal.get(0));
				setHue(col, cal.get(0));
				setNewColor(col, cal.get(0));
			};
		return {
			init: function (opt) {
				opt = $.extend({}, defaults, opt||{});
				if (typeof opt.color == 'string') {
					opt.color = HexToHSB(opt.color);
				} else if (opt.color.r != undefined && opt.color.g != undefined && opt.color.b != undefined) {
					opt.color = RGBToHSB(opt.color);
				} else if (opt.color.h != undefined && opt.color.s != undefined && opt.color.b != undefined) {
					opt.color = fixHSB(opt.color);
				} else {
					return this;
				}
				return this.each(function () {
					if (!$(this).data('colorpickerId')) {
						var options = $.extend({}, opt);
						options.origColor = opt.color;
						var id = 'collorpicker_' + parseInt(Math.random() * 1000);
						$(this).data('colorpickerId', id);
						var cal = $(tpl).prop('id', id);
						if (options.flat) {
							cal.appendTo(this).show();
						} else {
							cal.appendTo(document.body);
						}
						options.fields = cal
											.find('input')
												.bind('keyup', keyDown)
												.bind('change', change)
												.bind('blur', blur)
												.bind('focus', focus);
						cal
							.find('span').bind('mousedown', downIncrement).end()
							.find('>div.colorpicker_current_color').bind('click', restoreOriginal);
						options.selector = cal.find('div.colorpicker_color').bind('mousedown', downSelector);
						options.selectorIndic = options.selector.find('div div');
						options.el = this;
						options.hue = cal.find('div.colorpicker_hue div');
						cal.find('div.colorpicker_hue').bind('mousedown', downHue);
						options.newColor = cal.find('div.colorpicker_new_color');
						options.currentColor = cal.find('div.colorpicker_current_color');
						cal.data('colorpicker', options);
						cal.find('div.colorpicker_submit')
							.bind('mouseenter', enterSubmit)
							.bind('mouseleave', leaveSubmit)
							.bind('click', clickSubmit);
						fillRGBFields(options.color, cal.get(0));
						fillHSBFields(options.color, cal.get(0));
						fillHexFields(options.color, cal.get(0));
						setHue(options.color, cal.get(0));
						setSelector(options.color, cal.get(0));
						setCurrentColor(options.color, cal.get(0));
						setNewColor(options.color, cal.get(0));
						if (options.flat) {
							cal.css({
								position: 'relative',
								display: 'block'
							});
						} else {
							$(this).bind(options.eventName, show);
						}
					}
				});
			},
			showPicker: function() {
				return this.each( function () {
					if ($(this).data('colorpickerId')) {
						show.apply(this);
					}
				});
			},
			hidePicker: function() {
				return this.each( function () {
					if ($(this).data('colorpickerId')) {
						$('#' + $(this).data('colorpickerId')).hide();
					}
				});
			},
			setColor: function(col) {
				if (typeof col == 'string') {
					col = HexToHSB(col);
				} else if (col.r != undefined && col.g != undefined && col.b != undefined) {
					col = RGBToHSB(col);
				} else if (col.h != undefined && col.s != undefined && col.b != undefined) {
					col = fixHSB(col);
				} else {
					return this;
				}
				return this.each(function(){
					if ($(this).data('colorpickerId')) {
						var cal = $('#' + $(this).data('colorpickerId'));
						cal.data('colorpicker').color = col;
						cal.data('colorpicker').origColor = col;
						fillRGBFields(col, cal.get(0));
						fillHSBFields(col, cal.get(0));
						fillHexFields(col, cal.get(0));
						setHue(col, cal.get(0));
						setSelector(col, cal.get(0));
						setCurrentColor(col, cal.get(0));
						setNewColor(col, cal.get(0));
					}
				});
			}
		};
	}();
     $.fn.extend({
		ColorPicker: ColorPicker.init,
		ColorPickerHide: ColorPicker.hidePicker,
		ColorPickerShow: ColorPicker.showPicker,
		ColorPickerSetColor: ColorPicker.setColor
	});
})(jQuery);
$S(document).ready(function() {
	
	// Expand Panel
	$S(".open").click(function(){
		$S("div.panel").slideDown("slow");
	
	});	
	
	// Collapse Panel
	$S(".close").click(function(){
		$S("div.panel").slideUp("slow");	
	});		
	
	// Switch buttons from "Log In | Register" to "Close Panel" on click
	$S(".toggle a").click(function () {
		$S(".toggle a").toggle();
	});		
		
});
// jQuery Context Menu Plugin
//
// Version 1.01
//
// Cory S.N. LaViska
// A Beautiful Site (http://abeautifulsite.net/)
//
// More info: http://abeautifulsite.net/2008/09/jquery-context-menu-plugin/
//
// Terms of Use
//
// This plugin is dual-licensed under the GNU General Public License
//   and the MIT License and is copyright A Beautiful Site, LLC.
//
if(jQuery)( function($) {
  $.extend($.fn, {
    
    contextMenu: function( o, callback, displayActions ) {
      
      // Defaults
      if( o.menu == undefined ) return false;
      if( o.inSpeed == undefined ) o.inSpeed = 150;
      if( o.outSpeed == undefined ) o.outSpeed = 75;
      // 0 needs to be -1 for expected results (no fade)
      if( o.inSpeed == 0 ) o.inSpeed = -1;
      if( o.outSpeed == 0 ) o.outSpeed = -1;

      var $doc = $(document);
      
      // Loop each context menu
      $(this).each( function() {
    	  
        var el = $(this);
        var offset = $(el).offset();
        // Add contextMenu class
        var menu = $('#' + o.menu);
        
        menu.addClass('wgt-context_menu');
        
        // Simulate a true right click
        $(this).mousedown( function(e) {
          var evt = e;
          evt.stopPropagation();
          $(this).mouseup( function(e) {
            e.stopPropagation();
            var srcElement = $(this);
            $(this).unbind('mouseup');
            if( evt.button == 2 ) {
              // Hide context menus that may be showing
              $(".wgt-context_menu").hide();

              if( $(el).hasClass('disabled') )
                return false;
              
              // Detect mouse position
              var d = {}, x, y;
              if( self.innerHeight ) {
                d.pageYOffset = self.pageYOffset;
                d.pageXOffset = self.pageXOffset;
                d.innerHeight = self.innerHeight;
                d.innerWidth = self.innerWidth;
              } else if( document.documentElement &&
                document.documentElement.clientHeight ) {
                d.pageYOffset = document.documentElement.scrollTop;
                d.pageXOffset = document.documentElement.scrollLeft;
                d.innerHeight = document.documentElement.clientHeight;
                d.innerWidth = document.documentElement.clientWidth;
              } else if( document.body ) {
                d.pageYOffset = document.body.scrollTop;
                d.pageXOffset = document.body.scrollLeft;
                d.innerHeight = document.body.clientHeight;
                d.innerWidth = document.body.clientWidth;
              }
              (e.pageX) ? x = e.pageX : x = e.clientX + d.scrollLeft;
              (e.pageY) ? y = e.pageY : y = e.clientY + d.scrollTop;
              
              // Show the menu
              $doc.unbind('click');
              menu.css({ top: y, left: x }).fadeIn(o.inSpeed);
              // Hover events
              menu.find('A').mouseover( function() {
                menu.find('LI.hover').removeClass('hover');
                $(this).parent().addClass('hover');
              }).mouseout( function() {
                menu.find('LI.hover').removeClass('hover');
              });
              
              // Keyboard
              $doc.keypress( function(e) {
                switch( e.keyCode ) {
                  case 38: // up
                    if( menu.find('LI.hover').size() == 0 ) {
                      menu.find('LI:last').addClass('hover');
                    } else {
                      menu.find('LI.hover').removeClass('hover').prevAll('LI:not(.disabled)').eq(0).addClass('hover');
                      if( menu.find('LI.hover').size() == 0 ) menu.find('LI:last').addClass('hover');
                    }
                  break;
                  case 40: // down
                    if( menu.find('LI.hover').size() == 0 ) {
                      menu.find('LI:first').addClass('hover');
                    } else {
                      menu.find('LI.hover').removeClass('hover').nextAll('LI:not(.disabled)').eq(0).addClass('hover');
                      if( menu.find('LI.hover').size() == 0 ) menu.find('LI:first').addClass('hover');
                    }
                  break;
                  case 13: // enter
                    menu.find('LI.hover A').trigger('click');
                  break;
                  case 27: // esc
                    $doc.trigger('click');
                  break
                }
              });
              
              // When items are selected
              $('#' + o.menu).find('A').unbind('click');
              $('#' + o.menu).find('LI:not(.disabled) A').click( function() {
                $doc.unbind('click').unbind('keypress');
                $(".wgt-context_menu").hide();
                // Callback
                if( callback ) callback( $(this).prop('href').substr(1), $(srcElement), {x: x - offset.left, y: y - offset.top, docX: x, docY: y} );
                return false;
              });
              
              // Hide bindings
              setTimeout( function() { // Delay for Mozilla
                $doc.click( function() {
                  $doc.unbind('click').unbind('keypress');
                  menu.fadeOut(o.outSpeed);
                  return false;
                });
              }, 0);
            }
            
            return false;
          });

        });

        
        // Disable text selection
        if( $.browser.mozilla ) {
          $('#' + o.menu).each( function() { $(this).css({ 'MozUserSelect' : 'none' }); });
        } else if( $.browser.msie ) {
          $('#' + o.menu).each( function() { $(this).bind('selectstart.disableTextSelect', function() { return false; }); });
        } else {
          $('#' + o.menu).each(function() { $(this).bind('mousedown.disableTextSelect', function() { return false; }); });
        }
        // Disable browser context menu (requires both selectors to work in IE/Safari + FF/Chrome)
        $(el).add($('UL.wgt-context_menu')).bind('contextmenu', function() { return false; });
        
        if( displayActions ){
          menu.hideContextMenuItems( );
          menu.showContextMenuItems( displayActions, '#' );
        }
        
      });
      
      return $(this);
    },
    
    // Disable context menu items on the fly
    disableContextMenuItems: function(o) {
      if( o == undefined ) {
        // Disable all
        $(this).find('LI').addClass('disabled');
        return( $(this) );
      }
      $(this).each( function() {
        if( o != undefined ) {
          var d = o.split(',');
          for( var i = 0; i < d.length; i++ ) {
            $(this).find('A[href="' + d[i] + '"]').parent().addClass('disabled');
            
          }
        }
      });
      return( $(this) );
    },
    
    // Enable context menu items on the fly
    enableContextMenuItems: function(o) {
      if( o == undefined ) {
        // Enable all
        $(this).find('LI.disabled').removeClass('disabled');
        return( $(this) );
      }
      $(this).each( function() {
        if( o != undefined ) {
          var d = o.split(',');
          for( var i = 0; i < d.length; i++ ) {
            $(this).find('A[href="' + d[i] + '"]').parent().removeClass('disabled');
            
          }
        }
      });
      return( $(this) );
    },

    // Hide context menu items on the fly
    hideContextMenuItems: function(o, prep) {
    	
      
    	
      if( o == undefined ) {
        // Hide all
        $(this).find('LI').hide();
        return( $(this) );
      }
      $(this).each( function() {
        if( o != undefined ) {
          var d = o.split(',');
          for( var i = 0; i < d.length; i++ ) {
            $(this).find('A[href="' + d[i] + '"]').parent().hide();
            
          }
        }
      });
      return( $(this) );
    },
    
    // Show context menu items on the fly
    showContextMenuItems: function(o, prep ) {

      if( prep === undefined ){
        prep = '';
      }

      if( o == undefined ) {
        // Enable all
        $(this).find('LI.disabled').show();
        return( $(this) );
      }
      $(this).each( function() {
        if( o != undefined ) {
          var d = o.split(',');
          for( var i = 0; i < d.length; i++ ) {
            $(this).find('A[href="' + prep + d[i] + '"]').parent().show();
            
          }
        }
      });
      return( $(this) );
    },
    
    // Disable context menu(s)
    disableContextMenu: function() {
      $(this).each( function() {
        $(this).addClass('disabled');
      });
      return( $(this) );
    },
    
    // Enable context menu(s)
    enableContextMenu: function() {
      $(this).each( function() {
        $(this).removeClass('disabled');
      });
      return( $(this) );
    },
    
    // Destroy context menu(s)
    destroyContextMenu: function() {
      // Destroy specified context menus
      $(this).each( function() {
        // Disable action
        $(this).unbind('mousedown').unbind('mouseup');
      });
      return( $(this) );
    }
    
  });
})(jQuery);
/**
* hoverIntent is similar to jQuery's built-in "hover" function except that
* instead of firing the onMouseOver event immediately, hoverIntent checks
* to see if the user's mouse has slowed down (beneath the sensitivity
* threshold) before firing the onMouseOver event.
* 
* hoverIntent r6 // 2011.02.26 // jQuery 1.5.1+
* <http://cherne.net/brian/resources/jquery.hoverIntent.html>
* 
* hoverIntent is currently available for use in all personal or commercial 
* projects under both MIT and GPL licenses. This means that you can choose 
* the license that best suits your project, and use it accordingly.
* 
* // basic usage (just like .hover) receives onMouseOver and onMouseOut functions
* $("ul li").hoverIntent( showNav , hideNav );
* 
* // advanced usage receives configuration object only
* $("ul li").hoverIntent({
*	sensitivity: 7, // number = sensitivity threshold (must be 1 or higher)
*	interval: 100,   // number = milliseconds of polling interval
*	over: showNav,  // function = onMouseOver callback (required)
*	timeout: 0,   // number = milliseconds delay before onMouseOut function call
*	out: hideNav    // function = onMouseOut callback (required)
* });
* 
* @param  f  onMouseOver function || An object with configuration options
* @param  g  onMouseOut function  || Nothing (use configuration options object)
* @author    Brian Cherne brian(at)cherne(dot)net
*/
(function($) {
	$.fn.hoverIntent = function(f,g) {
		// default configuration options
		var cfg = {
			sensitivity: 7,
			interval: 100,
			timeout: 0
		};
		// override configuration options with user supplied object
		cfg = $.extend(cfg, g ? { over: f, out: g } : f );

		// instantiate variables
		// cX, cY = current X and Y position of mouse, updated by mousemove event
		// pX, pY = previous X and Y position of mouse, set by mouseover and polling interval
		var cX, cY, pX, pY;

		// A private function for getting mouse position
		var track = function(ev) {
			cX = ev.pageX;
			cY = ev.pageY;
		};

		// A private function for comparing current and previous mouse position
		var compare = function(ev,ob) {
			ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
			// compare mouse positions to see if they've crossed the threshold
			if ( ( Math.abs(pX-cX) + Math.abs(pY-cY) ) < cfg.sensitivity ) {
				$(ob).unbind("mousemove",track);
				// set hoverIntent state to true (so mouseOut can be called)
				ob.hoverIntent_s = 1;
				return cfg.over.apply(ob,[ev]);
			} else {
				// set previous coordinates for next time
				pX = cX; pY = cY;
				// use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)
				ob.hoverIntent_t = setTimeout( function(){compare(ev, ob);} , cfg.interval );
			}
		};

		// A private function for delaying the mouseOut function
		var delay = function(ev,ob) {
			ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
			ob.hoverIntent_s = 0;
			return cfg.out.apply(ob,[ev]);
		};

		// A private function for handling mouse 'hovering'
		var handleHover = function(e) {
			// copy objects to be passed into t (required for event object to be passed in IE)
			var ev = jQuery.extend({},e);
			var ob = this;

			// cancel hoverIntent timer if it exists
			if (ob.hoverIntent_t) { ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t); }

			// if e.type == "mouseenter"
			if (e.type == "mouseenter") {
				// set "previous" X and Y position based on initial entry point
				pX = ev.pageX; pY = ev.pageY;
				// update "current" X and Y position based on mousemove
				$(ob).bind("mousemove",track);
				// start polling interval (self-calling timeout) to compare mouse coordinates over time
				if (ob.hoverIntent_s != 1) { ob.hoverIntent_t = setTimeout( function(){compare(ev,ob);} , cfg.interval );}

			// else e.type == "mouseleave"
			} else {
				// unbind expensive mousemove event
				$(ob).unbind("mousemove",track);
				// if hoverIntent state is true, then call the mouseOut function after the specified delay
				if (ob.hoverIntent_s == 1) { ob.hoverIntent_t = setTimeout( function(){delay(ev,ob);} , cfg.timeout );}
			}
		};

		// bind the function to the two event listeners
		return this.bind('mouseenter',handleHover).bind('mouseleave',handleHover);
	};
})(jQuery);
/*
 * DC Mega Menu - jQuery mega menu
 * Copyright (c) 2011 Design Chemical
 *
 * Dual licensed under the MIT and GPL licenses:
 * 	http://www.opensource.org/licenses/mit-license.php
 * 	http://www.gnu.org/licenses/gpl.html
 *
 */
(function($){

  //define the defaults for the plugin and how to call it
  $.fn.wgtMegaMenu = function(options){
    //set default options
    var defaults = {
      classParent: 'wgt-mega-menu',
      classContainer: 'sub-container',
      classSubParent: 'mega-hdr',
      classSubLink: 'mega-hdr',
      classWidget: 'wgt-extra',
      rowItems: 3,
      speed: 'fast',
      effect: 'fade',
      event: 'hover',
      fullWidth: false,
      onLoad : function(){},
      beforeOpen : function(){},
      beforeClose: function(){}
    };

    //call in the default otions
    var options = $.extend(defaults, options);
    var $wgtMegaMenuObj = this;

    //act upon the element that is passed into the design
    return $wgtMegaMenuObj.each(function(options){

      var clSubParent = defaults.classSubParent;
      var clSubLink = defaults.classSubLink;
      var clParent = defaults.classParent;
      var clContainer = defaults.classContainer;
      var clWidget = defaults.classWidget;
			
      megaSetup();
			
      function megaOver(){

        var subNav = $('.subcnt',this);
        
        $(this).addClass('mega-hover');
          
        $(subNav).show();
        
        // schliesen des Menüs nach dem Request
        
        var closeMega = function( key ){
          if( 'mega_menu' !== key  )
            megaReset();
        };
        
        $D.requestCloseMenu( 'mega_menu' );
          
        $D.requestCloseMenu = closeMega;
        /*
        if(defaults.effect == 'fade'){
          $(subNav).fadeIn(defaults.speed);
        }
        if(defaults.effect == 'slide'){
          $(subNav).show(defaults.speed);
        }
        */
        // beforeOpen callback;
        defaults.beforeOpen.call(this);
      }

      function megaAction(obj){

        var subNav = $('.subcnt',obj);
        //$('.mega-hover').removeClass('mega-hover');
        $(obj).addClass('mega-hover');
        if(defaults.effect == 'fade'){
          $(subNav).fadeIn(defaults.speed);
        }
        else if(defaults.effect == 'slide'){
          $(subNav).show(defaults.speed);
        }
        // beforeOpen callback;
        defaults.beforeOpen.call(this);
      }

      function megaOut(){

        var subNav = $('.subcnt',this);
        $(this).removeClass('mega-hover');
        $(subNav).hide();
        // beforeClose callback;
        defaults.beforeClose.call(this);
      }

      function megaActionClose(obj){

        var subNav = $('.subcnt',obj);
        $(obj).removeClass('mega-hover');
        $(subNav).hide();
        // beforeClose callback;
        defaults.beforeClose.call(this);
      }

      function megaReset(){

        $('li',$wgtMegaMenuObj).removeClass('mega-hover');
        $('.subcnt',$wgtMegaMenuObj).hide();
      }

      function megaSetup(){

        var $arrow = '<span class="wgt-mega-menu-icon"></span>';
        var clParentLi = clParent+'-li';
        var menuWidth = $wgtMegaMenuObj.outerWidth();
 		
        $('> li',$wgtMegaMenuObj).each(function(){

          var actLi = $(this);

          if( actLi.hasClass( 'custom' ) ){

            var $mainSub = $('.subcnt',this);
            $('.subcnt',this).wrap('<div class="'+clContainer+'" />');
            
            var pos = $(this).position();
            var pl = pos.left;
            var iw = $('.subcnt',this).outerWidth(true);
              
            var newPos = pl - (iw/2);
            if( newPos < 0 )
              newPos = 0;

            $('.'+clContainer,this).css('left', newPos+'px');
            
          }
          else{

            //Set Width of sub
            var $mainSub = $('> ul',this);
            var $primaryLink = $('> a,> p',this);

            if( $mainSub.length ){

              $primaryLink.addClass(clParent).append($arrow);
              $mainSub.addClass('sub').addClass('subcnt').wrap('<div class="'+clContainer+'" />');

              var pos = $(this).position();
              var pl  = pos.left;

              if($('ul',$mainSub).length){

                $(this).addClass(clParentLi);
                $('.'+clContainer,this).addClass('mega');

                $('> li',$mainSub).each(function(){

                  if( !$(this).hasClass(clWidget) ){

                    $(this).addClass('mega-unit');

                    if( $('> ul',this).length ){

                      $(this).addClass(clSubParent);
                      $('> a,> p',this).addClass(clSubParent+'-a');
                    }
                    else {

                      $(this).addClass(clSubLink);
                      $('> a,> p',this).addClass(clSubLink+'-a');
                    }

                  }
                }); //end $('> li',$mainSub).each(function(){

                // Create Rows
                var hdrs    = $('.mega-unit',this);
                var rowSize = parseInt(defaults.rowItems);

                for(var i = 0; i < hdrs.length; i+=rowSize){
                  hdrs.slice(i, i+rowSize).wrapAll('<div class="row" />');
                }

              }

              // Get Sub Dimensions & Set Row Height
              $mainSub.show();
							
              // Get Position of Parent Item
              var pw = $(this).width();
              var pr = pl + pw;
							
              // Check available right margin
              var mr = menuWidth - pr;
							
              // // Calc Width of Sub Menu
              var subw = $mainSub.outerWidth();
              var totw = $mainSub.parent('.'+clContainer).outerWidth();
              var cpad = totw - subw;
							
              if( defaults.fullWidth == true ){
                var fw = menuWidth - cpad;
                $mainSub.parent('.'+clContainer).css({
                  width: fw+'px'
                });
                $wgtMegaMenuObj.addClass('full-width');
              }

              var iw = $('.mega-unit',$mainSub).outerWidth(true);
              var rowItems = $('.row:eq(0) .mega-unit',$mainSub).length;
              var inneriw = iw * rowItems;
              var totiw = inneriw + cpad;
							
              // Set mega header height
              $('.row',this).each(function(){
                $('.mega-unit:last',this).addClass('last');
                var maxValue = undefined;
                $('.mega-unit > a,.mega-unit > p',this).each(function(){
                  var val = parseInt($(this).height());
                  if (maxValue === undefined || maxValue < val){
                    maxValue = val;
                  }
                });
                $('.mega-unit > a,.mega-unit > p',this).css('height',maxValue+'px');
                $(this).css('width',inneriw+'px');
              });
							
              // Calc Required Left Margin incl additional required for right align
							
              if(defaults.fullWidth == true){
                params = {
                  left: 0
                };
              }
              else {
								
                var ml = mr < ml ? ml + ml - mr : (totiw - pw)/2;
                var subLeft = pl - ml;

                // If Left Position Is Negative Set To Left Margin
                var params = {
                  left: pl+'px',
                  marginLeft: -ml+'px'
                  };
								
                if(subLeft < 0){
                  params = {
                    left: 0
                  };
                }else if(mr < ml){
                  params = {
                    right: 0
                  };
                }
              }
              $('.'+clContainer,this).css(params);
							
              // Calculate Row Height
              $('.row',$mainSub).each(function(){
                var rh = $(this).height();
                $('.mega-unit',this).css({
                  height: rh+'px'
                });
                $(this).parent('.row').css({
                  height: rh+'px'
                });
              });
              $mainSub.hide();
					
            }
            else {
							
              $('.'+clContainer,this).addClass('non-mega').css('left',pl+'px');
            }

          }

          
        });
        
        // Set position of mega dropdown to bottom of main menu
        var menuHeight = $('> li > a,> li > p',$wgtMegaMenuObj).outerHeight(true);
        $('.'+clContainer,$wgtMegaMenuObj).css({
          top: menuHeight+'px'
        }).css('z-index','1000');
				
        if(defaults.event == 'hover'){
          // HoverIntent Configuration
          var config = {
            sensitivity: 1,
            interval: 100,
            over: megaOver,
            timeout: 100,
            out: megaOut
          };
          $('li',$wgtMegaMenuObj).hoverIntent(config);
        }
				
        if(defaults.event == 'click'){
				
          $('body').mouseup(function(e){
            if(!$(e.target).parents('.mega-hover').length){
              megaReset();
            }
          });

          $('> li > a.'+clParent+',> li > p.'+clParent,$wgtMegaMenuObj).click(function(e){
            var $parentLi = $(this).parent();
            if($parentLi.hasClass('mega-hover')){
              megaActionClose($parentLi);
            } else {
              megaAction($parentLi);
            }
            e.preventDefault();
          });
        }
				
        // onLoad callback;
        defaults.onLoad.call(this);
      }
    });
  };
})(jQuery);
/*
 * DC Vertical Mega Menu - jQuery vertical mega menu
 * Copyright (c) 2011 Design Chemical
 *
 * Dual licensed under the MIT and GPL licenses:
 * 	http://www.opensource.org/licenses/mit-license.php
 * 	http://www.gnu.org/licenses/gpl.html
 *
 */
(function($){

  //define the new for the plugin ans how to call it
  $.fn.vertMegaMenu = function(options){
    //set default options
    var defaults = {
      classParent: 'wgt-vert-mega-menu',
      arrow: true,
      classArrow: 'wgt-mega-icon',
      classContainer: 'sub-container',
      classSubMenu: 'sub',
      classMega: 'mega',
      classSubParent: 'mega-hdr',
      classSubLink: 'mega-hdr',
      classRow: 'row',
      rowItems: 3,
      speed: 'fast',
      effect: 'show',
      direction: 'right'
    };

    //call in the default otions
    var options = $.extend(defaults, options);
    var $vertMegaMenuObj = this;

    //act upon the element that is passed into the design
    return $vertMegaMenuObj.each(function(options){

      var $mega = $(this);
      if(defaults.direction == 'left'){
        $mega.addClass('d-left');
      } else {
        $mega.addClass('d-right');
      }
      // Get Menu Width
      var megaWidth = $mega.width();
			
      // Set up menu
      $('> li',$mega).each(function(){
				
        var $parent = $(this);
        var $megaSub = $('> ul',$parent);
	
        if($megaSub.length > 0){
					
          $('> a',$parent).addClass(defaults.classParent).append('<span class="'+defaults.classArrow+'"></span>');
          $megaSub.addClass(defaults.classSubMenu).wrap('<div class="'+defaults.classContainer+'" />');
          var $container = $('.'+defaults.classContainer,$parent);
					
          if($('ul',$megaSub).length > 0){
						
            $parent.addClass(defaults.classParent+'-li');
            $container.addClass(defaults.classMega);
						
            // Set sub headers
            $('> li',$megaSub).each(function(){
              $(this).addClass('mega-unit');
              if($('> ul',this).length){
                $(this).addClass(defaults.classSubParent);
                $('> a',this).addClass(defaults.classSubParent+'-a');
              } else {
                $(this).addClass(defaults.classSubLink);
                $('> a',this).addClass(defaults.classSubLink+'-a');
              }
            });
						
            // Create Rows
            var hdrs = $('.mega-unit',$parent);
            var rowSize = parseInt(defaults.rowItems);
            for(var i = 0; i < hdrs.length; i+=rowSize){
              hdrs.slice(i, i+rowSize).wrapAll('<div class="'+defaults.classRow+'" />');
            }

            // Get mega dimensions
            var itemWidth = $('.mega-unit',$megaSub).outerWidth(true);
            var rowItems = $('.row:eq(0) .mega-unit',$megaSub).length;
            var innerItemWidth = itemWidth * rowItems;
            var totalItemWidth = innerItemWidth + containerPad;

            // Set mega header height
            $('.row',this).each(function(){
              $('.mega-unit:last',this).addClass('last');
              var maxValue = undefined;
              $('.mega-unit > a',this).each(function(){
                var val = parseInt($(this).height());
                if (maxValue === undefined || maxValue < val){
                  maxValue = val;
                }
              });
              $('.mega-unit > a',this).css('height',maxValue+'px');
              $(this).css('width',innerItemWidth+'px');
            });
            var subWidth = $megaSub.outerWidth(true);
            var totalWidth = $container.outerWidth(true);
            var containerPad = totalWidth - subWidth;
            // Calculate Row Height
            $('.row',$megaSub).each(function(){
              var rowHeight = $(this).height();
              $(this).parent('.row').css('height',rowHeight+'px');
            });
            $('.row:last',$megaSub).addClass('last');
            $('.row:first',$megaSub).addClass('first');
          } else {
            $container.addClass('non-'+defaults.classMega);
          }
        }
			
        var $container = $('.'+defaults.classContainer,$parent);
        var subWidth = $megaSub.outerWidth(true);
        // Get flyout height
        var subHeight = $container.height();
        var itemHeight = $parent.outerHeight(true);
        // Set position to top of parent
        $container.css({
          height: subHeight+'px',
          marginTop: -itemHeight+'px',
          zIndex: '1000',
          width: subWidth+'px'
        }).hide();
      });

      // HoverIntent Configuration
      var config = {
        sensitivity: 2, // number = sensitivity threshold (must be 1 or higher)
        interval: 100, // number = milliseconds for onMouseOver polling interval
        over: megaOver, // function = onMouseOver callback (REQUIRED)
        timeout: 0, // number = milliseconds delay before onMouseOut
        out: megaOut // function = onMouseOut callback (REQUIRED)
      };
			
      $('li',$vertMegaMenuObj).hoverIntent(config);
				
      function megaOver(){
        $(this).addClass('mega-hover');
        var $link = $('> a',this);
        var $subNav = $('.sub',this);
        var $container = $('.sub-container',this);
        var width = $container.width();
        var outerHeight = $container.outerHeight();
        var height = $container.height();
        var itemHeight = $(this).outerHeight(true);
        var offset = $link.offset();
        var scrollTop = $(window).scrollTop();
        offset = offset.top - scrollTop;
        var bodyHeight = $(window).height();
        var maxHeight = bodyHeight - offset;
        var xsHeight = maxHeight - outerHeight;
			
        if(xsHeight < 0){
          var containerMargin = xsHeight - itemHeight;
          $container.css({
            marginTop: containerMargin+'px'
            });
        }
				
        var containerPosition = {
          right: megaWidth
        };
        if(defaults.direction == 'right'){
          containerPosition = {
            left: megaWidth
          };
        }
				
        if(defaults.effect == 'fade'){
          $container.css(containerPosition).fadeIn(defaults.speed);
        }
        if(defaults.effect == 'show'){
          $container.css(containerPosition).show();
        }
        if(defaults.effect == 'slide'){
          $container.css({
            width: 0,
            height: 0,
            opacity: 0
          });
					
          if(defaults.direction == 'right'){
				
            $container.show().css({
              left: megaWidth
            });
          } else {
					
            $container.show().css({
              right: megaWidth
            });
          }
          $container.animate({
            width: width,
            height: height,
            opacity: 1
          }, defaults.speed);
        }
      }
			
      function megaOut(){
        $(this).removeClass('mega-hover');
        var $container = $('.sub-container',this);
        $container.hide();
      }
    });
  };
})(jQuery);
/*
 * jQuery history plugin
 * 
 * sample page: http://www.mikage.to/jquery/jquery_history.html
 *
 * Copyright (c) 2006-2009 Taku Sano (Mikage Sawatari)
 * Licensed under the MIT License:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * Modified by Lincoln Cooper to add Safari support and only call the callback once during initialization
 * for msie when no initial hash supplied.
 */


jQuery.extend({
	historyCurrentHash: undefined,
	historyCallback: undefined,
	historyIframeSrc: undefined,
	
	historyInit: function(callback, src){
		jQuery.historyCallback = callback;
		if (src) jQuery.historyIframeSrc = src;
		var current_hash = location.hash.replace(/\?.*$/, '');
		
		jQuery.historyCurrentHash = current_hash;
		// if ((jQuery.browser.msie) && (jQuery.browser.version < 8)) {
		if (jQuery.browser.msie) {
			// To stop the callback firing twice during initilization if no hash present
			if (jQuery.historyCurrentHash == '') {
			jQuery.historyCurrentHash = '#';
		}
		
			// add hidden iframe for IE
			jQuery("body").prepend('<iframe id="jQuery_history" style="display: none;"'+
				(jQuery.historyIframeSrc ? ' src="'+jQuery.historyIframeSrc+'"' : '')
				+'></iframe>'
			);
			var ihistory = jQuery("#jQuery_history")[0];
			var iframe = ihistory.contentWindow.document;
			iframe.open();
			iframe.close();
			iframe.location.hash = current_hash;
		}
		else if (jQuery.browser.safari) {
			// etablish back/forward stacks
			jQuery.historyBackStack = [];
			jQuery.historyBackStack.length = history.length;
			jQuery.historyForwardStack = [];
			jQuery.lastHistoryLength = history.length;
			
			jQuery.isFirst = true;
		}
		if(current_hash)
			jQuery.historyCallback(current_hash.replace(/^#/, ''));
		setInterval(jQuery.historyCheck, 100);
	},
	
	historyAddHistory: function(hash) {
		// This makes the looping function do something
		jQuery.historyBackStack.push(hash);
		
		jQuery.historyForwardStack.length = 0; // clear forwardStack (true click occured)
		this.isFirst = true;
	},
	
	historyCheck: function(){
		// if ((jQuery.browser.msie) && (jQuery.browser.version < 8)) {
		if (jQuery.browser.msie) {
			// On IE, check for location.hash of iframe
			var ihistory = jQuery("#jQuery_history")[0];
			var iframe = ihistory.contentDocument || ihistory.contentWindow.document;
			var current_hash = iframe.location.hash.replace(/\?.*$/, '');
			if(current_hash != jQuery.historyCurrentHash) {
			
				location.hash = current_hash;
				jQuery.historyCurrentHash = current_hash;
				jQuery.historyCallback(current_hash.replace(/^#/, ''));
				
			}
		} else if (jQuery.browser.safari) {
			if(jQuery.lastHistoryLength == history.length && jQuery.historyBackStack.length > jQuery.lastHistoryLength) {
				jQuery.historyBackStack.shift();
			}
			if (!jQuery.dontCheck) {
				var historyDelta = history.length - jQuery.historyBackStack.length;
				jQuery.lastHistoryLength = history.length;
				
				if (historyDelta) { // back or forward button has been pushed
					jQuery.isFirst = false;
					if (historyDelta < 0) { // back button has been pushed
						// move items to forward stack
						for (var i = 0; i < Math.abs(historyDelta); i++) jQuery.historyForwardStack.unshift(jQuery.historyBackStack.pop());
					} else { // forward button has been pushed
						// move items to back stack
						for (var i = 0; i < historyDelta; i++) jQuery.historyBackStack.push(jQuery.historyForwardStack.shift());
					}
					var cachedHash = jQuery.historyBackStack[jQuery.historyBackStack.length - 1];
					if (cachedHash != undefined) {
						jQuery.historyCurrentHash = location.hash.replace(/\?.*$/, '');
						jQuery.historyCallback(cachedHash);
					}
				} else if (jQuery.historyBackStack[jQuery.historyBackStack.length - 1] == undefined && !jQuery.isFirst) {
					// back button has been pushed to beginning and URL already pointed to hash (e.g. a bookmark)
					// document.URL doesn't change in Safari
					if (location.hash) {
						var current_hash = location.hash;
						jQuery.historyCallback(location.hash.replace(/^#/, ''));
					} else {
						var current_hash = '';
						jQuery.historyCallback('');
					}
					jQuery.isFirst = true;
				}
			}
		} else {
			// otherwise, check for location.hash
			var current_hash = location.hash.replace(/\?.*$/, '');
			if(current_hash != jQuery.historyCurrentHash) {
				jQuery.historyCurrentHash = current_hash;
				jQuery.historyCallback(current_hash.replace(/^#/, ''));
			}
		}
	},
	historyLoad: function(hash){
		var newhash;
		hash = decodeURIComponent(hash.replace(/\?.*$/, ''));
		
		if (jQuery.browser.safari) {
			newhash = hash;
		}
		else {
			newhash = '#' + hash;
			location.hash = newhash;
		}
		jQuery.historyCurrentHash = newhash;
		
		// if ((jQuery.browser.msie) && (jQuery.browser.version < 8)) {
		if (jQuery.browser.msie) {
			var ihistory = jQuery("#jQuery_history")[0];
			var iframe = ihistory.contentWindow.document;
			iframe.open();
			iframe.close();
			iframe.location.hash = newhash;
			jQuery.lastHistoryLength = history.length;
			jQuery.historyCallback(hash);
		}
		else if (jQuery.browser.safari) {
			jQuery.dontCheck = true;
			// Manually keep track of the history values for Safari
			this.historyAddHistory(hash);
			
			// Wait a while before allowing checking so that Safari has time to update the "history" object
			// correctly (otherwise the check loop would detect a false change in hash).
			var fn = function() {jQuery.dontCheck = false;};
			window.setTimeout(fn, 200);
			jQuery.historyCallback(hash);
			// N.B. "location.hash=" must be the last line of code for Safari as execution stops afterwards.
			//      By explicitly using the "location.hash" command (instead of using a variable set to "location.hash") the
			//      URL in the browser and the "history" object are both updated correctly.
			location.hash = newhash;
		}
		else {
		  jQuery.historyCallback(hash);
		}
	}
});



/**
 * jQuery Opacity Rollover plugin
 *
 * Copyright (c) 2009 Trent Foley (http://trentacular.com)
 * Licensed under the MIT License:
 *   http://www.opensource.org/licenses/mit-license.php
 */
;(function($) {
	var defaults = {
		mouseOutOpacity:   0.67,
		mouseOverOpacity:  1.0,
		fadeSpeed:         'fast',
		exemptionSelector: '.selected'
	};

	$.fn.opacityrollover = function(settings) {
		// Initialize the effect
		$.extend(this, defaults, settings);

		var config = this;

		function fadeTo(element, opacity) {
			var $target = $(element);
			
			if (config.exemptionSelector)
				$target = $target.not(config.exemptionSelector);	
			
			$target.fadeTo(config.fadeSpeed, opacity);
		}

		this.css('opacity', this.mouseOutOpacity)
			.hover(
				function () {
					fadeTo(this, config.mouseOverOpacity);
				},
				function () {
					fadeTo(this, config.mouseOutOpacity);
				});

		return this;
	};
})(jQuery);

/**
 * jQuery Galleriffic plugin
 *
 * Copyright (c) 2008 Trent Foley (http://trentacular.com)
 * Licensed under the MIT License:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * Much thanks to primary contributer Ponticlaro (http://www.ponticlaro.com)
 */
;(function($) {
	// Globally keep track of all images by their unique hash.  Each item is an image data object.
	var allImages = {};
	var imageCounter = 0;

	// Galleriffic static class
	$.galleriffic = {
          version: '2.0.1',

          // Strips invalid characters and any leading # characters
          normalizeHash: function(hash) {
            return hash.replace(/^.*#/, '').replace(/\?.*$/, '');
          },

          getImage: function(hash) {
            if (!hash)
              return undefined;

            hash = $.galleriffic.normalizeHash(hash);
            return allImages[hash];
          },

          // Global function that looks up an image by its hash and displays the image.
          // Returns false when an image is not found for the specified hash.
          // @param {String} hash This is the unique hash value assigned to an image.
          gotoImage: function(hash) {
            var imageData = $.galleriffic.getImage(hash);
            if (!imageData)
              return false;

            var gallery = imageData.gallery;
            gallery.gotoImage(imageData);

            return true;
          },

          // Removes an image from its respective gallery by its hash.
          // Returns false when an image is not found for the specified hash or the
          // specified owner gallery does match the located images gallery.
          // @param {String} hash This is the unique hash value assigned to an image.
          // @param {Object} ownerGallery (Optional) When supplied, the located images
          // gallery is verified to be the same as the specified owning gallery before
          // performing the remove operation.
          removeImageByHash: function(hash, ownerGallery) {
            var imageData = $.galleriffic.getImage(hash);
            if (!imageData)
                    return false;

            var gallery = imageData.gallery;
            if (ownerGallery && ownerGallery != gallery)
                    return false;

            return gallery.removeImageByIndex(imageData.index);
          }
	};

	var defaults = {
          delay:                     3000,
          numThumbs:                 20,
          preloadAhead:              40, // Set to -1 to preload all images
          enableTopPager:            false,
          enableBottomPager:         true,
          maxPagesToShow:            7,
          imageContainerSel:         '',
          captionContainerSel:       '',
          controlsContainerSel:      '',
          loadingContainerSel:       '',
          renderSSControls:          true,
          renderNavControls:         true,
          playLinkText:              'Play',
          pauseLinkText:             'Pause',
          prevLinkText:              'Previous',
          nextLinkText:              'Next',
          nextPageLinkText:          'Next &rsaquo;',
          prevPageLinkText:          '&lsaquo; Prev',
          enableHistory:             false,
          enableKeyboardNavigation:  true,
          autoStart:                 false,
          syncTransitions:           false,
          defaultTransitionDuration: 1000,
          onSlideChange:             undefined, // accepts a delegate like such: function(prevIndex, nextIndex) { ... }
          onTransitionOut:           undefined, // accepts a delegate like such: function(slide, caption, isSync, callback) { ... }
          onTransitionIn:            undefined, // accepts a delegate like such: function(slide, caption, isSync) { ... }
          onPageTransitionOut:       undefined, // accepts a delegate like such: function(callback) { ... }
          onPageTransitionIn:        undefined, // accepts a delegate like such: function() { ... }
          onImageAdded:              undefined, // accepts a delegate like such: function(imageData, $li) { ... }
          onImageRemoved:            undefined  // accepts a delegate like such: function(imageData, $li) { ... }
	};

	// Primary Galleriffic initialization function that should be called on the thumbnail container.
	$.fn.galleriffic = function(settings) {
		//  Extend Gallery Object
		$.extend(this, {
			// Returns the version of the script
			version: $.galleriffic.version,

			// Current state of the slideshow
			isSlideshowRunning: false,
			slideshowTimeout: undefined,

			// This function is attached to the click event of generated hyperlinks within the gallery
			clickHandler: function(e, link) {
                          this.pause();

                          if (!this.enableHistory) {
                            // The href attribute holds the unique hash for an image
                            var hash = $.galleriffic.normalizeHash($(link).prop('href'));
                            $.galleriffic.gotoImage(hash);
                            e.preventDefault();
                          }
			},

			// Appends an image to the end of the set of images.  Argument listItem can be either a jQuery DOM element or arbitrary html.
			// @param listItem Either a jQuery object or a string of html of the list item that is to be added to the gallery.
			appendImage: function(listItem) {
                          this.addImage(listItem, false, false);
                          return this;
			},

			// Inserts an image into the set of images.  Argument listItem can be either a jQuery DOM element or arbitrary html.
			// @param listItem Either a jQuery object or a string of html of the list item that is to be added to the gallery.
			// @param {Integer} position The index within the gallery where the item shouold be added.
			insertImage: function(listItem, position) {
                          this.addImage(listItem, false, true, position);
                          return this;
			},

			// Adds an image to the gallery and optionally inserts/appends it to the DOM (thumbExists)
			// @param listItem Either a jQuery object or a string of html of the list item that is to be added to the gallery.
			// @param {Boolean} thumbExists Specifies whether the thumbnail already exists in the DOM or if it needs to be added.
			// @param {Boolean} insert Specifies whether the the image is appended to the end or inserted into the gallery.
			// @param {Integer} position The index within the gallery where the item shouold be added.
			addImage: function(listItem, thumbExists, insert, position) {
				var $li = ( typeof listItem === "string" ) ? $(listItem) : listItem;				
				var $aThumb = $li.find('a.thumb');
				var slideUrl = $aThumb.prop('href');
				var title = $aThumb.attr('title');
				var $caption = $li.find('.caption').remove();
				var hash = $aThumb.attr('name');

				// Increment the image counter
				imageCounter++;

				// Autogenerate a hash value if none is present or if it is a duplicate
				if (!hash || allImages[''+hash]) {
					hash = imageCounter;
				}

				// Set position to end when not specified
				if (!insert)
					position = this.data.length;
				
				var imageData = {
					title:title,
					slideUrl:slideUrl,
					caption:$caption,
					hash:hash,
					gallery:this,
					index:position
				};

				// Add the imageData to this gallery's array of images
				if (insert) {
					this.data.splice(position, 0, imageData);

					// Reset index value on all imageData objects
					this.updateIndices(position);
				}
				else {
					this.data.push(imageData);
				}

				var gallery = this;

				// Add the element to the DOM
				if (!thumbExists) {
					// Update thumbs passing in addition post transition out handler
					this.updateThumbs(function() {
						var $thumbsUl = gallery.find('ul.thumbs');
						if (insert)
							$thumbsUl.children(':eq('+position+')').before($li);
						else
							$thumbsUl.append($li);
						
						if (gallery.onImageAdded)
							gallery.onImageAdded(imageData, $li);
					});
				}

				// Register the image globally
				allImages[''+hash] = imageData;

				// Setup attributes and click handler
				$aThumb.attr('rel', 'history')
					.prop('href', '#'+hash)
					.removeAttr('name')
					.click(function(e) {
						gallery.clickHandler(e, this);
					});

				return this;
			},

			// Removes an image from the gallery based on its index.
			// Returns false when the index is out of range.
			removeImageByIndex: function(index) {
				if (index < 0 || index >= this.data.length)
					return false;
				
				var imageData = this.data[index];
				if (!imageData)
					return false;
				
				this.removeImage(imageData);
				
				return true;
			},

			// Convenience method that simply calls the global removeImageByHash method.
			removeImageByHash: function(hash) {
				return $.galleriffic.removeImageByHash(hash, this);
			},

			// Removes an image from the gallery.
			removeImage: function(imageData) {
				var index = imageData.index;
				
				// Remove the image from the gallery data array
				this.data.splice(index, 1);
				
				// Remove the global registration
				delete allImages[''+imageData.hash];
				
				// Remove the image's list item from the DOM
				this.updateThumbs(function() {
					var $li = gallery.find('ul.thumbs')
						.children(':eq('+index+')')
						.remove();

					if (gallery.onImageRemoved)
						gallery.onImageRemoved(imageData, $li);
				});

				// Update each image objects index value
				this.updateIndices(index);

				return this;
			},

			// Updates the index values of the each of the images in the gallery after the specified index
			updateIndices: function(startIndex) {
				for (i = startIndex; i < this.data.length; i++) {
					this.data[i].index = i;
				}
				
				return this;
			},

			// Scraped the thumbnail container for thumbs and adds each to the gallery
			initializeThumbs: function() {
				this.data = [];
				var gallery = this;

				this.find('ul.thumbs > li').each(function(i) {
					gallery.addImage($(this), true, false);
				});

				return this;
			},

			isPreloadComplete: false,

			// Initalizes the image preloader
			preloadInit: function() {
				if (this.preloadAhead == 0) return this;
				
				this.preloadStartIndex = this.currentImage.index;
				var nextIndex = this.getNextIndex(this.preloadStartIndex);
				return this.preloadRecursive(this.preloadStartIndex, nextIndex);
			},

			// Changes the location in the gallery the preloader should work
			// @param {Integer} index The index of the image where the preloader should restart at.
			preloadRelocate: function(index) {
				// By changing this startIndex, the current preload script will restart
				this.preloadStartIndex = index;
				return this;
			},

			// Recursive function that performs the image preloading
			// @param {Integer} startIndex The index of the first image the current preloader started on.
			// @param {Integer} currentIndex The index of the current image to preload.
			preloadRecursive: function(startIndex, currentIndex) {
				// Check if startIndex has been relocated
				if (startIndex != this.preloadStartIndex) {
					var nextIndex = this.getNextIndex(this.preloadStartIndex);
					return this.preloadRecursive(this.preloadStartIndex, nextIndex);
				}

				var gallery = this;

				// Now check for preloadAhead count
				var preloadCount = currentIndex - startIndex;
				if (preloadCount < 0)
					preloadCount = this.data.length-1-startIndex+currentIndex;
				if (this.preloadAhead >= 0 && preloadCount > this.preloadAhead) {
					// Do this in order to keep checking for relocated start index
					setTimeout(function() { gallery.preloadRecursive(startIndex, currentIndex); }, 500);
					return this;
				}

				var imageData = this.data[currentIndex];
				if (!imageData)
					return this;

				// If already loaded, continue
				if (imageData.image)
					return this.preloadNext(startIndex, currentIndex); 
				
				// Preload the image
				var image = new Image();
				
				image.onload = function() {
					imageData.image = this;
					gallery.preloadNext(startIndex, currentIndex);
				};

				image.alt = imageData.title;
				image.src = imageData.slideUrl;

				return this;
			},
			
			// Called by preloadRecursive in order to preload the next image after the previous has loaded.
			// @param {Integer} startIndex The index of the first image the current preloader started on.
			// @param {Integer} currentIndex The index of the current image to preload.
			preloadNext: function(startIndex, currentIndex) {
				var nextIndex = this.getNextIndex(currentIndex);
				if (nextIndex == startIndex) {
					this.isPreloadComplete = true;
				} else {
					// Use setTimeout to free up thread
					var gallery = this;
					setTimeout(function() { gallery.preloadRecursive(startIndex, nextIndex); }, 100);
				}

				return this;
			},

			// Safe way to get the next image index relative to the current image.
			// If the current image is the last, returns 0
			getNextIndex: function(index) {
				var nextIndex = index+1;
				if (nextIndex >= this.data.length)
					nextIndex = 0;
				return nextIndex;
			},

			// Safe way to get the previous image index relative to the current image.
			// If the current image is the first, return the index of the last image in the gallery.
			getPrevIndex: function(index) {
				var prevIndex = index-1;
				if (prevIndex < 0)
					prevIndex = this.data.length-1;
				return prevIndex;
			},

			// Pauses the slideshow
			pause: function() {
				this.isSlideshowRunning = false;
				if (this.slideshowTimeout) {
					clearTimeout(this.slideshowTimeout);
					this.slideshowTimeout = undefined;
				}

				if (this.$controlsContainer) {
					this.$controlsContainer
						.find('div.ss-controls a').removeClass().addClass('play')
						.attr('title', this.playLinkText)
						.prop('href', '#play')
						.html(this.playLinkText);
				}
				
				return this;
			},

			// Plays the slideshow
			play: function() {
				this.isSlideshowRunning = true;

				if (this.$controlsContainer) {
					this.$controlsContainer
						.find('div.ss-controls a').removeClass().addClass('pause')
						.attr('title', this.pauseLinkText)
						.prop('href', '#pause')
						.html(this.pauseLinkText);
				}

				if (!this.slideshowTimeout) {
					var gallery = this;
					this.slideshowTimeout = setTimeout(function() { gallery.ssAdvance(); }, this.delay);
				}

				return this;
			},

			// Toggles the state of the slideshow (playing/paused)
			toggleSlideshow: function() {
				if (this.isSlideshowRunning)
					this.pause();
				else
					this.play();

				return this;
			},

			// Advances the slideshow to the next image and delegates navigation to the
			// history plugin when history is enabled
			// enableHistory is true
			ssAdvance: function() {
				if (this.isSlideshowRunning)
					this.next(true);

				return this;
			},

			// Advances the gallery to the next image.
			// @param {Boolean} dontPause Specifies whether to pause the slideshow.
			// @param {Boolean} bypassHistory Specifies whether to delegate navigation to the history plugin when history is enabled.  
			next: function(dontPause, bypassHistory) {
				this.gotoIndex(this.getNextIndex(this.currentImage.index), dontPause, bypassHistory);
				return this;
			},

			// Navigates to the previous image in the gallery.
			// @param {Boolean} dontPause Specifies whether to pause the slideshow.
			// @param {Boolean} bypassHistory Specifies whether to delegate navigation to the history plugin when history is enabled.
			previous: function(dontPause, bypassHistory) {
				this.gotoIndex(this.getPrevIndex(this.currentImage.index), dontPause, bypassHistory);
				return this;
			},

			// Navigates to the next page in the gallery.
			// @param {Boolean} dontPause Specifies whether to pause the slideshow.
			// @param {Boolean} bypassHistory Specifies whether to delegate navigation to the history plugin when history is enabled.
			nextPage: function(dontPause, bypassHistory) {
				var page = this.getCurrentPage();
				var lastPage = this.getNumPages() - 1;
				if (page < lastPage) {
					var startIndex = page * this.numThumbs;
					var nextPage = startIndex + this.numThumbs;
					this.gotoIndex(nextPage, dontPause, bypassHistory);
				}

				return this;
			},

			// Navigates to the previous page in the gallery.
			// @param {Boolean} dontPause Specifies whether to pause the slideshow.
			// @param {Boolean} bypassHistory Specifies whether to delegate navigation to the history plugin when history is enabled.
			previousPage: function(dontPause, bypassHistory) {
				var page = this.getCurrentPage();
				if (page > 0) {
					var startIndex = page * this.numThumbs;
					var prevPage = startIndex - this.numThumbs;				
					this.gotoIndex(prevPage, dontPause, bypassHistory);
				}
				
				return this;
			},

			// Navigates to the image at the specified index in the gallery
			// @param {Integer} index The index of the image in the gallery to display.
			// @param {Boolean} dontPause Specifies whether to pause the slideshow.
			// @param {Boolean} bypassHistory Specifies whether to delegate navigation to the history plugin when history is enabled.
			gotoIndex: function(index, dontPause, bypassHistory) {
				if (!dontPause)
					this.pause();
				
				if (index < 0) index = 0;
				else if (index >= this.data.length) index = this.data.length-1;
				
				var imageData = this.data[index];
				
				if (!bypassHistory && this.enableHistory)
					$.historyLoad(String(imageData.hash));  // At the moment, historyLoad only accepts string arguments
				else
					this.gotoImage(imageData);

				return this;
			},

			// This function is garaunteed to be called anytime a gallery slide changes.
			// @param {Object} imageData An object holding the image metadata of the image to navigate to.
			gotoImage: function(imageData) {
				var index = imageData.index;

				if (this.onSlideChange)
					this.onSlideChange(this.currentImage.index, index);
				
				this.currentImage = imageData;
				this.preloadRelocate(index);
				
				this.refresh();
				
				return this;
			},

			// Returns the default transition duration value.  The value is halved when not
			// performing a synchronized transition.
			// @param {Boolean} isSync Specifies whether the transitions are synchronized.
			getDefaultTransitionDuration: function(isSync) {
				if (isSync)
					return this.defaultTransitionDuration;
				return this.defaultTransitionDuration / 2;
			},

			// Rebuilds the slideshow image and controls and performs transitions
			refresh: function() {
				var imageData = this.currentImage;
				if (!imageData)
					return this;

				var index = imageData.index;

				// Update Controls
				if (this.$controlsContainer) {
					this.$controlsContainer
						.find('div.nav-controls a.prev').prop('href', '#'+this.data[this.getPrevIndex(index)].hash).end()
						.find('div.nav-controls a.next').prop('href', '#'+this.data[this.getNextIndex(index)].hash);
				}

				var previousSlide = this.$imageContainer.find('span.current').addClass('previous').removeClass('current');
				var previousCaption = 0;

				if (this.$captionContainer) {
					previousCaption = this.$captionContainer.find('span.current').addClass('previous').removeClass('current');
				}

				// Perform transitions simultaneously if syncTransitions is true and the next image is already preloaded
				var isSync = this.syncTransitions && imageData.image;

				// Flag we are transitioning
				var isTransitioning = true;
				var gallery = this;

				var transitionOutCallback = function() {
					// Flag that the transition has completed
					isTransitioning = false;

					// Remove the old slide
					previousSlide.remove();

					// Remove old caption
					if (previousCaption)
						previousCaption.remove();

					if (!isSync) {
						if (imageData.image && imageData.hash == gallery.data[gallery.currentImage.index].hash) {
							gallery.buildImage(imageData, isSync);
						} else {
							// Show loading container
							if (gallery.$loadingContainer) {
								gallery.$loadingContainer.show();
							}
						}
					}
				};

				if (previousSlide.length == 0) {
					// For the first slide, the previous slide will be empty, so we will call the callback immediately
					transitionOutCallback();
				} else {
					if (this.onTransitionOut) {
						this.onTransitionOut(previousSlide, previousCaption, isSync, transitionOutCallback);
					} else {
						previousSlide.fadeTo(this.getDefaultTransitionDuration(isSync), 0.0, transitionOutCallback);
						if (previousCaption)
							previousCaption.fadeTo(this.getDefaultTransitionDuration(isSync), 0.0);
					}
				}

				// Go ahead and begin transitioning in of next image
				if (isSync)
					this.buildImage(imageData, isSync);

				if (!imageData.image) {
					var image = new Image();
					
					// Wire up mainImage onload event
					image.onload = function() {
						imageData.image = this;

						// Only build image if the out transition has completed and we are still on the same image hash
						if (!isTransitioning && imageData.hash == gallery.data[gallery.currentImage.index].hash) {
							gallery.buildImage(imageData, isSync);
						}
					};

					// set alt and src
					image.alt = imageData.title;
					image.src = imageData.slideUrl;
				}

				// This causes the preloader (if still running) to relocate out from the currentIndex
				this.relocatePreload = true;

				return this.syncThumbs();
			},

			// Called by the refresh method after the previous image has been transitioned out or at the same time
			// as the out transition when performing a synchronous transition.
			// @param {Object} imageData An object holding the image metadata of the image to build.
			// @param {Boolean} isSync Specifies whether the transitions are synchronized.
			buildImage: function(imageData, isSync) {
				var gallery = this;
				var nextIndex = this.getNextIndex(imageData.index);

				// Construct new hidden span for the image
				var newSlide = this.$imageContainer
					.append('<span class="image-wrapper current"><a class="advance-link" rel="history" href="#'+this.data[nextIndex].hash+'" title="'+imageData.title+'">&nbsp;</a></span>')
					.find('span.current').css('opacity', '0');
				
				newSlide.find('a')
					.append(imageData.image)
					.click(function(e) {
						gallery.clickHandler(e, this);
					});
				
				var newCaption = 0;
				if (this.$captionContainer) {
					// Construct new hidden caption for the image
					newCaption = this.$captionContainer
						.append('<span class="image-caption current"></span>')
						.find('span.current').css('opacity', '0')
						.append(imageData.caption);
				}

				// Hide the loading conatiner
				if (this.$loadingContainer) {
					this.$loadingContainer.hide();
				}

				// Transition in the new image
				if (this.onTransitionIn) {
					this.onTransitionIn(newSlide, newCaption, isSync);
				} else {
					newSlide.fadeTo(this.getDefaultTransitionDuration(isSync), 1.0);
					if (newCaption)
						newCaption.fadeTo(this.getDefaultTransitionDuration(isSync), 1.0);
				}
				
				if (this.isSlideshowRunning) {
					if (this.slideshowTimeout)
						clearTimeout(this.slideshowTimeout);

					this.slideshowTimeout = setTimeout(function() { gallery.ssAdvance(); }, this.delay);
				}

				return this;
			},

			// Returns the current page index that should be shown for the currentImage
			getCurrentPage: function() {
				return Math.floor(this.currentImage.index / this.numThumbs);
			},

			// Applies the selected class to the current image's corresponding thumbnail.
			// Also checks if the current page has changed and updates the displayed page of thumbnails if necessary.
			syncThumbs: function() {
				var page = this.getCurrentPage();
				if (page != this.displayedPage)
					this.updateThumbs();

				// Remove existing selected class and add selected class to new thumb
				var $thumbs = this.find('ul.thumbs').children();
				$thumbs.filter('.selected').removeClass('selected');
				$thumbs.eq(this.currentImage.index).addClass('selected');

				return this;
			},

			// Performs transitions on the thumbnails container and updates the set of
			// thumbnails that are to be displayed and the navigation controls.
			// @param {Delegate} postTransitionOutHandler An optional delegate that is called after
			// the thumbnails container has transitioned out and before the thumbnails are rebuilt.
			updateThumbs: function(postTransitionOutHandler) {
				var gallery = this;
				var transitionOutCallback = function() {
					// Call the Post-transition Out Handler
					if (postTransitionOutHandler)
						postTransitionOutHandler();
					
					gallery.rebuildThumbs();

					// Transition In the thumbsContainer
					if (gallery.onPageTransitionIn)
						gallery.onPageTransitionIn();
					else
						gallery.show();
				};

				// Transition Out the thumbsContainer
				if (this.onPageTransitionOut) {
					this.onPageTransitionOut(transitionOutCallback);
				} else {
					this.hide();
					transitionOutCallback();
				}

				return this;
			},

			// Updates the set of thumbnails that are to be displayed and the navigation controls.
			rebuildThumbs: function() {
				var needsPagination = this.data.length > this.numThumbs;

				// Rebuild top pager
				if (this.enableTopPager) {
					var $topPager = this.find('div.top');
					if ($topPager.length == 0)
						$topPager = this.prepend('<div class="top pagination"></div>').find('div.top');
					else
						$topPager.empty();

					if (needsPagination)
						this.buildPager($topPager);
				}

				// Rebuild bottom pager
				if (this.enableBottomPager) {
					var $bottomPager = this.find('div.bottom');
					if ($bottomPager.length == 0)
						$bottomPager = this.append('<div class="bottom pagination"></div>').find('div.bottom');
					else
						$bottomPager.empty();

					if (needsPagination)
						this.buildPager($bottomPager);
				}

				var page = this.getCurrentPage();
				var startIndex = page*this.numThumbs;
				var stopIndex = startIndex+this.numThumbs-1;
				if (stopIndex >= this.data.length)
					stopIndex = this.data.length-1;

				// Show/Hide thumbs
				var $thumbsUl = this.find('ul.thumbs');
				$thumbsUl.find('li').each(function(i) {
					var $li = $(this);
					if (i >= startIndex && i <= stopIndex) {
						$li.show();
					} else {
						$li.hide();
					}
				});

				this.displayedPage = page;

				// Remove the noscript class from the thumbs container ul
				$thumbsUl.removeClass('noscript');
				
				return this;
			},

			// Returns the total number of pages required to display all the thumbnails.
			getNumPages: function() {
				return Math.ceil(this.data.length/this.numThumbs);
			},

			// Rebuilds the pager control in the specified matched element.
			// @param {jQuery} pager A jQuery element set matching the particular pager to be rebuilt.
			buildPager: function(pager) {
				var gallery = this;
				var numPages = this.getNumPages();
				var page = this.getCurrentPage();
				var startIndex = page * this.numThumbs;
				var pagesRemaining = this.maxPagesToShow - 1;
				
				var pageNum = page - Math.floor((this.maxPagesToShow - 1) / 2) + 1;
				if (pageNum > 0) {
					var remainingPageCount = numPages - pageNum;
					if (remainingPageCount < pagesRemaining) {
						pageNum = pageNum - (pagesRemaining - remainingPageCount);
					}
				}

				if (pageNum < 0) {
					pageNum = 0;
				}

				// Prev Page Link
				if (page > 0) {
					var prevPage = startIndex - this.numThumbs;
					pager.append('<a rel="history" href="#'+this.data[prevPage].hash+'" title="'+this.prevPageLinkText+'">'+this.prevPageLinkText+'</a>');
				}

				// Create First Page link if needed
				if (pageNum > 0) {
					this.buildPageLink(pager, 0, numPages);
					if (pageNum > 1)
						pager.append('<span class="ellipsis">&hellip;</span>');
					
					pagesRemaining--;
				}

				// Page Index Links
				while (pagesRemaining > 0) {
					this.buildPageLink(pager, pageNum, numPages);
					pagesRemaining--;
					pageNum++;
				}

				// Create Last Page link if needed
				if (pageNum < numPages) {
					var lastPageNum = numPages - 1;
					if (pageNum < lastPageNum)
						pager.append('<span class="ellipsis">&hellip;</span>');

					this.buildPageLink(pager, lastPageNum, numPages);
				}

				// Next Page Link
				var nextPage = startIndex + this.numThumbs;
				if (nextPage < this.data.length) {
					pager.append('<a rel="history" href="#'+this.data[nextPage].hash+'" title="'+this.nextPageLinkText+'">'+this.nextPageLinkText+'</a>');
				}

				pager.find('a').click(function(e) {
					gallery.clickHandler(e, this);
				});

				return this;
			},

			// Builds a single page link within a pager.  This function is called by buildPager
			// @param {jQuery} pager A jQuery element set matching the particular pager to be rebuilt.
			// @param {Integer} pageNum The page number of the page link to build.
			// @param {Integer} numPages The total number of pages required to display all thumbnails.
			buildPageLink: function(pager, pageNum, numPages) {
				var pageLabel = pageNum + 1;
				var currentPage = this.getCurrentPage();
				if (pageNum == currentPage)
					pager.append('<span class="current">'+pageLabel+'</span>');
				else if (pageNum < numPages) {
					var imageIndex = pageNum*this.numThumbs;
					pager.append('<a rel="history" href="#'+this.data[imageIndex].hash+'" title="'+pageLabel+'">'+pageLabel+'</a>');
				}
				
				return this;
			}
		});

		// Now initialize the gallery
		$.extend(this, defaults, settings);
		
		// Verify the history plugin is available
		if (this.enableHistory && !$.historyInit)
			this.enableHistory = false;
		
		// Select containers
		if (this.imageContainerSel) this.$imageContainer = $(this.imageContainerSel);
		if (this.captionContainerSel) this.$captionContainer = $(this.captionContainerSel);
		if (this.loadingContainerSel) this.$loadingContainer = $(this.loadingContainerSel);

		// Initialize the thumbails
		this.initializeThumbs();
		
		if (this.maxPagesToShow < 3)
			this.maxPagesToShow = 3;

		this.displayedPage = -1;
		this.currentImage = this.data[0];
		var gallery = this;

		// Hide the loadingContainer
		if (this.$loadingContainer)
			this.$loadingContainer.hide();

		// Setup controls
		if (this.controlsContainerSel) {
			this.$controlsContainer = $(this.controlsContainerSel).empty();
			
			if (this.renderSSControls) {
				if (this.autoStart) {
					this.$controlsContainer
						.append('<div class="ss-controls"><a href="#pause" class="pause" title="'+this.pauseLinkText+'">'+this.pauseLinkText+'</a></div>');
				} else {
					this.$controlsContainer
						.append('<div class="ss-controls"><a href="#play" class="play" title="'+this.playLinkText+'">'+this.playLinkText+'</a></div>');
				}

				this.$controlsContainer.find('div.ss-controls a')
					.click(function(e) {
						gallery.toggleSlideshow();
						e.preventDefault();
						return false;
					});
			}
		
			if (this.renderNavControls) {
				this.$controlsContainer
					.append('<div class="nav-controls"><a class="prev" rel="history" title="'+this.prevLinkText+'">'+this.prevLinkText+'</a><a class="next" rel="history" title="'+this.nextLinkText+'">'+this.nextLinkText+'</a></div>')
					.find('div.nav-controls a')
					.click(function(e) {
						gallery.clickHandler(e, this);
					});
			}
		}

		var initFirstImage = !this.enableHistory || !location.hash;
		if (this.enableHistory && location.hash) {
			var hash = $.galleriffic.normalizeHash(location.hash);
			var imageData = allImages[hash];
			if (!imageData)
				initFirstImage = true;
		}

		// Setup gallery to show the first image
		if (initFirstImage)
			this.gotoIndex(0, false, true);

		// Setup Keyboard Navigation
		if (this.enableKeyboardNavigation) {
			$(document).keydown(function(e) {
				var key = e.charCode ? e.charCode : e.keyCode ? e.keyCode : 0;
				switch(key) {
					case 32: // space
						gallery.next();
						e.preventDefault();
						break;
					case 33: // Page Up
						gallery.previousPage();
						e.preventDefault();
						break;
					case 34: // Page Down
						gallery.nextPage();
						e.preventDefault();
						break;
					case 35: // End
						gallery.gotoIndex(gallery.data.length-1);
						e.preventDefault();
						break;
					case 36: // Home
						gallery.gotoIndex(0);
						e.preventDefault();
						break;
					case 37: // left arrow
						gallery.previous();
						e.preventDefault();
						break;
					case 39: // right arrow
						gallery.next();
						e.preventDefault();
						break;
				}
			});
		}

		// Auto start the slideshow
		if (this.autoStart)
			this.play();

		// Kickoff Image Preloader after 1 second
		setTimeout(function() { gallery.preloadInit(); }, 1000);

		return this;
	};
})(jQuery);

/*!
 * jQuery UI 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function( $, undefined ) {

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don't want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: "1.8.6",

	keyCode: {
		ALT: 18,
		BACKSPACE: 8,
		CAPS_LOCK: 20,
		COMMA: 188,
		COMMAND: 91,
		COMMAND_LEFT: 91, // COMMAND
		COMMAND_RIGHT: 93,
		CONTROL: 17,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		INSERT: 45,
		LEFT: 37,
		MENU: 93, // COMMAND_RIGHT
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SHIFT: 16,
		SPACE: 32,
		TAB: 9,
		UP: 38,
		WINDOWS: 91 // COMMAND
	}
});

// plugins
$.fn.extend({
	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === "number" ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.browser.msie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.curCSS(this,'position',1)) && (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));
			}).eq(0);
		}

		return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.each( [ "Width", "Height" ], function( i, name ) {
	var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
		type = name.toLowerCase(),
		orig = {
			innerWidth: $.fn.innerWidth,
			innerHeight: $.fn.innerHeight,
			outerWidth: $.fn.outerWidth,
			outerHeight: $.fn.outerHeight
		};

	function reduce( elem, size, border, margin ) {
		$.each( side, function() {
			size -= parseFloat( $.curCSS( elem, "padding" + this, true) ) || 0;
			if ( border ) {
				size -= parseFloat( $.curCSS( elem, "border" + this + "Width", true) ) || 0;
			}
			if ( margin ) {
				size -= parseFloat( $.curCSS( elem, "margin" + this, true) ) || 0;
			}
		});
		return size;
	}

	$.fn[ "inner" + name ] = function( size ) {
		if ( size === undefined ) {
			return orig[ "inner" + name ].call( this );
		}

		return this.each(function() {
			$( this ).css( type, reduce( this, size ) + "px" );
		});
	};

	$.fn[ "outer" + name] = function( size, margin ) {
		if ( typeof size !== "number" ) {
			return orig[ "outer" + name ].call( this, size );
		}

		return this.each(function() {
			$( this).css( type, reduce( this, size, true, margin ) + "px" );
		});
	};
});

// selectors
function visible( element ) {
	return !$( element ).parents().andSelf().filter(function() {
		return $.curCSS( this, "visibility" ) === "hidden" ||
			$.expr.filters.hidden( this );
	}).length;
}

$.extend( $.expr[ ":" ], {
	data: function( elem, i, match ) {
		return !!$.data( elem, match[ 3 ] );
	},

	focusable: function( element ) {
		var nodeName = element.nodeName.toLowerCase(),
			tabIndex = $.attr( element, "tabindex" );
		if ( "area" === nodeName ) {
			var map = element.parentNode,
				mapName = map.name,
				img;
			if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
				return false;
			}
			img = $( "img[usemap=#" + mapName + "]" )[0];
			return !!img && visible( img );
		}
		return ( /input|select|textarea|button|object/.test( nodeName )
			? !element.disabled
			: "a" == nodeName
				? element.href || !isNaN( tabIndex )
				: !isNaN( tabIndex ))
			// the element and all of its ancestors must be visible
			&& visible( element );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" );
		return ( isNaN( tabIndex ) || tabIndex >= 0 ) && $( element ).is( ":focusable" );
	}
});

// support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( "div" ) );

	$.extend( div.style, {
		minHeight: "100px",
		height: "auto",
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = "onselectstart" in div;

	// set display to none to avoid a layout bug in IE
	// http://dev.jquery.com/ticket/4014
	body.removeChild( div ).style.display = "none";
});





// deprecated
$.extend( $.ui, {
	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var proto = $.ui[ module ].prototype;
			for ( var i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode ) {
				return;
			}
	
			for ( var i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},
	
	// will be deprecated when we switch to jQuery 1.4 - use jQuery.contains()
	contains: function( a, b ) {
		return document.compareDocumentPosition ?
			a.compareDocumentPosition( b ) & 16 :
			a !== b && a.contains( b );
	},
	
	// only used by resizable
	hasScroll: function( el, a ) {
	
		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}
	
		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;
	
		if ( el[ scroll ] > 0 ) {
			return true;
		}
	
		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},
	
	// these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		//Determines when x coordinate is over "b" element axis
		return ( x > reference ) && ( x < ( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		//Determines when x, y coordinates is over "b" element
		return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );

/*!
 * jQuery UI Widget 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function( $, undefined ) {

// jQuery 1.4+
if ( $.cleanData ) {
	var _cleanData = $.cleanData;
	$.cleanData = function( elems ) {
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			$( elem ).triggerHandler( "remove" );
		}
		_cleanData( elems );
	};
} else {
	var _remove = $.fn.remove;
	$.fn.remove = function( selector, keepData ) {
		return this.each(function() {
			if ( !keepData ) {
				if ( !selector || $.filter( selector, [ this ] ).length ) {
					$( "*", this ).add( [ this ] ).each(function() {
						$( this ).triggerHandler( "remove" );
					});
				}
			}
			return _remove.call( $(this), selector, keepData );
		});
	};
}

$.widget = function( name, base, prototype ) {
	var namespace = name.split( "." )[ 0 ],
		fullName;
	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName ] = function( elem ) {
		return !!$.data( elem, name );
	};

	$[ namespace ] = $[ namespace ] || {};
	$[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without initializing for simple inheritance
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	var basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
//	$.each( basePrototype, function( key, val ) {
//		if ( $.isPlainObject(val) ) {
//			basePrototype[ key ] = $.extend( {}, val );
//		}
//	});
	basePrototype.options = $.extend( true, {}, basePrototype.options );
	$[ namespace ][ name ].prototype = $.extend( true, basePrototype, {
		namespace: namespace,
		widgetName: name,
		widgetEventPrefix: $[ namespace ][ name ].prototype.widgetEventPrefix || name,
		widgetBaseClass: fullName
	}, prototype );

	$.widget.bridge( name, $[ namespace ][ name ] );
};

$.widget.bridge = function( name, object ) {
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = Array.prototype.slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.extend.apply( null, [ true, options ].concat(args) ) :
			options;

		// prevent calls to internal methods
		if ( isMethodCall && options.charAt( 0 ) === "_" ) {
			return returnValue;
		}

		if ( isMethodCall ) {
			this.each(function() {
				var instance = $.data( this, name ),
					methodValue = instance && $.isFunction( instance[options] ) ?
						instance[ options ].apply( instance, args ) :
						instance;
				// TODO: add this back in 1.9 and use $.error() (see #5972)
//				if ( !instance ) {
//					throw "cannot call methods on " + name + " prior to initialization; " +
//						"attempted to call method '" + options + "'";
//				}
//				if ( !$.isFunction( instance[options] ) ) {
//					throw "no such method '" + options + "' for " + name + " widget instance";
//				}
//				var methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, name );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, name, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( options, element ) {
	// allow instantiation without initializing for simple inheritance
	if ( arguments.length ) {
		this._createWidget( options, element );
	}
};

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	options: {
		disabled: false
	},
	_createWidget: function( options, element ) {
		// $.widget.bridge stores the plugin instance, but we do it anyway
		// so that it's stored even before the _create function runs
		$.data( element, this.widgetName, this );
		this.element = $( element );
		this.options = $.extend( true, {},
			this.options,
			this._getCreateOptions(),
			options );

		var self = this;
		this.element.bind( "remove." + this.widgetName, function() {
			self.destroy();
		});

		this._create();
		this._trigger( "create" );
		this._init();
	},
	_getCreateOptions: function() {
		return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];
	},
	_create: function() {},
	_init: function() {},

	destroy: function() {
		this.element
			.unbind( "." + this.widgetName )
			.removeData( this.widgetName );
		this.widget()
			.unbind( "." + this.widgetName )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetBaseClass + "-disabled " +
				"ui-state-disabled" );
	},

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.extend( {}, this.options );
		}

		if  (typeof key === "string" ) {
			if ( value === undefined ) {
				return this.options[ key ];
			}
			options = {};
			options[ key ] = value;
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var self = this;
		$.each( options, function( key, value ) {
			self._setOption( key, value );
		});

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				[ value ? "addClass" : "removeClass"](
					this.widgetBaseClass + "-disabled" + " " +
					"ui-state-disabled" )
				.attr( "aria-disabled", value );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_trigger: function( type, event, data ) {
		var callback = this.options[ type ];

		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		data = data || {};

		// copy original event properties over to the new event
		// this would happen if we could call $.event.fix instead of $.Event
		// but we don't have a way to force an event to be fixed multiple times
		if ( event.originalEvent ) {
			for ( var i = $.event.props.length, prop; i; ) {
				prop = $.event.props[ --i ];
				event[ prop ] = event.originalEvent[ prop ];
			}
		}

		this.element.trigger( event, data );

		return !( $.isFunction(callback) &&
			callback.call( this.element[0], event, data ) === false ||
			event.isDefaultPrevented() );
	}
};

})( jQuery );

/*!
 * jQuery UI Mouse 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.mouse", {
	options: {
		cancel: ':input,option',
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var self = this;

		this.element
			.bind('mousedown.'+this.widgetName, function(event) {
				return self._mouseDown(event);
			})
			.bind('click.'+this.widgetName, function(event) {
				if(self._preventClickEvent) {
					self._preventClickEvent = false;
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind('.'+this.widgetName);
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		// TODO: figure out why we have to use originalEvent
		event.originalEvent = event.originalEvent || {};
		if (event.originalEvent.mouseHandled) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var self = this,
			btnIsLeft = (event.which == 1),
			elIsCancel = (typeof this.options.cancel == "string" ? $(event.target).parents().add(event.target).filter(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				self.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return self._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return self._mouseUp(event);
		};
		$(document)
			.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();
		event.originalEvent.mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.browser.msie && !(document.documentMode >= 9) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;
			this._preventClickEvent = (event.target == this._mouseDownEvent.target);
			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);

/*
 * jQuery UI Draggable 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css("position")))
			this.element[0].style.position = 'relative';

		(this.options.addClasses && this.element.addClass("ui-draggable"));
		(this.options.disabled && this.element.addClass("ui-draggable-disabled"));

		this._mouseInit();

	},

	destroy: function() {
		if(!this.element.data('draggable')) return;
		this.element
			.removeData("draggable")
			.unbind(".draggable")
			.removeClass("ui-draggable"
				+ " ui-draggable-dragging"
				+ " ui-draggable-disabled");
		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle'))
			return false;

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css("position");
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.helper.addClass("ui-draggable-dragging");
		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger('drag', event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}
		
		//if the original element is removed, don't bother to continue
		if(!this.element[0] || !this.element[0].parentNode)
			return false;

		if((this.options.revert == "invalid" && !dropped) || (this.options.revert == "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			var self = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(self._trigger("stop", event) !== false) {
					self._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},
	
	cancel: function() {
		
		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}
		
		return this;
		
	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find("*")
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone() : this.element);

		if(!helper.parents('body').length)
			helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position")))
			helper.css("position", "absolute");

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) {
			var ce = $(o.containment)[0]; if(!ce) return;
			var co = $(o.containment).offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove();
		//if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == "drag") this.positionAbs = this._convertPositionTo("absolute"); //The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.extend($.ui.draggable, {
	version: "1.8.6"
});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, 'sortable');
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable._refreshItems();	//Do a one-time refresh at start to refresh the containerCache
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: 'valid/invalid'
				if(this.shouldRevert) this.instance.options.revert = true;

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == 'original')
					this.instance.currentItem.css({ top: 'auto', left: 'auto' });

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), self = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {
			
			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;
			
			if(this.instance._intersectsWith(this.instance.containerCache)) {

				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(self).clone().appendTo(this.instance.element).data("sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;
					
					//Prevent reverting on this forced stop
					this.instance.options.revert = false;
					
					// The out event needs to be triggered independently
					this.instance._trigger('out', event, this.instance._uiHash(this.instance));
					
					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function(event, ui) {
		var t = $('body'), o = $(this).data('draggable').options;
		if (t.css("cursor")) o._cursor = t.css("cursor");
		t.css("cursor", o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if (o._cursor) $('body').css("cursor", o._cursor);
	}
});

$.ui.plugin.add("draggable", "iframeFix", {
	start: function(event, ui) {
		var o = $(this).data('draggable').options;
		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>')
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});
	},
	stop: function(event, ui) {
		$("div.ui-draggable-iframeFix").each(function() { this.parentNode.removeChild(this); }); //Remove frame helpers
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data('draggable').options;
		if(t.css("opacity")) o._opacity = t.css("opacity");
		t.css('opacity', o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if(o._opacity) $(ui.helper).css('opacity', o._opacity);
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function(event, ui) {
		var i = $(this).data("draggable");
		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') {

			if(!o.axis || o.axis != 'x') {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != 'y') {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != 'x') {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != 'y') {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || ':data(draggable)' ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i >= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != 'inner') {
				var ts = Math.abs(t - y2) <= d;
				var bs = Math.abs(b - y1) <= d;
				var ls = Math.abs(l - x2) <= d;
				var rs = Math.abs(r - x1) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != 'outer') {
				var ts = Math.abs(t - y1) <= d;
				var bs = Math.abs(b - y2) <= d;
				var ls = Math.abs(l - x1) <= d;
				var rs = Math.abs(r - x2) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first))
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function(event, ui) {

		var o = $(this).data("draggable").options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
		});
		if (!group.length) { return; }
		
		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("draggable").options;
		if(t.css("zIndex")) o._zIndex = t.css("zIndex");
		t.css('zIndex', o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("draggable").options;
		if(o._zIndex) $(ui.helper).css('zIndex', o._zIndex);
	}
});

})(jQuery);

/*
 * jQuery UI Droppable 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Droppables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.mouse.js
 *	jquery.ui.draggable.js
 */
(function( $, undefined ) {

$.widget("ui.droppable", {
	widgetEventPrefix: "drop",
	options: {
		accept: '*',
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: 'default',
		tolerance: 'intersect'
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable's proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses && this.element.addClass("ui-droppable"));

	},

	destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i < drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element
			.removeClass("ui-droppable ui-droppable-disabled")
			.removeData("droppable")
			.unbind(".droppable");

		return this;
	},

	_setOption: function(key, value) {

		if(key == 'accept') {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable && this._trigger('activate', event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable && this._trigger('deactivate', event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger('over', event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('out', event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function() {
			var inst = $.data(this, 'droppable');
			if(
				inst.options.greedy
				&& !inst.options.disabled
				&& inst.options.scope == draggable.options.scope
				&& inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&& $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('drop', event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.extend($.ui.droppable, {
	version: "1.8.6"
});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case 'fit':
			return (l <= x1 && x2 <= r
				&& t <= y1 && y2 <= b);
			break;
		case 'intersect':
			return (l < x1 + (draggable.helperProportions.width / 2) // Right Half
				&& x2 - (draggable.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (draggable.helperProportions.height / 2) // Bottom Half
				&& y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
			break;
		case 'pointer':
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case 'touch':
			return (
					(y1 >= t && y1 <= b) ||	// Top edge touching
					(y2 >= t && y2 <= b) ||	// Bottom edge touching
					(y1 < t && y2 > b)		// Surrounded vertically
				) && (
					(x1 >= l && x1 <= r) ||	// Left edge touching
					(x2 >= l && x2 <= r) ||	// Right edge touching
					(x1 < l && x2 > r)		// Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { 'default': [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; // workaround for #2317
		var list = (t.currentItem || t.element).find(":data(droppable)").andSelf();

		droppablesLoop: for (var i = 0; i < m.length; i++) {

			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	//No disabled and non-accepted
			for (var j=0; j < list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
			m[i].visible = m[i].element.css("display") != "none"; if(!m[i].visible) continue; 									//If the element is not visible, continue

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

			if(type == "mousedown") m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = dropped || this._drop.call(this, event);

			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				var parent = this.element.parents(':data(droppable):eq(0)');
				if (parent.length) {
					parentInstance = $.data(parent[0], 'droppable');
					parentInstance.greedyChild = (c == 'isover' ? 1 : 0);
				}
			}

			// we just moved into a greedy child
			if (parentInstance && c == 'isover') {
				parentInstance['isover'] = 0;
				parentInstance['isout'] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0;
			this[c == "isover" ? "_over" : "_out"].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance && c == 'isout') {
				parentInstance['isout'] = 0;
				parentInstance['isover'] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	}
};

})(jQuery);

/*
 * jQuery UI Resizable 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.resizable", $.ui.mouse, {
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var self = this, o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Opera fix for relative positioning
			if (/relative/.test(this.element.css('position')) && $.browser.opera)
				this.element.css({ position: 'relative', top: 'auto', left: 'auto' });

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
					position: this.element.css('position'),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css('top'),
					left: this.element.css('left')
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"resizable", this.element.data('resizable')
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css('resize');
			this.originalElement.css('resize', 'none');

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css('margin') });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' });
		if(this.handles.constructor == String) {

			if(this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';
			var n = this.handles.split(","); this.handles = {};

			for(var i = 0; i < n.length; i++) {

				var handle = $.trim(n[i]), hname = 'ui-resizable-'+handle;
				var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>');

				// increase zIndex of sw, se, ne, nw axis
				//TODO : this modifies original option
				if(/sw|se|ne|nw/.test(handle)) axis.css({ zIndex: ++o.zIndex });

				//TODO : What's going on here?
				if ('se' == handle) {
					axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
				};

				//Insert into internal handles object and append to element
				this.handles[handle] = '.ui-resizable-'+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					var padPos = [ 'padding',
						/ne|nw|n/.test(i) ? 'Top' :
						/se|sw|s/.test(i) ? 'Bottom' :
						/^e$/.test(i) ? 'Right' : 'Left' ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $('.ui-resizable-handle', this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!self.resizing) {
				if (this.className)
					var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				//Axis, default = se
				self.axis = axis && axis[1] ? axis[1] : 'se';
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.hover(function() {
					$(this).removeClass("ui-resizable-autohide");
					self._handles.show();
				},
				function(){
					if (!self.resizing) {
						$(this).addClass("ui-resizable-autohide");
						self._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
				.removeData("resizable").unbind(".resizable").find('.ui-resizable-handle').remove();
		};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			wrapper.after(
				this.originalElement.css({
					position: wrapper.css('position'),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css('top'),
					left: wrapper.css('left')
				})
			).remove();
		}

		this.originalElement.css('resize', this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled && handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		// bugfix for http://dev.jquery.com/ticket/1749
		if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {
			el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
		}

		//Opera fixing relative position
		if ($.browser.opera && (/relative/).test(el.css('position')))
			el.css({ position: 'relative', top: 'auto', left: 'auto' });

		this._renderProxy();

		var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top'));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

	    var cursor = $('.ui-resizable-' + this.axis).css('cursor');
	    $('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			self = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		// Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]), ie6 = $.browser.msie && $.browser.version < 7, csdif = this.sizeDiff;

		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		el.css({
			top: this.position.top + "px", left: this.position.left + "px",
			width: this.size.width + "px", height: this.size.height + "px"
		});

		if (!this._helper && this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		// calling the user callback at the end
		this._trigger('resize', event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, self = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
						soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
							soffsetw = ista ? 0 : self.sizeDiff.width;

			var s = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },
				left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
				top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			self.helper.height(self.size.height);
			self.helper.width(self.size.width);

			if (this._helper && !o.animate) this._proportionallyResize();
		}

		$('body').css('cursor', 'auto');

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) this.helper.remove();
		return false;

	},

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (data.height) data.width = (csize.height * this.aspectRatio);
		else if (data.width) data.height = (csize.width / this.aspectRatio);

		if (a == 'sw') {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == 'nw') {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this.options, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
					isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

		if (isminw && cw) data.left = dw - o.minWidth;
		if (ismaxw && cw) data.left = dw - o.maxWidth;
		if (isminh && ch)	data.top = dh - o.minHeight;
		if (ismaxh && ch)	data.top = dh - o.maxHeight;

		// fixing jump error on top/left - bug #2330
		var isNotwh = !data.width && !data.height;
		if (isNotwh && !data.left && data.top) data.top = null;
		else if (isNotwh && !data.top && data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i < this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],
					p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			if ($.browser.msie && !(!($(element).is(':hidden') || $(element).parents(':hidden').length)))
				continue;

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $('<div style="overflow:hidden;"></div>');

			// fix ie6 offset TODO: This seems broken
			var ie6 = $.browser.msie && $.browser.version < 7, ie6offset = (ie6 ? 1 : 0),
			pxyoffset = ( ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: 'absolute',
				left: this.elementOffset.left - ie6offset +'px',
				top: this.elementOffset.top - ie6offset +'px',
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

$.extend($.ui.resizable, {
	version: "1.8.6"
});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "alsoResize", {

	start: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data("resizable-alsoresize", {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css('left'), 10), top: parseInt(el.css('top'), 10),
					position: el.css('position') // to reset Opera on stop()
				});
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options, os = self.originalSize, op = self.originalPosition;

		var delta = {
			height: (self.size.height - os.height) || 0, width: (self.size.width - os.width) || 0,
			top: (self.position.top - op.top) || 0, left: (self.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data("resizable-alsoresize"), style = {}, 
					css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left'];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum && sum >= 0)
						style[prop] = sum || null;
				});

				// Opera fixing relative position
				if ($.browser.opera && /relative/.test(el.css('position'))) {
					self._revertToRelativePosition = true;
					el.css({ position: 'absolute', top: 'auto', left: 'auto' });
				}

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var _reset = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				// reset position for Opera - no need to verify it was changed
				el.css({ position: el.data("resizable-alsoresize").position });
			});
		};

		if (self._revertToRelativePosition) {
			self._revertToRelativePosition = false;
			if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
				$.each(o.alsoResize, function (exp) { _reset(exp); });
			}else{
				_reset(o.alsoResize);
			}
		}

		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "animate", {

	stop: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var pr = self._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
						soffsetw = ista ? 0 : self.sizeDiff.width;

		var style = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },
					left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
						top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

		self.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(self.element.css('width'), 10),
						height: parseInt(self.element.css('height'), 10),
						top: parseInt(self.element.css('top'), 10),
						left: parseInt(self.element.css('left'), 10)
					};

					if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					// propagating resize, and updating values for each animation step
					self._updateCache(data);
					self._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, el = self.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		self.containerElement = $(ce);

		if (/document/.test(oc) || oc == document) {
			self.containerOffset = { left: 0, top: 0 };
			self.containerPosition = { left: 0, top: 0 };

			self.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			self.containerOffset = element.offset();
			self.containerPosition = element.position();
			self.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = self.containerOffset, ch = self.containerSize.height,	cw = self.containerSize.width,
						width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			self.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options,
				ps = self.containerSize, co = self.containerOffset, cs = self.size, cp = self.position,
				pRatio = self._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = self.containerElement;

		if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;

		if (cp.left < (self._helper ? co.left : 0)) {
			self.size.width = self.size.width + (self._helper ? (self.position.left - co.left) : (self.position.left - cop.left));
			if (pRatio) self.size.height = self.size.width / o.aspectRatio;
			self.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (self._helper ? co.top : 0)) {
			self.size.height = self.size.height + (self._helper ? (self.position.top - co.top) : self.position.top);
			if (pRatio) self.size.width = self.size.height * o.aspectRatio;
			self.position.top = self._helper ? co.top : 0;
		}

		self.offset.left = self.parentData.left+self.position.left;
		self.offset.top = self.parentData.top+self.position.top;

		var woset = Math.abs( (self._helper ? self.offset.left - cop.left : (self.offset.left - cop.left)) + self.sizeDiff.width ),
					hoset = Math.abs( (self._helper ? self.offset.top - cop.top : (self.offset.top - co.top)) + self.sizeDiff.height );

		var isParent = self.containerElement.get(0) == self.element.parent().get(0),
		    isOffsetRelative = /relative|absolute/.test(self.containerElement.css('position'));

		if(isParent && isOffsetRelative) woset -= self.parentData.left;

		if (woset + self.size.width >= self.parentData.width) {
			self.size.width = self.parentData.width - woset;
			if (pRatio) self.size.height = self.size.width / self.aspectRatio;
		}

		if (hoset + self.size.height >= self.parentData.height) {
			self.size.height = self.parentData.height - hoset;
			if (pRatio) self.size.width = self.size.height * self.aspectRatio;
		}
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options, cp = self.position,
				co = self.containerOffset, cop = self.containerPosition, ce = self.containerElement;

		var helper = $(self.helper), ho = helper.offset(), w = helper.outerWidth() - self.sizeDiff.width, h = helper.outerHeight() - self.sizeDiff.height;

		if (self._helper && !o.animate && (/relative/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (self._helper && !o.animate && (/static/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function(event, ui) {

		var self = $(this).data("resizable"), o = self.options, cs = self.size;

		self.ghost = self.originalElement.clone();
		self.ghost
			.css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass('ui-resizable-ghost')
			.addClass(typeof o.ghost == 'string' ? o.ghost : '');

		self.ghost.appendTo(self.helper);

	},

	resize: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost) self.ghost.css({ position: 'relative', height: self.size.height, width: self.size.width });
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost && self.helper) self.helper.get(0).removeChild(self.ghost.get(0));
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, cs = self.size, os = self.originalSize, op = self.originalPosition, a = self.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

		if (/^(se|s|e)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
		}
		else if (/^(ne)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
		}
		else if (/^(sw)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.left = op.left - ox;
		}
		else {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
			self.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);

/*
 * jQuery UI Position 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var horizontalPositions = /left|center|right/,
	verticalPositions = /top|center|bottom/,
	center = "center",
	_position = $.fn.position,
	_offset = $.fn.offset;

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var target = $( options.of ),
		targetElem = target[0],
		collision = ( options.collision || "flip" ).split( " " ),
		offset = options.offset ? options.offset.split( " " ) : [ 0, 0 ],
		targetWidth,
		targetHeight,
		basePosition;

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: 0, left: 0 };
	// TODO: use $.isWindow() in 1.9
	} else if ( targetElem.setTimeout ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		basePosition = { top: options.of.pageY, left: options.of.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		basePosition = target.offset();
	}

	// force my and at to have valid horizontal and veritcal positions
	// if a value is missing or invalid, it will be converted to center 
	$.each( [ "my", "at" ], function() {
		var pos = ( options[this] || "" ).split( " " );
		if ( pos.length === 1) {
			pos = horizontalPositions.test( pos[0] ) ?
				pos.concat( [center] ) :
				verticalPositions.test( pos[0] ) ?
					[ center ].concat( pos ) :
					[ center, center ];
		}
		pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : center;
		pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : center;
		options[ this ] = pos;
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	// normalize offset option
	offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
	if ( offset.length === 1 ) {
		offset[ 1 ] = offset[ 0 ];
	}
	offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

	if ( options.at[0] === "right" ) {
		basePosition.left += targetWidth;
	} else if (options.at[0] === center ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[1] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[1] === center ) {
		basePosition.top += targetHeight / 2;
	}

	basePosition.left += offset[ 0 ];
	basePosition.top += offset[ 1 ];

	return this.each(function() {
		var elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseInt( $.curCSS( this, "marginLeft", true ) ) || 0,
			marginTop = parseInt( $.curCSS( this, "marginTop", true ) ) || 0,
			collisionWidth = elemWidth + marginLeft +
				parseInt( $.curCSS( this, "marginRight", true ) ) || 0,
			collisionHeight = elemHeight + marginTop +
				parseInt( $.curCSS( this, "marginBottom", true ) ) || 0,
			position = $.extend( {}, basePosition ),
			collisionPosition;

		if ( options.my[0] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[0] === center ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[1] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[1] === center ) {
			position.top -= elemHeight / 2;
		}

		// prevent fractions (see #5280)
		position.left = parseInt( position.left );
		position.top = parseInt( position.top );

		collisionPosition = {
			left: position.left - marginLeft,
			top: position.top - marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[i] ] ) {
				$.ui.position[ collision[i] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: offset,
					my: options.my,
					at: options.at
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}
		elem.offset( $.extend( position, { using: options.using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft();
			position.left = over > 0 ? position.left - over : Math.max( position.left - data.collisionPosition.left, position.left );
		},
		top: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop();
			position.top = over > 0 ? position.top - over : Math.max( position.top - data.collisionPosition.top, position.top );
		}
	},

	flip: {
		left: function( position, data ) {
			if ( data.at[0] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(),
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					-data.targetWidth,
				offset = -2 * data.offset[ 0 ];
			position.left += data.collisionPosition.left < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		},
		top: function( position, data ) {
			if ( data.at[1] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(),
				myOffset = data.my[ 1 ] === "top" ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					-data.targetHeight,
				offset = -2 * data.offset[ 1 ];
			position.top += data.collisionPosition.top < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		}
	}
};

// offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
	$.offset.setOffset = function( elem, options ) {
		// set position first, in-case top/left are set even on static elem
		if ( /static/.test( $.curCSS( elem, "position" ) ) ) {
			elem.style.position = "relative";
		}
		var curElem   = $( elem ),
			curOffset = curElem.offset(),
			curTop    = parseInt( $.curCSS( elem, "top",  true ), 10 ) || 0,
			curLeft   = parseInt( $.curCSS( elem, "left", true ), 10)  || 0,
			props     = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};
		
		if ( 'using' in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	};

	$.fn.offset = function( options ) {
		var elem = this[ 0 ];
		if ( !elem || !elem.ownerDocument ) { return null; }
		if ( options ) { 
			return this.each(function() {
				$.offset.setOffset( this, options );
			});
		}
		return _offset.call( this );
	};
}

}( jQuery ));

/*
 * jQuery UI Selectable 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Selectables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.selectable", $.ui.mouse, {
	options: {
		appendTo: 'body',
		autoRefresh: true,
		distance: 0,
		filter: '*',
		tolerance: 'touch'
	},
	_create: function() {
		var self = this;

		this.element.addClass("ui-selectable");

		this.dragged = false;

		// cache selectee children based on filter
		var selectees;
		this.refresh = function() {
			selectees = $(self.options.filter, self.element[0]);
			selectees.each(function() {
				var $this = $(this);
				var pos = $this.offset();
				$.data(this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass('ui-selected'),
					selecting: $this.hasClass('ui-selecting'),
					unselecting: $this.hasClass('ui-unselecting')
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass("ui-selectee");

		this._mouseInit();

		this.helper = $("<div class='ui-selectable-helper'></div>");
	},

	destroy: function() {
		this.selectees
			.removeClass("ui-selectee")
			.removeData("selectable-item");
		this.element
			.removeClass("ui-selectable ui-selectable-disabled")
			.removeData("selectable")
			.unbind(".selectable");
		this._mouseDestroy();

		return this;
	},

	_mouseStart: function(event) {
		var self = this;

		this.opos = [event.pageX, event.pageY];

		if (this.options.disabled)
			return;

		var options = this.options;

		this.selectees = $(options.filter, this.element[0]);

		this._trigger("start", event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			"left": event.clientX,
			"top": event.clientY,
			"width": 0,
			"height": 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter('.ui-selected').each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.startselected = true;
			if (!event.metaKey) {
				selectee.$element.removeClass('ui-selected');
				selectee.selected = false;
				selectee.$element.addClass('ui-unselecting');
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				self._trigger("unselecting", event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().andSelf().each(function() {
			var selectee = $.data(this, "selectable-item");
			if (selectee) {
				var doSelect = !event.metaKey || !selectee.$element.hasClass('ui-selected');
				selectee.$element
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					self._trigger("selecting", event, {
						selecting: selectee.element
					});
				} else {
					self._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {
		var self = this;
		this.dragged = true;

		if (this.options.disabled)
			return;

		var options = this.options;

		var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
		if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

		this.selectees.each(function() {
			var selectee = $.data(this, "selectable-item");
			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element == self.element[0])
				return;
			var hit = false;
			if (options.tolerance == 'touch') {
				hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
			} else if (options.tolerance == 'fit') {
				hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass('ui-selected');
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass('ui-unselecting');
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass('ui-selecting');
					selectee.selecting = true;
					// selectable SELECTING callback
					self._trigger("selecting", event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if (event.metaKey && selectee.startselected) {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						selectee.$element.addClass('ui-selected');
						selectee.selected = true;
					} else {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass('ui-unselecting');
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						self._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey && !selectee.startselected) {
						selectee.$element.removeClass('ui-selected');
						selectee.selected = false;

						selectee.$element.addClass('ui-unselecting');
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						self._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var self = this;

		this.dragged = false;

		var options = this.options;

		$('.ui-unselecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-unselecting');
			selectee.unselecting = false;
			selectee.startselected = false;
			self._trigger("unselected", event, {
				unselected: selectee.element
			});
		});
		$('.ui-selecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			self._trigger("selected", event, {
				selected: selectee.element
			});
		});
		this._trigger("stop", event);

		this.helper.remove();

		return false;
	}

});

$.extend($.ui.selectable, {
	version: "1.8.6"
});

})(jQuery);

/*
 * jQuery UI Sortable 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.sortable", $.ui.mouse, {
	widgetEventPrefix: "sort",
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: 'auto',
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: '> *',
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine if the items are floating
		this.floating = this.items.length ? (/left|right/).test(this.items[0].item.css('float')) : false;

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

	},

	destroy: function() {
		this.element
			.removeClass("ui-sortable ui-sortable-disabled")
			.removeData("sortable")
			.unbind(".sortable");
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- )
			this.items[i].item.removeData("sortable-item");

		return this;
	},

	_setOption: function(key, value){
		if ( key === "disabled" ) {
			this.options[ key ] = value;
	
			this.widget()
				[ value ? "addClass" : "removeClass"]( "ui-sortable-disabled" );
		} else {
			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == 'static') return false;

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, self = this, nodes = $(event.target).parents().each(function() {
			if($.data(this, 'sortable-item') == self) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, 'sortable-item') == self) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle && !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find("*").andSelf().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options, self = this;
		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { // cursor option
			if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor");
			$('body').css("cursor", o.cursor);
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')
			this.overflowOffset = this.scrollParent.offset();

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		//Post 'activate' events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("activate", event, self._uiHash(this)); }
		}

		//Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';

		//Rearrange
		for (var i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			if(itemElement != this.currentItem[0] //cannot intersect with itself
				&&	this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement //no useless actions that have been done before
				&&	!$.ui.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
				&& (this.options.type == 'semi-dynamic' ? !$.ui.contains(this.element[0], itemElement) : true)
				//&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? "down" : "up";

				if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		//Call callbacks
		this._trigger('sort', event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var self = this;
			var cur = self.placeholder.offset();

			self.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - self.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - self.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				self._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		var self = this;

		if(this.dragging) {

			this._mouseUp();

			if(this.options.helper == "original")
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			else
				this.currentItem.show();

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, self._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, self._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
		if(this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove();

		$.extend(this, {
			helper: null,
			dragging: false,
			reverting: false,
			_noFinalSort: null
		});

		if(this.domPosition.prev) {
			$(this.domPosition.prev).after(this.currentItem);
		} else {
			$(this.domPosition.parent).prepend(this.currentItem);
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));
			if(res) str.push((o.key || res[1]+'[]')+'='+(o.key && o.expression ? res[1] : res[2]));
		});

		if(!str.length && o.key) {
			str.push(o.key + '=');
		}

		return str.join('&');

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || 'id') || ''); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

		if(	   this.options.tolerance == "pointer"
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) // Right Half
				&& x2 - (this.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (this.helperProportions.height / 2) // Bottom Half
				&& y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection == "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},
	
	_getItemsAsjQuery: function(connected) {

		var self = this;
		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith && connected) {
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], 'sortable');
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]);

		for (var i = queries.length - 1; i >= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(sortable-item)");

		for (var i=0; i < this.items.length; i++) {

			for (var j=0; j < list.length; j++) {
				if(list[j] == this.items[i].item[0])
					this.items.splice(i,1);
			};

		};

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var self = this;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith) {
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], 'sortable');
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i >= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				var item = $(_queries[j]);

				item.data('sortable-item', targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i >= 0; i--){
			var item = this.items[i];

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			var p = t.offset();
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i >= 0; i--){
				var p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {

		var self = that || this, o = self.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(self.currentItem[0].nodeName))
						.addClass(className || self.currentItem[0].className+" ui-sortable-placeholder")
						.removeClass("ui-sortable-helper")[0];

					if(!className)
						el.style.visibility = "hidden";

					return el;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) return;

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(self.currentItem.innerHeight() - parseInt(self.currentItem.css('paddingTop')||0, 10) - parseInt(self.currentItem.css('paddingBottom')||0, 10)); };
					if(!p.width()) { p.width(self.currentItem.innerWidth() - parseInt(self.currentItem.css('paddingLeft')||0, 10) - parseInt(self.currentItem.css('paddingRight')||0, 10)); };
				}
			};
		}

		//Create the placeholder
		self.placeholder = $(o.placeholder.element.call(self.element, self.currentItem));

		//Append it after the actual current item
		self.currentItem.after(self.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(self, self.placeholder);

	},

	_contactContainers: function(event) {
		
		// get innermost container that intersects with item 
		var innermostContainer = null, innermostIndex = null;		
		
		
		for (var i = this.containers.length - 1; i >= 0; i--){

			// never consider a container that's located within the item itself 
			if($.ui.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue 
				if(innermostContainer && $.ui.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i]; 
				innermostIndex = i;
					
			} else {
				// container doesn't intersect. trigger "out" event if necessary 
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}
		
		// if no intersecting containers found, return 
		if(!innermostContainer) return; 

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else if(this.currentContainer != this.containers[innermostIndex]) { 

			//When entering a new container, we will find the item with the least distance and append our item near it 
			var dist = 10000; var itemWithLeastDistance = null; var base = this.positionAbs[this.containers[innermostIndex].floating ? 'left' : 'top']; 
			for (var j = this.items.length - 1; j >= 0; j--) { 
				if(!$.ui.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue; 
				var cur = this.items[j][this.containers[innermostIndex].floating ? 'left' : 'top']; 
				if(Math.abs(cur - base) < dist) { 
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j]; 
				} 
			} 

			if(!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled 
				return; 

			this.currentContainer = this.containers[innermostIndex]; 
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true); 
			this._trigger("change", event, this._uiHash()); 
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this)); 

			//Update the placeholder 
			this.options.placeholder.update(this.currentContainer, this.placeholder); 
		
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)); 
			this.containers[innermostIndex].containerCache.over = 1;
		} 
	
		
	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already
			$(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };

		if(helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var self = this, counter = this.counter;

		window.setTimeout(function() {
			if(counter == self.counter) self.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
		},0);

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var delayedTriggers = [], self = this;

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem[0].parentNode) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		if(!$.ui.contains(this.element[0], this.currentItem[0])) { //Node was moved out of the current element
			if(!noPropagation) delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
			for (var i = this.containers.length - 1; i >= 0; i--){
				if($.ui.contains(this.containers[i].element[0], this.currentItem[0]) && !noPropagation) {
					delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
					delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.containers[i]));
				}
			};
		};

		//Post events to containers
		for (var i = this.containers.length - 1; i >= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if(this._storedCursor) $('body').css("cursor", this._storedCursor); //Reset cursor
		if(this._storedOpacity) this.helper.css("opacity", this._storedOpacity); //Reset opacity
		if(this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
				for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}
			return false;
		}

		if(!noPropagation) this._trigger("beforeStop", event, this._uiHash());

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(inst) {
		var self = inst || this;
		return {
			helper: self.helper,
			placeholder: self.placeholder || $([]),
			position: self.position,
			originalPosition: self.originalPosition,
			offset: self.positionAbs,
			item: self.currentItem,
			sender: inst ? inst.element : null
		};
	}

});

$.extend($.ui.sortable, {
	version: "1.8.6"
});

})(jQuery);

/*
 * jQuery UI Button 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var lastActive,
	baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
	stateClasses = "ui-state-hover ui-state-active ",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function( event ) {
		$( ":ui-button", event.target.form ).each(function() {
			var inst = $( this ).data( "button" );
			setTimeout(function() {
				inst.refresh();
			}, 1 );
		});
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "']" );
			} else {
				radios = $( "[name='" + name + "']", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset.button" )
			.bind( "reset.button", formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = this.element.attr( "disabled" );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var self = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			hoverClass = "ui-state-hover" + ( !toggleButton ? " ui-state-active" : "" ),
			focusClass = "ui-state-focus";

		if ( options.label === null ) {
			options.label = this.buttonElement.html();
		}

		if ( this.element.is( ":disabled" ) ) {
			options.disabled = true;
		}

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter.button", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( "ui-state-hover" );
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave.button", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( hoverClass );
			})
			.bind( "focus.button", function() {
				// no need to check disabled, focus won't be triggered anyway
				$( this ).addClass( focusClass );
			})
			.bind( "blur.button", function() {
				$( this ).removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( "change.button", function() {
				self.refresh();
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click.button", function() {
				if ( options.disabled ) {
					return false;
				}
				$( this ).toggleClass( "ui-state-active" );
				self.buttonElement.attr( "aria-pressed", self.element[0].checked );
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click.button", function() {
				if ( options.disabled ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				self.buttonElement.attr( "aria-pressed", true );

				var radio = self.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", false );
			});
		} else {
			this.buttonElement
				.bind( "mousedown.button", function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					$( document ).one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup.button", function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown.button", function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode == $.ui.keyCode.SPACE || event.keyCode == $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				.bind( "keyup.button", function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget's handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
		// be overridden by individual plugins
		this._setOption( "disabled", options.disabled );
	},

	_determineButtonType: function() {
		
		if ( this.element.is(":checkbox") ) {
			this.type = "checkbox";
		} else {
			if ( this.element.is(":radio") ) {
				this.type = "radio";
			} else {
				if ( this.element.is("input") ) {
					this.type = "input";
				} else {
					this.type = "button";
				}
			}
		}
		
		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			this.buttonElement = this.element.parents().last()
				.find( "label[for=" + this.element.attr("id") + "]" );
			this.element.addClass( "ui-helper-hidden-accessible" );

			var checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.attr( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}

		$.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
		if ( key === "disabled" ) {
			if ( value ) {
				this.element.attr( "disabled", true );
			} else {
				this.element.removeAttr( "disabled" );
			}
		}
		this._resetButton();
	},

	refresh: function() {
		var isDisabled = this.element.is( ":disabled" );
		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", true );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", false );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", true );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", false );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>" )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary;
		if ( icons.primary || icons.secondary ) {
			buttonElement.addClass( "ui-button-text-icon" +
				( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
			}
			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
			}
			if ( !this.options.text ) {
				buttonElement
					.addClass( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" )
					.removeClass( "ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary" );
				if ( !this.hasTitle ) {
					buttonElement.attr( "title", buttonText );
				}
			}
		} else {
			buttonElement.addClass( "ui-button-text-only" );
		}
	}
});

$.widget( "ui.buttonset", {
	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},
	
	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		$.Widget.prototype._setOption.apply( this, arguments );
	},
	
	refresh: function() {
		this.buttons = this.element.find( ":button, :submit, :reset, :checkbox, :radio, a, :data(button)" )
			.filter( ":ui-button" )
				.button( "refresh" )
			.end()
			.not( ":ui-button" )
				.button()
			.end()
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":visible" )
					.filter( ":first" )
						.addClass( "ui-corner-left" )
					.end()
					.filter( ":last" )
						.addClass( "ui-corner-right" )
					.end()
				.end()
			.end();
	},

	destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );

		$.Widget.prototype.destroy.call( this );
	}
});

}( jQuery ) );

/*
 * jQuery UI Dialog 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Dialog
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  jquery.ui.button.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
(function( $, undefined ) {

var uiDialogClasses =
		'ui-dialog ' +
		'ui-widget ' +
		'ui-widget-content ' +
		'ui-corner-all ',
	sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	};

$.widget("ui.dialog", {
	options: {
		autoOpen: true,
		buttons: {},
		closeOnEscape: true,
		closeText: 'close',
		dialogClass: '',
		draggable: true,
		hide: null,
		height: 'auto',
		maxHeight: false,
		maxWidth: false,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: 'center',
			at: 'center',
			of: window,
			collision: 'fit',
			// ensure that the titlebar is never outside the document
			using: function(pos) {
				var topOffset = $(this).css(pos).offset().top;
				if (topOffset < 0) {
					$(this).css('top', pos.top - topOffset);
				}
			}
		},
		resizable: true,
		show: null,
		stack: true,
		title: '',
		width: 300,
		zIndex: 1000
	},

	_create: function() {
		this.originalTitle = this.element.attr('title');
		// #5742 - .attr() might return a DOMElement
		if ( typeof this.originalTitle !== "string" ) {
			this.originalTitle = "";
		}

		this.options.title = this.options.title || this.originalTitle;
		var self = this,
			options = self.options,

			title = options.title || '&#160;',
			titleId = $.ui.dialog.getTitleId(self.element),

			uiDialog = (self.uiDialog = $('<div></div>'))
				.appendTo(document.body)
				.hide()
				.addClass(uiDialogClasses + options.dialogClass)
				.css({
					zIndex: options.zIndex
				})
				// setting tabIndex makes the div focusable
				// setting outline to 0 prevents a border on focus in Mozilla
				.attr('tabIndex', -1).css('outline', 0).keydown(function(event) {
					if (options.closeOnEscape && event.keyCode &&
						event.keyCode === $.ui.keyCode.ESCAPE) {
						
						self.close(event);
						event.preventDefault();
					}
				})
				.attr({
					role: 'dialog',
					'aria-labelledby': titleId
				})
				.mousedown(function(event) {
					self.moveToTop(false, event);
				}),

			uiDialogContent = self.element
				.show()
				.removeAttr('title')
				.addClass(
					'ui-dialog-content ' +
					'ui-widget-content')
				.appendTo(uiDialog),

			uiDialogTitlebar = (self.uiDialogTitlebar = $('<div></div>'))
				.addClass(
					'ui-dialog-titlebar ' +
					'ui-widget-header ' +
					'ui-corner-all ' +
					'ui-helper-clearfix'
				)
				.prependTo(uiDialog),

			uiDialogTitlebarClose = $('<a href="#"></a>')
				.addClass(
					'ui-dialog-titlebar-close ' +
					'ui-corner-all'
				)
				.attr('role', 'button')
				.hover(
					function() {
						uiDialogTitlebarClose.addClass('ui-state-hover');
					},
					function() {
						uiDialogTitlebarClose.removeClass('ui-state-hover');
					}
				)
				.focus(function() {
					uiDialogTitlebarClose.addClass('ui-state-focus');
				})
				.blur(function() {
					uiDialogTitlebarClose.removeClass('ui-state-focus');
				})
				.click(function(event) {
					self.close(event);
					return false;
				})
				.appendTo(uiDialogTitlebar),

			uiDialogTitlebarCloseText = (self.uiDialogTitlebarCloseText = $('<span></span>'))
				.addClass(
					'ui-icon ' +
					'ui-icon-closethick'
				)
				.text(options.closeText)
				.appendTo(uiDialogTitlebarClose),

			uiDialogTitle = $('<span></span>')
				.addClass('ui-dialog-title')
				.attr('id', titleId)
				.html(title)
				.prependTo(uiDialogTitlebar);

		//handling of deprecated beforeclose (vs beforeClose) option
		//Ticket #4669 http://dev.jqueryui.com/ticket/4669
		//TODO: remove in 1.9pre
		if ($.isFunction(options.beforeclose) && !$.isFunction(options.beforeClose)) {
			options.beforeClose = options.beforeclose;
		}

		uiDialogTitlebar.find("*").add(uiDialogTitlebar).disableSelection();

		if (options.draggable && $.fn.draggable) {
			self._makeDraggable();
		}
		if (options.resizable && $.fn.resizable) {
			self._makeResizable();
		}

		self._createButtons(options.buttons);
		self._isOpen = false;

		if ($.fn.bgiframe) {
			uiDialog.bgiframe();
		}
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	destroy: function() {
		var self = this;
		
		if (self.overlay) {
			self.overlay.destroy();
		}
		self.uiDialog.hide();
		self.element
			.unbind('.dialog')
			.removeData('dialog')
			.removeClass('ui-dialog-content ui-widget-content')
			.hide().appendTo('body');
		self.uiDialog.remove();

		if (self.originalTitle) {
			self.element.attr('title', self.originalTitle);
		}

		return self;
	},

	widget: function() {
		return this.uiDialog;
	},

	close: function(event) {
		var self = this,
			maxZ;
		
		if (false === self._trigger('beforeClose', event)) {
			return;
		}

		if (self.overlay) {
			self.overlay.destroy();
		}
		self.uiDialog.unbind('keypress.ui-dialog');

		self._isOpen = false;

		if (self.options.hide) {
			self.uiDialog.hide(self.options.hide, function() {
				self._trigger('close', event);
			});
		} else {
			self.uiDialog.hide();
			self._trigger('close', event);
		}

		$.ui.dialog.overlay.resize();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		if (self.options.modal) {
			maxZ = 0;
			$('.ui-dialog').each(function() {
				if (this !== self.uiDialog[0]) {
					maxZ = Math.max(maxZ, $(this).css('z-index'));
				}
			});
			$.ui.dialog.maxZ = maxZ;
		}

		return self;
	},

	isOpen: function() {
		return this._isOpen;
	},

	// the force parameter allows us to move modal dialogs to their correct
	// position on open
	moveToTop: function(force, event) {
		var self = this,
			options = self.options,
			saveScroll;

		if ((options.modal && !force) ||
			(!options.stack && !options.modal)) {
			return self._trigger('focus', event);
		}

		if (options.zIndex > $.ui.dialog.maxZ) {
			$.ui.dialog.maxZ = options.zIndex;
		}
		if (self.overlay) {
			$.ui.dialog.maxZ += 1;
			self.overlay.$el.css('z-index', $.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ);
		}

		//Save and then restore scroll since Opera 9.5+ resets when parent z-Index is changed.
		//  http://ui.jquery.com/bugs/ticket/3193
		saveScroll = { scrollTop: self.element.attr('scrollTop'), scrollLeft: self.element.attr('scrollLeft') };
		$.ui.dialog.maxZ += 1;
		self.uiDialog.css('z-index', $.ui.dialog.maxZ);
		self.element.attr(saveScroll);
		self._trigger('focus', event);

		return self;
	},

	open: function() {
		if (this._isOpen) { return; }

		var self = this,
			options = self.options,
			uiDialog = self.uiDialog;

		self.overlay = options.modal ? new $.ui.dialog.overlay(self) : null;
		self._size();
		self._position(options.position);
		uiDialog.show(options.show);
		self.moveToTop(true);

		// prevent tabbing out of modal dialogs
		if (options.modal) {
			uiDialog.bind('keypress.ui-dialog', function(event) {
				if (event.keyCode !== $.ui.keyCode.TAB) {
					return;
				}

				var tabbables = $(':tabbable', this),
					first = tabbables.filter(':first'),
					last  = tabbables.filter(':last');

				if (event.target === last[0] && !event.shiftKey) {
					first.focus(1);
					return false;
				} else if (event.target === first[0] && event.shiftKey) {
					last.focus(1);
					return false;
				}
			});
		}

		// set focus to the first tabbable element in the content area or the first button
		// if there are no tabbable elements, set focus on the dialog itself
		$(self.element.find(':tabbable').get().concat(
			uiDialog.find('.ui-dialog-buttonpane :tabbable').get().concat(
				uiDialog.get()))).eq(0).focus();

		self._isOpen = true;
		self._trigger('open');

		return self;
	},

	_createButtons: function(buttons) {
		var self = this,
			hasButtons = false,
			uiDialogButtonPane = $('<div></div>')
				.addClass(
					'ui-dialog-buttonpane ' +
					'ui-widget-content ' +
					'ui-helper-clearfix'
				),
			uiButtonSet = $( "<div></div>" )
				.addClass( "ui-dialog-buttonset" )
				.appendTo( uiDialogButtonPane );

		// if we already have a button pane, remove it
		self.uiDialog.find('.ui-dialog-buttonpane').remove();

		if (typeof buttons === 'object' && buttons !== null) {
			$.each(buttons, function() {
				return !(hasButtons = true);
			});
		}
		if (hasButtons) {
			$.each(buttons, function(name, props) {
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				var button = $('<button type="button"></button>')
					.attr( props, true )
					.unbind('click')
					.click(function() {
						props.click.apply(self.element[0], arguments);
					})
					.appendTo(uiButtonSet);
				if ($.fn.button) {
					button.button();
				}
			});
			uiDialogButtonPane.appendTo(self.uiDialog);
		}
	},

	_makeDraggable: function() {
		var self = this,
			options = self.options,
			doc = $(document),
			heightBeforeDrag;

		function filteredUi(ui) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		self.uiDialog.draggable({
			cancel: '.ui-dialog-content, .ui-dialog-titlebar-close',
			handle: '.ui-dialog-titlebar',
			containment: 'document',
			start: function(event, ui) {
				heightBeforeDrag = options.height === "auto" ? "auto" : $(this).height();
				$(this).height($(this).height()).addClass("ui-dialog-dragging");
				self._trigger('dragStart', event, filteredUi(ui));
			},
			drag: function(event, ui) {
				self._trigger('drag', event, filteredUi(ui));
			},
			stop: function(event, ui) {
				options.position = [ui.position.left - doc.scrollLeft(),
					ui.position.top - doc.scrollTop()];
				$(this).removeClass("ui-dialog-dragging").height(heightBeforeDrag);
				self._trigger('dragStop', event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		});
	},

	_makeResizable: function(handles) {
		handles = (handles === undefined ? this.options.resizable : handles);
		var self = this,
			options = self.options,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = self.uiDialog.css('position'),
			resizeHandles = (typeof handles === 'string' ?
				handles	:
				'n,e,s,w,se,sw,ne,nw'
			);

		function filteredUi(ui) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		self.uiDialog.resizable({
			cancel: '.ui-dialog-content',
			containment: 'document',
			alsoResize: self.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: self._minHeight(),
			handles: resizeHandles,
			start: function(event, ui) {
				$(this).addClass("ui-dialog-resizing");
				self._trigger('resizeStart', event, filteredUi(ui));
			},
			resize: function(event, ui) {
				self._trigger('resize', event, filteredUi(ui));
			},
			stop: function(event, ui) {
				$(this).removeClass("ui-dialog-resizing");
				options.height = $(this).height();
				options.width = $(this).width();
				self._trigger('resizeStop', event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		})
		.css('position', position)
		.find('.ui-resizable-se').addClass('ui-icon ui-icon-grip-diagonal-se');
	},

	_minHeight: function() {
		var options = this.options;

		if (options.height === 'auto') {
			return options.minHeight;
		} else {
			return Math.min(options.minHeight, options.height);
		}
	},

	_position: function(position) {
		var myAt = [],
			offset = [0, 0],
			isVisible;

		if (position) {
			// deep extending converts arrays to objects in jQuery <= 1.3.2 :-(
	//		if (typeof position == 'string' || $.isArray(position)) {
	//			myAt = $.isArray(position) ? position : position.split(' ');

			if (typeof position === 'string' || (typeof position === 'object' && '0' in position)) {
				myAt = position.split ? position.split(' ') : [position[0], position[1]];
				if (myAt.length === 1) {
					myAt[1] = myAt[0];
				}

				$.each(['left', 'top'], function(i, offsetPosition) {
					if (+myAt[i] === myAt[i]) {
						offset[i] = myAt[i];
						myAt[i] = offsetPosition;
					}
				});

				position = {
					my: myAt.join(" "),
					at: myAt.join(" "),
					offset: offset.join(" ")
				};
			} 

			position = $.extend({}, $.ui.dialog.prototype.options.position, position);
		} else {
			position = $.ui.dialog.prototype.options.position;
		}

		// need to show the dialog to get the actual offset in the position plugin
		isVisible = this.uiDialog.is(':visible');
		if (!isVisible) {
			this.uiDialog.show();
		}
		this.uiDialog
			// workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
			.css({ top: 0, left: 0 })
			.position(position);
		if (!isVisible) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var self = this,
			resizableOptions = {},
			resize = false;

		$.each( options, function( key, value ) {
			self._setOption( key, value );
			
			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
		}
		if ( this.uiDialog.is( ":data(resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function(key, value){
		var self = this,
			uiDialog = self.uiDialog;

		switch (key) {
			//handling of deprecated beforeclose (vs beforeClose) option
			//Ticket #4669 http://dev.jqueryui.com/ticket/4669
			//TODO: remove in 1.9pre
			case "beforeclose":
				key = "beforeClose";
				break;
			case "buttons":
				self._createButtons(value);
				break;
			case "closeText":
				// ensure that we always pass a string
				self.uiDialogTitlebarCloseText.text("" + value);
				break;
			case "dialogClass":
				uiDialog
					.removeClass(self.options.dialogClass)
					.addClass(uiDialogClasses + value);
				break;
			case "disabled":
				if (value) {
					uiDialog.addClass('ui-dialog-disabled');
				} else {
					uiDialog.removeClass('ui-dialog-disabled');
				}
				break;
			case "draggable":
				var isDraggable = uiDialog.is( ":data(draggable)" )
				if ( isDraggable && !value ) {
					uiDialog.draggable( "destroy" );
				}
				
				if ( !isDraggable && value ) {
					self._makeDraggable();
				}
				break;
			case "position":
				self._position(value);
				break;
			case "resizable":
				// currently resizable, becoming non-resizable
				var isResizable = uiDialog.is( ":data(resizable)" )
				if (isResizable && !value) {
					uiDialog.resizable('destroy');
				}

				// currently resizable, changing handles
				if (isResizable && typeof value === 'string') {
					uiDialog.resizable('option', 'handles', value);
				}

				// currently non-resizable, becoming resizable
				if (!isResizable && value !== false) {
					self._makeResizable(value);
				}
				break;
			case "title":
				// convert whatever was passed in o a string, for html() to not throw up
				$(".ui-dialog-title", self.uiDialogTitlebar).html("" + (value || '&#160;'));
				break;
		}

		$.Widget.prototype._setOption.apply(self, arguments);
	},

	_size: function() {
		/* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		 * divs will both have width and height set, so we need to reset them
		 */
		var options = this.options,
			nonContentHeight,
			minContentHeight;

		// reset content sizing
		this.element.show().css({
			width: 'auto',
			minHeight: 0,
			height: 0
		});

		if (options.minWidth > options.width) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: 'auto',
				width: options.width
			})
			.height();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		
		if ( options.height === "auto" ) {
			// only needed for IE6 support
			if ( $.support.minHeight ) {
				this.element.css({
					minHeight: minContentHeight,
					height: "auto"
				});
			} else {
				this.uiDialog.show();
				var autoHeight = this.element.css( "height", "auto" ).height();
				this.uiDialog.hide();
				this.element.height( Math.max( autoHeight, minContentHeight ) );
			}
		} else {
			this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
		}

		if (this.uiDialog.is(':data(resizable)')) {
			this.uiDialog.resizable('option', 'minHeight', this._minHeight());
		}
	}
});

$.extend($.ui.dialog, {
	version: "1.8.6",

	uuid: 0,
	maxZ: 0,

	getTitleId: function($el) {
		var id = $el.attr('id');
		if (!id) {
			this.uuid += 1;
			id = this.uuid;
		}
		return 'ui-dialog-title-' + id;
	},

	overlay: function(dialog) {
		this.$el = $.ui.dialog.overlay.create(dialog);
	}
});

$.extend($.ui.dialog.overlay, {
	instances: [],
	// reuse old instances due to IE memory leak with alpha transparency (see #5185)
	oldInstances: [],
	maxZ: 0,
	events: $.map('focus,mousedown,mouseup,keydown,keypress,click'.split(','),
		function(event) { return event + '.dialog-overlay'; }).join(' '),
	create: function(dialog) {
		if (this.instances.length === 0) {
			// prevent use of anchors and inputs
			// we use a setTimeout in case the overlay is created from an
			// event that we're going to be cancelling (see #2804)
			setTimeout(function() {
				// handle $(el).dialog().dialog('close') (see #4065)
				if ($.ui.dialog.overlay.instances.length) {
					$(document).bind($.ui.dialog.overlay.events, function(event) {
						// stop events if the z-index of the target is < the z-index of the overlay
						// we cannot return true when we don't want to cancel the event (#3523)
						if ($(event.target).zIndex() < $.ui.dialog.overlay.maxZ) {
							return false;
						}
					});
				}
			}, 1);

			// allow closing by pressing the escape key
			$(document).bind('keydown.dialog-overlay', function(event) {
				if (dialog.options.closeOnEscape && event.keyCode &&
					event.keyCode === $.ui.keyCode.ESCAPE) {
					
					dialog.close(event);
					event.preventDefault();
				}
			});

			// handle window resize
			$(window).bind('resize.dialog-overlay', $.ui.dialog.overlay.resize);
		}

		var $el = (this.oldInstances.pop() || $('<div></div>').addClass('ui-widget-overlay'))
			.appendTo(document.body)
			.css({
				width: this.width(),
				height: this.height()
			});

		if ($.fn.bgiframe) {
			$el.bgiframe();
		}

		this.instances.push($el);
		return $el;
	},

	destroy: function($el) {
		this.oldInstances.push(this.instances.splice($.inArray($el, this.instances), 1)[0]);

		if (this.instances.length === 0) {
			$([document, window]).unbind('.dialog-overlay');
		}

		$el.remove();
		
		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		var maxZ = 0;
		$.each(this.instances, function() {
			maxZ = Math.max(maxZ, this.css('z-index'));
		});
		this.maxZ = maxZ;
	},

	height: function() {
		var scrollHeight,
			offsetHeight;
		// handle IE 6
		if ($.browser.msie && $.browser.version < 7) {
			scrollHeight = Math.max(
				document.documentElement.scrollHeight,
				document.body.scrollHeight
			);
			offsetHeight = Math.max(
				document.documentElement.offsetHeight,
				document.body.offsetHeight
			);

			if (scrollHeight < offsetHeight) {
				return $(window).height() + 'px';
			} else {
				return scrollHeight + 'px';
			}
		// handle "good" browsers
		} else {
			return $(document).height() + 'px';
		}
	},

	width: function() {
		var scrollWidth,
			offsetWidth;
		// handle IE 6
		if ($.browser.msie && $.browser.version < 7) {
			scrollWidth = Math.max(
				document.documentElement.scrollWidth,
				document.body.scrollWidth
			);
			offsetWidth = Math.max(
				document.documentElement.offsetWidth,
				document.body.offsetWidth
			);

			if (scrollWidth < offsetWidth) {
				return $(window).width() + 'px';
			} else {
				return scrollWidth + 'px';
			}
		// handle "good" browsers
		} else {
			return $(document).width() + 'px';
		}
	},

	resize: function() {
		/* If the dialog is draggable and the user drags it past the
		 * right edge of the window, the document becomes wider so we
		 * need to stretch the overlay. If the user then drags the
		 * dialog back to the left, the document will become narrower,
		 * so we need to shrink the overlay to the appropriate size.
		 * This is handled by shrinking the overlay before setting it
		 * to the full document size.
		 */
		var $overlays = $([]);
		$.each($.ui.dialog.overlay.instances, function() {
			$overlays = $overlays.add(this);
		});

		$overlays.css({
			width: 0,
			height: 0
		}).css({
			width: $.ui.dialog.overlay.width(),
			height: $.ui.dialog.overlay.height()
		});
	}
});

$.extend($.ui.dialog.overlay.prototype, {
	destroy: function() {
		$.ui.dialog.overlay.destroy(this.$el);
	}
});

}(jQuery));

/*
 * jQuery UI Progressbar 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Progressbar
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget( "ui.progressbar", {
	options: {
		value: 0
	},

	min: 0,
	max: 100,

	_create: function() {
		this.element
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.attr({
				role: "progressbar",
				"aria-valuemin": this.min,
				"aria-valuemax": this.max,
				"aria-valuenow": this._value()
			});

		this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
			.appendTo( this.element );

		this._refreshValue();
	},

	destroy: function() {
		this.element
			.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();

		$.Widget.prototype.destroy.apply( this, arguments );
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this._value();
		}

		this._setOption( "value", newValue );
		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "value" ) {
			this.options.value = value;
			this._refreshValue();
			this._trigger( "change" );
			if ( this._value() === this.max ) {
				this._trigger( "complete" );
			}
		}

		$.Widget.prototype._setOption.apply( this, arguments );
	},

	_value: function() {
		var val = this.options.value;
		// normalize invalid value
		if ( typeof val !== "number" ) {
			val = 0;
		}
		return Math.min( this.max, Math.max( this.min, val ) );
	},

	_refreshValue: function() {
		var value = this.value();
		this.valueDiv
			.toggleClass( "ui-corner-right", value === this.max )
			.width( value + "%" );
		this.element.attr( "aria-valuenow", value );
	}
});

$.extend( $.ui.progressbar, {
	version: "1.8.6"
});

})( jQuery );

/*
 * jQuery UI Datepicker 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.8.6" } });

var PROP_NAME = 'datepicker';
var dpuuid = new Date().getTime();

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this.debug = false; // Change this to true to start debugging
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division
	this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class
	this._appendClass = 'ui-datepicker-append'; // The name of the append marker class
	this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class
	this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class
	this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class
	this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class
	this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class
	this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[''] = { // Default regional settings
		closeText: 'Done', // Display text for close link
		prevText: 'Prev', // Display text for previous month link
		nextText: 'Next', // Display text for next month link
		currentText: 'Today', // Display text for current month link
		monthNames: ['January','February','March','April','May','June',
			'July','August','September','October','November','December'], // Names of months for drop-down and formatting
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday
		weekHeader: 'Wk', // Column header for week of the year
		dateFormat: 'mm/dd/yy', // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: '' // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: 'focus', // 'focus' for popup on focus,
			// 'button' for trigger button, or 'both' for either
		showAnim: 'fadeIn', // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: '', // Display text following the input box, e.g. showing the format
		buttonText: '...', // Text for trigger button
		buttonImage: '', // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: 'c-10:c+10', // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: '+10', // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with '+' for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: 'fast', // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or '',
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: '', // Selector for an alternate field to store selected dates into
		altFormat: '', // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false // True to size the input for the date format, false to leave as is
	};
	$.extend(this._defaults, this.regional['']);
	this.dpDiv = $('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all ui-helper-hidden-accessible"></div>');
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: 'hasDatepicker',

	/* Debug logging (if enabled). */
	log: function () {
		if (this.debug)
			console.log.apply('', arguments);
	},
	
	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	   @param  settings  object - the new settings to use as defaults (anonymous object)
	   @return the manager object */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span
	   @param  settings  object - the new settings to use for this date picker instance (anonymous) */
	_attachDatepicker: function(target, settings) {
		// check for settings on the control itself - in namespace 'date:'
		var inlineSettings = null;
		for (var attrName in this._defaults) {
			var attrValue = target.getAttribute('date:' + attrName);
			if (attrValue) {
				inlineSettings = inlineSettings || {};
				try {
					inlineSettings[attrName] = eval(attrValue);
				} catch (err) {
					inlineSettings[attrName] = attrValue;
				}
			}
		}
		var nodeName = target.nodeName.toLowerCase();
		var inline = (nodeName == 'div' || nodeName == 'span');
		if (!target.id) {
			this.uuid += 1;
			target.id = 'dp' + this.uuid;
		}
		var inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {}, inlineSettings || {});
		if (nodeName == 'input') {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			$('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName))
			return;
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp).
			bind("setData.datepicker", function(event, key, value) {
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key) {
				return this._get(inst, key);
			});
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var appendText = this._get(inst, 'appendText');
		var isRTL = this._get(inst, 'isRTL');
		if (inst.append)
			inst.append.remove();
		if (appendText) {
			inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
			input[isRTL ? 'before' : 'after'](inst.append);
		}
		input.unbind('focus', this._showDatepicker);
		if (inst.trigger)
			inst.trigger.remove();
		var showOn = this._get(inst, 'showOn');
		if (showOn == 'focus' || showOn == 'both') // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		if (showOn == 'button' || showOn == 'both') { // pop-up date picker when button clicked
			var buttonText = this._get(inst, 'buttonText');
			var buttonImage = this._get(inst, 'buttonImage');
			inst.trigger = $(this._get(inst, 'buttonImageOnly') ?
				$('<img/>').addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$('<button type="button"></button>').addClass(this._triggerClass).
					html(buttonImage == '' ? buttonText : $('<img/>').attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? 'before' : 'after'](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput == input[0])
					$.datepicker._hideDatepicker();
				else
					$.datepicker._showDatepicker(input[0]);
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, 'autoSize') && !inst.inline) {
			var date = new Date(2009, 12 - 1, 20); // Ensure double digits
			var dateFormat = this._get(inst, 'dateFormat');
			if (dateFormat.match(/[DM]/)) {
				var findMax = function(names) {
					var max = 0;
					var maxI = 0;
					for (var i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					'monthNames' : 'monthNamesShort'))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					'dayNames' : 'dayNamesShort'))) + 20 - date.getDay());
			}
			inst.input.attr('size', this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName))
			return;
		divSpan.addClass(this.markerClassName).append(inst.dpDiv).
			bind("setData.datepicker", function(event, key, value){
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key){
				return this._get(inst, key);
			});
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
	},

	/* Pop-up the date picker in a "dialog" box.
	   @param  input     element - ignored
	   @param  date      string or Date - the initial date to display
	   @param  onSelect  function - the function to call when a date is selected
	   @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	   @param  pos       int[2] - coordinates for the dialog's position within the screen or
	                     event - with x/y coordinates or
	                     leave empty for default (screen centre)
	   @return the manager object */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var inst = this._dialogInst; // internal instance
		if (!inst) {
			this.uuid += 1;
			var id = 'dp' + this.uuid;
			this._dialogInput = $('<input type="text" id="' + id +
				'" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>');
			this._dialogInput.keydown(this._doKeyDown);
			$('body').append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor == Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			var browserWidth = document.documentElement.clientWidth;
			var browserHeight = document.documentElement.clientHeight;
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px');
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI)
			$.blockUI(this.dpDiv);
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	   @param  target    element - the target input field or division or span */
	_destroyDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName == 'input') {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind('focus', this._showDatepicker).
				unbind('keydown', this._doKeyDown).
				unbind('keypress', this._doKeyPress).
				unbind('keyup', this._doKeyUp);
		} else if (nodeName == 'div' || nodeName == 'span')
			$target.removeClass(this.markerClassName).empty();
	},

	/* Enable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_enableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = false;
			inst.trigger.filter('button').
				each(function() { this.disabled = false; }).end().
				filter('img').css({opacity: '1.0', cursor: ''});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().removeClass('ui-state-disabled');
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_disableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = true;
			inst.trigger.filter('button').
				each(function() { this.disabled = true; }).end().
				filter('img').css({opacity: '0.5', cursor: 'default'});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().addClass('ui-state-disabled');
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	   @param  target    element - the target input field or division or span
	   @return boolean - true if disabled, false if enabled */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] == target)
				return true;
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	   @param  target  element - the target input field or division or span
	   @return  object - the associated instance data
	   @throws  error if a jQuery problem getting data */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw 'Missing instance data for this datepicker';
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span
	   @param  name    object - the new settings to update or
	                   string - the name of the setting to change or retrieve,
	                   when retrieving also 'all' for all instance settings or
	                   'defaults' for all global defaults
	   @param  value   any - the new value for the setting
	                   (omit if above is an object or to retrieve a value) */
	_optionDatepicker: function(target, name, value) {
		var inst = this._getInst(target);
		if (arguments.length == 2 && typeof name == 'string') {
			return (name == 'defaults' ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name == 'all' ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}
		var settings = name || {};
		if (typeof name == 'string') {
			settings = {};
			settings[name] = value;
		}
		if (inst) {
			if (this._curInst == inst) {
				this._hideDatepicker();
			}
			var date = this._getDateDatepicker(target, true);
			extendRemove(inst.settings, settings);
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDateDatepicker(target, date);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	   @param  target   element - the target input field or division or span
	   @param  date     Date - the new date */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	   @param  target     element - the target input field or division or span
	   @param  noDefault  boolean - true if no default date is to be used
	   @return Date - the current date */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline)
			this._setDateFromField(inst, noDefault);
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var inst = $.datepicker._getInst(event.target);
		var handled = true;
		var isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing)
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: var sel = $('td.' + $.datepicker._dayOverClass, inst.dpDiv).
							add($('td.' + $.datepicker._currentClass, inst.dpDiv));
						if (sel[0])
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						else
							$.datepicker._hideDatepicker();
						return false; // don't submit the form
						break; // select the value on enter
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, 'stepBigMonths') :
							-$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, 'stepBigMonths') :
							+$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, 'stepBigMonths') :
									-$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, 'stepBigMonths') :
									+$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		else if (event.keyCode == 36 && event.ctrlKey) // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		else {
			handled = false;
		}
		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if ($.datepicker._get(inst, 'constrainInput')) {
			var chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
			var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
			return event.ctrlKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if (inst.input.val() != inst.lastVal) {
			try {
				var date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));
				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (event) {
				$.datepicker.log(event);
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	   @param  input  element - the input field attached to the date picker or
	                  event - if triggered by focus */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() != 'input') // find from button/image trigger
			input = $('input', input.parentNode)[0];
		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) // already here
			return;
		var inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst != inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
		}
		var beforeShow = $.datepicker._get(inst, 'beforeShow');
		extendRemove(inst.settings, (beforeShow ? beforeShow.apply(input, [input, inst]) : {}));
		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);
		if ($.datepicker._inDialog) // hide cursor
			input.value = '';
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}
		var isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css('position') == 'fixed';
			return !isFixed;
		});
		if (isFixed && $.browser.opera) { // correction for Opera when fixed and scrolled
			$.datepicker._pos[0] -= document.documentElement.scrollLeft;
			$.datepicker._pos[1] -= document.documentElement.scrollTop;
		}
		var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		// determine sizing offscreen
		inst.dpDiv.css({position: 'absolute', display: 'block', top: '-1000px'});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
			left: offset.left + 'px', top: offset.top + 'px'});
		if (!inst.inline) {
			var showAnim = $.datepicker._get(inst, 'showAnim');
			var duration = $.datepicker._get(inst, 'duration');
			var postProcess = function() {
				$.datepicker._datepickerShowing = true;
				var borders = $.datepicker._getBorders(inst.dpDiv);
				inst.dpDiv.find('iframe.ui-datepicker-cover'). // IE6- only
					css({left: -borders[0], top: -borders[1],
						width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
			};
			inst.dpDiv.zIndex($(input).zIndex()+1);
			if ($.effects && $.effects[showAnim])
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);
			if (!showAnim || !duration)
				postProcess();
			if (inst.input.is(':visible') && !inst.input.is(':disabled'))
				inst.input.focus();
			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		var self = this;
		var borders = $.datepicker._getBorders(inst.dpDiv);
		inst.dpDiv.empty().append(this._generateHTML(inst))
			.find('iframe.ui-datepicker-cover') // IE6- only
				.css({left: -borders[0], top: -borders[1],
					width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
			.end()
			.find('button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a')
				.bind('mouseout', function(){
					$(this).removeClass('ui-state-hover');
					if(this.className.indexOf('ui-datepicker-prev') != -1) $(this).removeClass('ui-datepicker-prev-hover');
					if(this.className.indexOf('ui-datepicker-next') != -1) $(this).removeClass('ui-datepicker-next-hover');
				})
				.bind('mouseover', function(){
					if (!self._isDisabledDatepicker( inst.inline ? inst.dpDiv.parent()[0] : inst.input[0])) {
						$(this).parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
						$(this).addClass('ui-state-hover');
						if(this.className.indexOf('ui-datepicker-prev') != -1) $(this).addClass('ui-datepicker-prev-hover');
						if(this.className.indexOf('ui-datepicker-next') != -1) $(this).addClass('ui-datepicker-next-hover');
					}
				})
			.end()
			.find('.' + this._dayOverClass + ' a')
				.trigger('mouseover')
			.end();
		var numMonths = this._getNumberOfMonths(inst);
		var cols = numMonths[1];
		var width = 17;
		if (cols > 1)
			inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em');
		else
			inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
		inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') +
			'Class']('ui-datepicker-multi');
		inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') +
			'Class']('ui-datepicker-rtl');
		if (inst == $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
				inst.input.is(':visible') && !inst.input.is(':disabled'))
			inst.input.focus();
	},

	/* Retrieve the size of left and top borders for an element.
	   @param  elem  (jQuery object) the element of interest
	   @return  (number[2]) the left and top borders */
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css('border-left-width'))),
			parseFloat(convert(elem.css('border-top-width')))];
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth();
		var dpHeight = inst.dpDiv.outerHeight();
		var inputWidth = inst.input ? inst.input.outerWidth() : 0;
		var inputHeight = inst.input ? inst.input.outerHeight() : 0;
		var viewWidth = document.documentElement.clientWidth + $(document).scrollLeft();
		var viewHeight = document.documentElement.clientHeight + $(document).scrollTop();

		offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var inst = this._getInst(obj);
		var isRTL = this._get(inst, 'isRTL');
        while (obj && (obj.type == 'hidden' || obj.nodeType != 1)) {
            obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
        }
        var position = $(obj).offset();
	    return [position.left, position.top];
	},

	/* Hide the date picker from view.
	   @param  input  element - the input field attached to the date picker */
	_hideDatepicker: function(input) {
		var inst = this._curInst;
		if (!inst || (input && inst != $.data(input, PROP_NAME)))
			return;
		if (this._datepickerShowing) {
			var showAnim = this._get(inst, 'showAnim');
			var duration = this._get(inst, 'duration');
			var postProcess = function() {
				$.datepicker._tidyDialog(inst);
				this._curInst = null;
			};
			if ($.effects && $.effects[showAnim])
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' :
					(showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
			if (!showAnim)
				postProcess();
			var onClose = this._get(inst, 'onClose');
			if (onClose)
				onClose.apply((inst.input ? inst.input[0] : null),
					[(inst.input ? inst.input.val() : ''), inst]);  // trigger custom callback
			this._datepickerShowing = false;
			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
				if ($.blockUI) {
					$.unblockUI();
					$('body').append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst)
			return;
		var $target = $(event.target);
		if ($target[0].id != $.datepicker._mainDivId &&
				$target.parents('#' + $.datepicker._mainDivId).length == 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.hasClass($.datepicker._triggerClass) &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI))
			$.datepicker._hideDatepicker();
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		}
		else {
			var date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		inst._selectingMonthYear = false;
		inst['selected' + (period == 'M' ? 'Month' : 'Year')] =
		inst['draw' + (period == 'M' ? 'Month' : 'Year')] =
			parseInt(select.options[select.selectedIndex].value,10);
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Restore input focus after not changing month/year. */
	_clickMonthYear: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (inst.input && inst._selectingMonthYear) {
			setTimeout(function() {
				inst.input.focus();
			}, 0);
		}
		inst._selectingMonthYear = !inst._selectingMonthYear;
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var target = $(id);
		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}
		var inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $('a', td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		this._selectDate(target, '');
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, 'onSelect');
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		else if (inst.input)
			inst.input.trigger('change'); // fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != 'object')
				inst.input.focus(); // restore focus
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altField = this._get(inst, 'altField');
		if (altField) { // update alternate field too
			var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
			var date = this._getDate(inst);
			var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	   @param  date  Date - the date to customise
	   @return [boolean, string] - is this date selectable?, what is its CSS class? */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ''];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   @param  date  Date - the date to get the week for
	   @return  number - the number of the week within the year that contains this date */
	iso8601Week: function(date) {
		var checkDate = new Date(date.getTime());
		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
		var time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	   See formatDate below for the possible formats.

	   @param  format    string - the expected format of the date
	   @param  value     string - the date in the above format
	   @param  settings  Object - attributes include:
	                     shortYearCutoff  number - the cutoff year for determining the century (optional)
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  Date - the extracted date value or null if value is blank */
	parseDate: function (format, value, settings) {
		if (format == null || value == null)
			throw 'Invalid arguments';
		value = (typeof value == 'object' ? value.toString() : value + '');
		if (value == '')
			return null;
		var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		var year = -1;
		var month = -1;
		var day = -1;
		var doy = -1;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Extract a number from the string value
		var getNumber = function(match) {
			lookAhead(match);
			var size = (match == '@' ? 14 : (match == '!' ? 20 :
				(match == 'y' ? 4 : (match == 'o' ? 3 : 2))));
			var digits = new RegExp('^\\d{1,' + size + '}');
			var num = value.substring(iValue).match(digits);
			if (!num)
				throw 'Missing number at position ' + iValue;
			iValue += num[0].length;
			return parseInt(num[0], 10);
		};
		// Extract a name from the string value and convert to an index
		var getName = function(match, shortNames, longNames) {
			var names = (lookAhead(match) ? longNames : shortNames);
			for (var i = 0; i < names.length; i++) {
				if (value.substr(iValue, names[i].length).toLowerCase() == names[i].toLowerCase()) {
					iValue += names[i].length;
					return i + 1;
				}
			}
			throw 'Unknown name at position ' + iValue;
		};
		// Confirm that a literal character matches the string value
		var checkLiteral = function() {
			if (value.charAt(iValue) != format.charAt(iFormat))
				throw 'Unexpected literal at position ' + iValue;
			iValue++;
		};
		var iValue = 0;
		for (var iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					checkLiteral();
			else
				switch (format.charAt(iFormat)) {
					case 'd':
						day = getNumber('d');
						break;
					case 'D':
						getName('D', dayNamesShort, dayNames);
						break;
					case 'o':
						doy = getNumber('o');
						break;
					case 'm':
						month = getNumber('m');
						break;
					case 'M':
						month = getName('M', monthNamesShort, monthNames);
						break;
					case 'y':
						year = getNumber('y');
						break;
					case '@':
						var date = new Date(getNumber('@'));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case '!':
						var date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'"))
							checkLiteral();
						else
							literal = true;
						break;
					default:
						checkLiteral();
				}
		}
		if (year == -1)
			year = new Date().getFullYear();
		else if (year < 100)
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				var dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim)
					break;
				month++;
				day -= dim;
			} while (true);
		}
		var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
			throw 'Invalid date'; // E.g. 31/02/*
		return date;
	},

	/* Standard date formats. */
	ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)
	COOKIE: 'D, dd M yy',
	ISO_8601: 'yy-mm-dd',
	RFC_822: 'D, d M y',
	RFC_850: 'DD, dd-M-y',
	RFC_1036: 'D, d M y',
	RFC_1123: 'D, d M yy',
	RFC_2822: 'D, d M yy',
	RSS: 'D, d M y', // RFC 822
	TICKS: '!',
	TIMESTAMP: '@',
	W3C: 'yy-mm-dd', // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	   The format can be combinations of the following:
	   d  - day of month (no leading zero)
	   dd - day of month (two digit)
	   o  - day of year (no leading zeros)
	   oo - day of year (three digit)
	   D  - day name short
	   DD - day name long
	   m  - month of year (no leading zero)
	   mm - month of year (two digit)
	   M  - month name short
	   MM - month name long
	   y  - year (two digit)
	   yy - year (four digit)
	   @ - Unix timestamp (ms since 01/01/1970)
	   ! - Windows ticks (100ns since 01/01/0001)
	   '...' - literal text
	   '' - single quote

	   @param  format    string - the desired format of the date
	   @param  date      Date - the date value to format
	   @param  settings  Object - attributes include:
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  string - the date in the above format */
	formatDate: function (format, date, settings) {
		if (!date)
			return '';
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Format a number, with leading zero if necessary
		var formatNumber = function(match, value, len) {
			var num = '' + value;
			if (lookAhead(match))
				while (num.length < len)
					num = '0' + num;
			return num;
		};
		// Format a name, short or long as requested
		var formatName = function(match, value, shortNames, longNames) {
			return (lookAhead(match) ? longNames[value] : shortNames[value]);
		};
		var output = '';
		var literal = false;
		if (date)
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal)
					if (format.charAt(iFormat) == "'" && !lookAhead("'"))
						literal = false;
					else
						output += format.charAt(iFormat);
				else
					switch (format.charAt(iFormat)) {
						case 'd':
							output += formatNumber('d', date.getDate(), 2);
							break;
						case 'D':
							output += formatName('D', date.getDay(), dayNamesShort, dayNames);
							break;
						case 'o':
							output += formatNumber('o',
								(date.getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000, 3);
							break;
						case 'm':
							output += formatNumber('m', date.getMonth() + 1, 2);
							break;
						case 'M':
							output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
							break;
						case 'y':
							output += (lookAhead('y') ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);
							break;
						case '@':
							output += date.getTime();
							break;
						case '!':
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'"))
								output += "'";
							else
								literal = true;
							break;
						default:
							output += format.charAt(iFormat);
					}
			}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var chars = '';
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		for (var iFormat = 0; iFormat < format.length; iFormat++)
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					chars += format.charAt(iFormat);
			else
				switch (format.charAt(iFormat)) {
					case 'd': case 'm': case 'y': case '@':
						chars += '0123456789';
						break;
					case 'D': case 'M':
						return null; // Accept anything
					case "'":
						if (lookAhead("'"))
							chars += "'";
						else
							literal = true;
						break;
					default:
						chars += format.charAt(iFormat);
				}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() == inst.lastVal) {
			return;
		}
		var dateFormat = this._get(inst, 'dateFormat');
		var dates = inst.lastVal = inst.input ? inst.input.val() : null;
		var date, defaultDate;
		date = defaultDate = this._getDefaultDate(inst);
		var settings = this._getFormatConfig(inst);
		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			this.log(event);
			dates = (noDefault ? '' : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
			var date = new Date();
			date.setDate(date.getDate() + offset);
			return date;
		};
		var offsetString = function(offset) {
			try {
				return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					offset, $.datepicker._getFormatConfig(inst));
			}
			catch (e) {
				// Ignore
			}
			var date = (offset.toLowerCase().match(/^c/) ?
				$.datepicker._getDate(inst) : null) || new Date();
			var year = date.getFullYear();
			var month = date.getMonth();
			var day = date.getDate();
			var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
			var matches = pattern.exec(offset);
			while (matches) {
				switch (matches[2] || 'd') {
					case 'd' : case 'D' :
						day += parseInt(matches[1],10); break;
					case 'w' : case 'W' :
						day += parseInt(matches[1],10) * 7; break;
					case 'm' : case 'M' :
						month += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
					case 'y': case 'Y' :
						year += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
				}
				matches = pattern.exec(offset);
			}
			return new Date(year, month, day);
		};
		date = (date == null ? defaultDate : (typeof date == 'string' ? offsetString(date) :
			(typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : date)));
		date = (date && date.toString() == 'Invalid Date' ? defaultDate : date);
		if (date) {
			date.setHours(0);
			date.setMinutes(0);
			date.setSeconds(0);
			date.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(date);
	},

	/* Handle switch to/from daylight saving.
	   Hours may be non-zero on daylight saving cut-over:
	   > 12 when midnight changeover, but then cannot generate
	   midnight datetime, so jump to 1AM, otherwise reset.
	   @param  date  (Date) the date to check
	   @return  (Date) the corrected date */
	_daylightSavingAdjust: function(date) {
		if (!date) return null;
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !(date);
		var origMonth = inst.selectedMonth;
		var origYear = inst.selectedYear;
		date = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
		inst.selectedDay = inst.currentDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = date.getFullYear();
		if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange)
			this._notifyChange(inst);
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? '' : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() == '') ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var today = new Date();
		today = this._daylightSavingAdjust(
			new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
		var isRTL = this._get(inst, 'isRTL');
		var showButtonPanel = this._get(inst, 'showButtonPanel');
		var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext');
		var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat');
		var numMonths = this._getNumberOfMonths(inst);
		var showCurrentAtPos = this._get(inst, 'showCurrentAtPos');
		var stepMonths = this._get(inst, 'stepMonths');
		var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
		var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
			new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var drawMonth = inst.drawMonth - showCurrentAtPos;
		var drawYear = inst.drawYear;
		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;
		var prevText = this._get(inst, 'prevText');
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));
		var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-prev ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._adjustDate(\'#' + inst.id + '\', -' + stepMonths + ', \'M\');"' +
			' title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+ prevText +'"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>'));
		var nextText = this._get(inst, 'nextText');
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));
		var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-next ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._adjustDate(\'#' + inst.id + '\', +' + stepMonths + ', \'M\');"' +
			' title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+ nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>'));
		var currentText = this._get(inst, 'currentText');
		var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
		var controls = (!inst.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._hideDatepicker();">' + this._get(inst, 'closeText') + '</button>' : '');
		var buttonPanel = (showButtonPanel) ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (isRTL ? controls : '') +
			(this._isInRange(inst, gotoDate) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._gotoToday(\'#' + inst.id + '\');"' +
			'>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
		var firstDay = parseInt(this._get(inst, 'firstDay'),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);
		var showWeek = this._get(inst, 'showWeek');
		var dayNames = this._get(inst, 'dayNames');
		var dayNamesShort = this._get(inst, 'dayNamesShort');
		var dayNamesMin = this._get(inst, 'dayNamesMin');
		var monthNames = this._get(inst, 'monthNames');
		var monthNamesShort = this._get(inst, 'monthNamesShort');
		var beforeShowDay = this._get(inst, 'beforeShowDay');
		var showOtherMonths = this._get(inst, 'showOtherMonths');
		var selectOtherMonths = this._get(inst, 'selectOtherMonths');
		var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week;
		var defaultDate = this._getDefaultDate(inst);
		var html = '';
		for (var row = 0; row < numMonths[0]; row++) {
			var group = '';
			for (var col = 0; col < numMonths[1]; col++) {
				var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				var cornerClass = ' ui-corner-all';
				var calender = '';
				if (isMultiMonth) {
					calender += '<div class="ui-datepicker-group';
					if (numMonths[1] > 1)
						switch (col) {
							case 0: calender += ' ui-datepicker-group-first';
								cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break;
							case numMonths[1]-1: calender += ' ui-datepicker-group-last';
								cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break;
							default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break;
						}
					calender += '">';
				}
				calender += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '">' +
					(/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') +
					(/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					'</div><table class="ui-datepicker-calendar"><thead>' +
					'<tr>';
				var thead = (showWeek ? '<th class="ui-datepicker-week-col">' + this._get(inst, 'weekHeader') + '</th>' : '');
				for (var dow = 0; dow < 7; dow++) { // days of the week
					var day = (dow + firstDay) % 7;
					thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : '') + '>' +
						'<span title="' + dayNames[day] + '">' + dayNamesMin[day] + '</span></th>';
				}
				calender += thead + '</tr></thead><tbody>';
				var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth)
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				var numRows = (isMultiMonth ? 6 : Math.ceil((leadDays + daysInMonth) / 7)); // calculate the number of rows to generate
				var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (var dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += '<tr>';
					var tbody = (!showWeek ? '' : '<td class="ui-datepicker-week-col">' +
						this._get(inst, 'calculateWeek')(printDate) + '</td>');
					for (var dow = 0; dow < 7; dow++) { // create date picker days
						var daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']);
						var otherMonth = (printDate.getMonth() != drawMonth);
						var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += '<td class="' +
							((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends
							(otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months
							((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							' ' + this._dayOverClass : '') + // highlight selected day
							(unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled': '') +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates
							(printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day
							(printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '"' + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? ' title="' + daySettings[2] + '"' : '') + // cell title
							(unselectable ? '' : ' onclick="DP_jQuery_' + dpuuid + '.datepicker._selectDay(\'#' +
							inst.id + '\',' + printDate.getMonth() + ',' + printDate.getFullYear() + ', this);return false;"') + '>' + // actions
							(otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months
							(unselectable ? '<span class="ui-state-default">' + printDate.getDate() + '</span>' : '<a class="ui-state-default' +
							(printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') +
							(printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day
							(otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months
							'" href="#">' + printDate.getDate() + '</a>')) + '</td>'; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + '</tr>';
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += '</tbody></table>' + (isMultiMonth ? '</div>' + 
							((numMonths[0] > 0 && col == numMonths[1]-1) ? '<div class="ui-datepicker-row-break"></div>' : '') : '');
				group += calender;
			}
			html += group;
		}
		html += buttonPanel + ($.browser.msie && parseInt($.browser.version,10) < 7 && !inst.inline ?
			'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : '');
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {
		var changeMonth = this._get(inst, 'changeMonth');
		var changeYear = this._get(inst, 'changeYear');
		var showMonthAfterYear = this._get(inst, 'showMonthAfterYear');
		var html = '<div class="ui-datepicker-title">';
		var monthHtml = '';
		// month selection
		if (secondary || !changeMonth)
			monthHtml += '<span class="ui-datepicker-month">' + monthNames[drawMonth] + '</span>';
		else {
			var inMinYear = (minDate && minDate.getFullYear() == drawYear);
			var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);
			monthHtml += '<select class="ui-datepicker-month" ' +
				'onchange="DP_jQuery_' + dpuuid + '.datepicker._selectMonthYear(\'#' + inst.id + '\', this, \'M\');" ' +
				'onclick="DP_jQuery_' + dpuuid + '.datepicker._clickMonthYear(\'#' + inst.id + '\');"' +
			 	'>';
			for (var month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) &&
						(!inMaxYear || month <= maxDate.getMonth()))
					monthHtml += '<option value="' + month + '"' +
						(month == drawMonth ? ' selected="selected"' : '') +
						'>' + monthNamesShort[month] + '</option>';
			}
			monthHtml += '</select>';
		}
		if (!showMonthAfterYear)
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
		// year selection
		if (secondary || !changeYear)
			html += '<span class="ui-datepicker-year">' + drawYear + '</span>';
		else {
			// determine range of years to display
			var years = this._get(inst, 'yearRange').split(':');
			var thisYear = new Date().getFullYear();
			var determineYear = function(value) {
				var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
					(value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
					parseInt(value, 10)));
				return (isNaN(year) ? thisYear : year);
			};
			var year = determineYear(years[0]);
			var endYear = Math.max(year, determineYear(years[1] || ''));
			year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
			endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
			html += '<select class="ui-datepicker-year" ' +
				'onchange="DP_jQuery_' + dpuuid + '.datepicker._selectMonthYear(\'#' + inst.id + '\', this, \'Y\');" ' +
				'onclick="DP_jQuery_' + dpuuid + '.datepicker._clickMonthYear(\'#' + inst.id + '\');"' +
				'>';
			for (; year <= endYear; year++) {
				html += '<option value="' + year + '"' +
					(year == drawYear ? ' selected="selected"' : '') +
					'>' + year + '</option>';
			}
			html += '</select>';
		}
		html += this._get(inst, 'yearSuffix');
		if (showMonthAfterYear)
			html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
		html += '</div>'; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period == 'Y' ? offset : 0);
		var month = inst.drawMonth + (period == 'M' ? offset : 0);
		var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
			(period == 'D' ? offset : 0);
		var date = this._restrictMinMax(inst,
			this._daylightSavingAdjust(new Date(year, month, day)));
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period == 'M' || period == 'Y')
			this._notifyChange(inst);
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		date = (minDate && date < minDate ? minDate : date);
		date = (maxDate && date > maxDate ? maxDate : date);
		return date;
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, 'onChangeMonthYear');
		if (onChange)
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, 'numberOfMonths');
		return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - new Date(year, month, 32).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst);
		var date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
		if (offset < 0)
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, 'shortYearCutoff');
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'),
			monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames')};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day == 'object' ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
	}
});

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props)
		if (props[name] == null || props[name] == undefined)
			target[name] = props[name];
	return target;
};

/* Determine whether an object is an array. */
function isArray(a) {
	return (a && (($.browser.safari && typeof a == 'object' && a.length) ||
		(a.constructor && a.constructor.toString().match(/\Array\(\)/))));
};

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
                    Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick).
			find('body').append($.datepicker.dpDiv);
		$.datepicker.initialized = true;
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'widget'))
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	return this.each(function() {
		typeof options == 'string' ?
			$.datepicker['_' + options + 'Datepicker'].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.8.6";

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window['DP_jQuery_' + dpuuid] = $;

})(jQuery);

/*!
 * jQuery UI Accordion 1.8.22
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Accordion
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget( "ui.accordion", {
	options: {
		active: 0,
		animated: "slide",
		autoHeight: true,
		clearStyle: false,
		collapsible: false,
		event: "click",
		fillSpace: false,
		header: "> li > :first-child,> :not(li):even",
		icons: {
			header: "ui-icon-triangle-1-e",
			headerSelected: "ui-icon-triangle-1-s"
		},
		navigation: false,
		navigationFilter: function() {
			return this.href.toLowerCase() === location.href.toLowerCase();
		}
	},

	_create: function() {
		var self = this,
			options = self.options;

		self.running = 0;

		self.element
			.addClass( "ui-accordion ui-widget ui-helper-reset" )
			// in lack of child-selectors in CSS
			// we need to mark top-LIs in a UL-accordion for some IE-fix
			.children( "li" )
				.addClass( "ui-accordion-li-fix" );

		self.headers = self.element.find( options.header )
			.addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" )
			.bind( "mouseenter.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( "ui-state-hover" );
			})
			.bind( "mouseleave.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( "ui-state-hover" );
			})
			.bind( "focus.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( "ui-state-focus" );
			})
			.bind( "blur.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( "ui-state-focus" );
			});

		self.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" );

		if ( options.navigation ) {
			var current = self.element.find( "a" ).filter( options.navigationFilter ).eq( 0 );
			if ( current.length ) {
				var header = current.closest( ".ui-accordion-header" );
				if ( header.length ) {
					// anchor within header
					self.active = header;
				} else {
					// anchor within content
					self.active = current.closest( ".ui-accordion-content" ).prev();
				}
			}
		}

		self.active = self._findActive( self.active || options.active )
			.addClass( "ui-state-default ui-state-active" )
			.toggleClass( "ui-corner-all" )
			.toggleClass( "ui-corner-top" );
		self.active.next().addClass( "ui-accordion-content-active" );

		self._createIcons();
		self.resize();
		
		// ARIA
		self.element.attr( "role", "tablist" );

		self.headers
			.attr( "role", "tab" )
			.bind( "keydown.accordion", function( event ) {
				return self._keydown( event );
			})
			.next()
				.attr( "role", "tabpanel" );

		self.headers
			.not( self.active || "" )
			.attr({
				"aria-expanded": "false",
				"aria-selected": "false",
				tabIndex: -1
			})
			.next()
				.hide();

		// make sure at least one header is in the tab order
		if ( !self.active.length ) {
			self.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			self.active
				.attr({
					"aria-expanded": "true",
					"aria-selected": "true",
					tabIndex: 0
				});
		}

		// only need links in tab order for Safari
		if ( !$.browser.safari ) {
			self.headers.find( "a" ).attr( "tabIndex", -1 );
		}

		if ( options.event ) {
			self.headers.bind( options.event.split(" ").join(".accordion ") + ".accordion", function(event) {
                                
                                if( $S(this).hasClass('ui-state-disabled') )
                                  return;
                          
				self._clickHandler.call( self, event, this );
				event.preventDefault();
			});
		}
	},

	_createIcons: function() {
		var options = this.options;
		if ( options.icons ) {
			$( "<span></span>" )
				.addClass( "ui-icon " + options.icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-icon" )  
				.toggleClass(options.icons.header)
				.toggleClass(options.icons.headerSelected);
			this.element.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers.children( ".ui-icon" ).remove();
		this.element.removeClass( "ui-accordion-icons" );
	},

	destroy: function() {
		var options = this.options;

		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		this.headers
			.unbind( ".accordion" )
			.removeClass( "ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-selected" )
			.removeAttr( "tabIndex" );

		this.headers.find( "a" ).removeAttr( "tabIndex" );
		this._destroyIcons();
		var contents = this.headers.next()
			.css( "display", "" )
			.removeAttr( "role" )
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled" );
		if ( options.autoHeight || options.fillHeight ) {
			contents.css( "height", "" );
		}

		return $.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
			
		if ( key == "active" ) {
			this.activate( value );
		}
		if ( key == "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}
		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key == "disabled" ) {
			this.headers.add(this.headers.next())
				[ value ? "addClass" : "removeClass" ](
					"ui-accordion-disabled ui-state-disabled" );
		}
	},

	_keydown: function( event ) {
		if ( this.options.disabled || event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._clickHandler( { target: event.target }, event.target );
				event.preventDefault();
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.focus();
			return false;
		}

		return true;
	},

	resize: function() {
		var options = this.options,
			maxHeight;

		if ( options.fillSpace ) {
			if ( $.browser.msie ) {
				var defOverflow = this.element.parent().css( "overflow" );
				this.element.parent().css( "overflow", "hidden");
			}
			maxHeight = this.element.parent().height();
			if ($.browser.msie) {
				this.element.parent().css( "overflow", defOverflow );
			}

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) + 10 );
                                   //$( this ).height( Math.max( 0, maxHeight -
                                   //    $( this ).innerHeight() + $( this ).height() ) - 5 );
				})
				.css( "overflow", "auto" );
		} else if ( options.autoHeight ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
				})
				.height( maxHeight +18 );
		}

		return this;
	},

	activate: function( index ) {
		// TODO this gets called on init, changing the option without an explicit call for that
		this.options.active = index;
		// call clickHandler with custom event
		var active = this._findActive( index )[ 0 ];

                
		this._clickHandler( { target: active }, active );

		return this;
	},

	_findActive: function( selector ) {
		return selector
			? typeof selector === "number"
				? this.headers.filter( ":eq(" + selector + ")" )
				: this.headers.not( this.headers.not( selector ) )
			: selector === false
				? $( [] )
				: this.headers.filter( ":eq(0)" );
	},

	// TODO isn't event.target enough? why the separate target argument?
	_clickHandler: function( event, target ) {
		var options = this.options;
		if ( options.disabled ) {
			return;
		}

		// called only when using activate(false) to close all parts programmatically
		if ( !event.target ) {
			if ( !options.collapsible ) {
				return;
			}
			this.active
				.removeClass( "ui-state-active ui-corner-top" )
				.addClass( "ui-state-default ui-corner-all" )
				.children( ".ui-icon" )
					.removeClass( options.icons.headerSelected )
					.addClass( options.icons.header );
			this.active.next().addClass( "ui-accordion-content-active" );
			var toHide = this.active.next(),
				data = {
					options: options,
					newHeader: $( [] ),
					oldHeader: options.active,
					newContent: $( [] ),
					oldContent: toHide
				},
				toShow = ( this.active = $( [] ) );
			this._toggle( toShow, toHide, data );
			return;
		}

		// get the click target
		var clicked = $( event.currentTarget || target ),
			clickedIsActive = clicked[0] === this.active[0];

		// TODO the option is changed, is that correct?
		// TODO if it is correct, shouldn't that happen after determining that the click is valid?
		options.active = options.collapsible && clickedIsActive ?
			false :
			this.headers.index( clicked );

		// if animations are still active, or the active header is the target, ignore click
		if ( this.running || ( !options.collapsible && clickedIsActive ) ) {
			return;
		}

		// find elements to show and hide
		var active = this.active,
			toShow = clicked.next(),
			toHide = this.active.next(),
			data = {
				options: options,
				newHeader: clickedIsActive && options.collapsible ? $([]) : clicked,
				oldHeader: this.active,
				newContent: clickedIsActive && options.collapsible ? $([]) : toShow,
				oldContent: toHide
			},
			down = this.headers.index( this.active[0] ) > this.headers.index( clicked[0] );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $([]) : clicked;
		this._toggle( toShow, toHide, data, clickedIsActive, down );

		// switch classes
		active
			.removeClass( "ui-state-active ui-corner-top" )
			.addClass( "ui-state-default ui-corner-all" )
			.children( ".ui-icon" )
				.removeClass( options.icons.headerSelected )
				.addClass( options.icons.header );
		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-state-default ui-corner-all" )
				.addClass( "ui-state-active ui-corner-top" )
				.children( ".ui-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.headerSelected );
			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}

		return;
	},

	_toggle: function( toShow, toHide, data, clickedIsActive, down ) {
		var self = this,
			options = self.options;

		self.toShow = toShow;
		self.toHide = toHide;
		self.data = data;

		var complete = function() {
			if ( !self ) {
				return;
			}
			return self._completed.apply( self, arguments );
		};

		// trigger changestart event
		self._trigger( "changestart", null, self.data );

		// count elements to animate
		self.running = toHide.size() === 0 ? toShow.size() : toHide.size();

		if ( options.animated ) {
			var animOptions = {};

			if ( options.collapsible && clickedIsActive ) {
				animOptions = {
					toShow: $( [] ),
					toHide: toHide,
					complete: complete,
					down: down,
					autoHeight: options.autoHeight || options.fillSpace
				};
			} else {
				animOptions = {
					toShow: toShow,
					toHide: toHide,
					complete: complete,
					down: down,
					autoHeight: options.autoHeight || options.fillSpace
				};
			}

			if ( !options.proxied ) {
				options.proxied = options.animated;
			}

			if ( !options.proxiedDuration ) {
				options.proxiedDuration = options.duration;
			}

			options.animated = $.isFunction( options.proxied ) ?
				options.proxied( animOptions ) :
				options.proxied;

			options.duration = $.isFunction( options.proxiedDuration ) ?
				options.proxiedDuration( animOptions ) :
				options.proxiedDuration;

			var animations = $.ui.accordion.animations,
				duration = options.duration,
				easing = options.animated;

			if ( easing && !animations[ easing ] && !$.easing[ easing ] ) {
				easing = "slide";
			}
			if ( !animations[ easing ] ) {
				animations[ easing ] = function( options ) {
					this.slide( options, {
						easing: easing,
						duration: duration || 700
					});
				};
			}

			animations[ easing ]( animOptions );
		} else {
			if ( options.collapsible && clickedIsActive ) {
				toShow.toggle();
			} else {
				toHide.hide();
				toShow.show();
			}

			complete( true );
		}

		// TODO assert that the blur and focus triggers are really necessary, remove otherwise
		toHide.prev()
			.attr({
				"aria-expanded": "false",
				"aria-selected": "false",
				tabIndex: -1
			})
			.blur();
		toShow.prev()
			.attr({
				"aria-expanded": "true",
				"aria-selected": "true",
				tabIndex: 0
			})
			.focus();
	},

	_completed: function( cancel ) {
		this.running = cancel ? 0 : --this.running;
		if ( this.running ) {
			return;
		}

		if ( this.options.clearStyle ) {
			this.toShow.add( this.toHide ).css({
				height: "",
				overflow: ""
			});
		}

		// other classes are removed before the animation; this one needs to stay until completed
		this.toHide.removeClass( "ui-accordion-content-active" );
		// Work around for rendering bug in IE (#5421)
		if ( this.toHide.length ) {
			this.toHide.parent()[0].className = this.toHide.parent()[0].className;
		}

		this._trigger( "change", null, this.data );
	}
});

$.extend( $.ui.accordion, {
	version: "1.8.22",
	animations: {
		slide: function( options, additions ) {
			options = $.extend({
				easing: "swing",
				duration: 300
			}, options, additions );
			if ( !options.toHide.size() ) {
				options.toShow.animate({
					height: "show",
					paddingTop: "show",
					paddingBottom: "show"
				}, options );
				return;
			}
			if ( !options.toShow.size() ) {
				options.toHide.animate({
					height: "hide",
					paddingTop: "hide",
					paddingBottom: "hide"
				}, options );
				return;
			}
			var overflow = options.toShow.css( "overflow" ),
				percentDone = 0,
				showProps = {},
				hideProps = {},
				fxAttrs = [ "height", "paddingTop", "paddingBottom" ],
				originalWidth;
			// fix width before calculating height of hidden element
			var s = options.toShow;
			originalWidth = s[0].style.width;
			s.width( s.parent().width()
				- parseFloat( s.css( "paddingLeft" ) )
				- parseFloat( s.css( "paddingRight" ) )
				- ( parseFloat( s.css( "borderLeftWidth" ) ) || 0 )
				- ( parseFloat( s.css( "borderRightWidth" ) ) || 0 ) );

			$.each( fxAttrs, function( i, prop ) {
				hideProps[ prop ] = "hide";

				var parts = ( "" + $.css( options.toShow[0], prop ) ).match( /^([\d+-.]+)(.*)$/ );
				showProps[ prop ] = {
					value: parts[ 1 ],
					unit: parts[ 2 ] || "px"
				};
			});
			options.toShow.css({ height: 0, overflow: "hidden" }).show();
			options.toHide
				.filter( ":hidden" )
					.each( options.complete )
				.end()
				.filter( ":visible" )
				.animate( hideProps, {
				step: function( now, settings ) {
					// only calculate the percent when animating height
					// IE gets very inconsistent results when animating elements
					// with small values, which is common for padding
					if ( settings.prop == "height" ) {
						percentDone = ( settings.end - settings.start === 0 ) ? 0 :
							( settings.now - settings.start ) / ( settings.end - settings.start );
					}

					options.toShow[ 0 ].style[ settings.prop ] =
						( percentDone * showProps[ settings.prop ].value )
						+ showProps[ settings.prop ].unit;
				},
				duration: options.duration,
				easing: options.easing,
				complete: function() {
					if ( !options.autoHeight ) {
						options.toShow.css( "height", "" );
					}
					options.toShow.css({
						width: originalWidth,
						overflow: overflow
					});
					options.complete();
				}
			});
		},
		bounceslide: function( options ) {
			this.slide( options, {
				easing: options.down ? "easeOutBounce" : "swing",
				duration: options.down ? 1000 : 200
			});
		}
	}
});

})( jQuery );
/*
 * jQuery UI Autocomplete 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Autocomplete
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 */
(function( $, undefined ) {

$.widget( "ui.autocomplete", {
	options: {
		appendTo: "body",
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null
	},
	_create: function() {
		var self = this,
			doc = this.element[ 0 ].ownerDocument,
			suppressKeyPress;

		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" )
			// TODO verify these actually work as intended
			.attr({
				role: "textbox",
				"aria-autocomplete": "list",
				"aria-haspopup": "true"
			})
			.bind( "keydown.autocomplete", function( event ) {
				if ( self.options.disabled || self.element.attr( "readonly" ) ) {
					return;
				}

				suppressKeyPress = false;
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					self._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					self._move( "nextPage", event );
					break;
				case keyCode.UP:
					self._move( "previous", event );
					// prevent moving cursor to beginning of text field in some browsers
					event.preventDefault();
					break;
				case keyCode.DOWN:
					self._move( "next", event );
					// prevent moving cursor to end of text field in some browsers
					event.preventDefault();
					break;
				case keyCode.ENTER:
				case keyCode.NUMPAD_ENTER:
					// when menu is open and has focus
					if ( self.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
					}
					//passthrough - ENTER and TAB both select the current element
				case keyCode.TAB:
					if ( !self.menu.active ) {
						return;
					}
					self.menu.select( event );
					break;
				case keyCode.ESCAPE:
					self.element.val( self.term );
					self.close( event );
					break;
				default:
					// keypress is triggered before the input value is changed
					clearTimeout( self.searching );
					self.searching = setTimeout(function() {
						// only search if the value has changed
						if ( self.term != self.element.val() ) {
							self.selectedItem = null;
							self.search( null, event );
						}
					}, self.options.delay );
					break;
				}
			})
			.bind( "keypress.autocomplete", function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					event.preventDefault();
				}
			})
			.bind( "focus.autocomplete", function() {
				if ( self.options.disabled ) {
					return;
				}

				self.selectedItem = null;
				self.previous = self.element.val();
			})
			.bind( "blur.autocomplete", function( event ) {
				if ( self.options.disabled ) {
					return;
				}

				clearTimeout( self.searching );
				// clicks on the menu (or a button to trigger a search) will cause a blur event
				self.closing = setTimeout(function() {
					self.close( event );
					self._change( event );
				}, 150 );
			});
		this._initSource();
		this.response = function() {
			return self._response.apply( self, arguments );
		};
		this.menu = $( "<ul></ul>" )
			.addClass( "ui-autocomplete" )
			.appendTo( $( this.options.appendTo || "body", doc )[0] )
			// prevent the close-on-blur in case of a "slow" click on the menu (long mousedown)
			.mousedown(function( event ) {
				// clicking on the scrollbar causes focus to shift to the body
				// but we can't detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = self.menu.element[ 0 ];
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
					setTimeout(function() {
						$( document ).one( 'mousedown', function( event ) {
							if ( event.target !== self.element[ 0 ] &&
								event.target !== menuElement &&
								!$.ui.contains( menuElement, event.target ) ) {
								self.close();
							}
						});
					}, 1 );
				}

				// use another timeout to make sure the blur-event-handler on the input was already triggered
				setTimeout(function() {
					clearTimeout( self.closing );
				}, 13);
			})
			.menu({
				focus: function( event, ui ) {
					var item = ui.item.data( "item.autocomplete" );
					if ( false !== self._trigger( "focus", event, { item: item } ) ) {
						// use value to match what will end up in the input, if it was a key event
						if ( /^key/.test(event.originalEvent.type) ) {
							self.element.val( item.value );
						}
					}
				},
				selected: function( event, ui ) {
					var item = ui.item.data( "item.autocomplete" ),
						previous = self.previous;

					// only trigger when focus was lost (click on menu)
					if ( self.element[0] !== doc.activeElement ) {
						self.element.focus();
						self.previous = previous;
						// #6109 - IE triggers two focus events and the second
						// is asynchronous, so we need to reset the previous
						// term synchronously and asynchronously :-(
						setTimeout(function() {
							self.previous = previous;
						}, 1);
					}

					if ( false !== self._trigger( "select", event, { item: item } ) ) {
						self.element.val( item.value );
					}
					// reset the term after the select event
					// this allows custom select handling to work properly
					self.term = self.element.val();

					self.close( event );
					self.selectedItem = item;
				},
				blur: function( event, ui ) {
					// don't set the value of the text field if it's already correct
					// this prevents moving the cursor unnecessarily
					if ( self.menu.element.is(":visible") &&
						( self.element.val() !== self.term ) ) {
						self.element.val( self.term );
					}
				}
			})
			.zIndex( this.element.zIndex() + 1 )
			// workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
			.css({ top: 0, left: 0 })
			.hide()
			.data( "menu" );
		if ( $.fn.bgiframe ) {
			 this.menu.element.bgiframe();
		}
	},

	destroy: function() {
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" )
			.removeAttr( "role" )
			.removeAttr( "aria-autocomplete" )
			.removeAttr( "aria-haspopup" );
		this.menu.element.remove();
		$.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( $( value || "body", this.element[0].ownerDocument )[0] )
		}
	},

	_initSource: function() {
		var self = this,
			array,
			url;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter(array, request.term) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if (self.xhr) {
					self.xhr.abort();
				}
				self.xhr = $.getJSON( url, request, function( data, status, xhr ) {
					if ( xhr === self.xhr ) {
						response( data );
					}
					self.xhr = null;
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	search: function( value, event ) {
		value = value != null ? value : this.element.val();

		// always save the actual value, not the one passed as an argument
		this.term = this.element.val();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		clearTimeout( this.closing );
		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.element.addClass( "ui-autocomplete-loading" );

		this.source( { term: value }, this.response );
	},

	_response: function( content ) {
		if ( content && content.length ) {
			content = this._normalize( content );
			this._suggest( content );
			this._trigger( "open" );
		} else {
			this.close();
		}
		this.element.removeClass( "ui-autocomplete-loading" );
	},

	close: function( event ) {
		clearTimeout( this.closing );
		if ( this.menu.element.is(":visible") ) {
			this._trigger( "close", event );
			this.menu.element.hide();
			this.menu.deactivate();
		}
	},
	
	_change: function( event ) {
		if ( this.previous !== this.element.val() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[0].label && items[0].value ) {
			return items;
		}
		return $.map( items, function(item) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element
			.empty()
			.zIndex( this.element.zIndex() + 1 );
		this._renderMenu( ul, items );
		// TODO refresh should check if the active item is still in the dom, removing the need for a manual deactivate
		this.menu.deactivate();
		this.menu.refresh();
		this.menu.element.show().position( $.extend({
			of: this.element
		}, this.options.position ));

		this._resizeMenu();
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			ul.width( "" ).outerWidth(),
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var self = this;
		$.each( items, function( index, item ) {
			self._renderItem( ul, item );
		});
	},

	_renderItem: function( ul, item) {
		return $( "<li></li>" )
			.data( "item.autocomplete", item )
			.append( $( "<a></a>" ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is(":visible") ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.first() && /^previous/.test(direction) ||
				this.menu.last() && /^next/.test(direction) ) {
			this.element.val( this.term );
			this.menu.deactivate();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});

}( jQuery ));

/*
 * jQuery UI Menu (not officially released)
 * 
 * This widget isn't yet finished and the API is subject to change. We plan to finish
 * it for the next release. You're welcome to give it a try anyway and give us feedback,
 * as long as you're okay with migrating your code later on. We can help with that, too.
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Menu
 *
 * Depends:
 *	jquery.ui.core.js
 *  jquery.ui.widget.js
 */
(function($) {

$.widget("ui.menu", {
	_create: function() {
		var self = this;
		this.element
			.addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
			.attr({
				role: "listbox",
				"aria-activedescendant": "ui-active-menuitem"
			})
			.click(function( event ) {
				if ( !$( event.target ).closest( ".ui-menu-item a" ).length ) {
					return;
				}
				// temporary
				event.preventDefault();
				self.select( event );
			});
		this.refresh();
	},
	
	refresh: function() {
		var self = this;

		// don't refresh list items that are already adapted
		var items = this.element.children("li:not(.ui-menu-item):has(a)")
			.addClass("ui-menu-item")
			.attr("role", "menuitem");
		
		items.children("a")
			.addClass("ui-corner-all")
			.attr("tabindex", -1)
			// mouseenter doesn't work with event delegation
			.mouseenter(function( event ) {
				self.activate( event, $(this).parent() );
			})
			.mouseleave(function() {
				self.deactivate();
			});
	},

	activate: function( event, item ) {
		this.deactivate();
		if (this.hasScroll()) {
			var offset = item.offset().top - this.element.offset().top,
				scroll = this.element.attr("scrollTop"),
				elementHeight = this.element.height();
			if (offset < 0) {
				this.element.attr("scrollTop", scroll + offset);
			} else if (offset >= elementHeight) {
				this.element.attr("scrollTop", scroll + offset - elementHeight + item.height());
			}
		}
		this.active = item.eq(0)
			.children("a")
				.addClass("ui-state-hover")
				.attr("id", "ui-active-menuitem")
			.end();
		this._trigger("focus", event, { item: item });
	},

	deactivate: function() {
		if (!this.active) { return; }

		this.active.children("a")
			.removeClass("ui-state-hover")
			.removeAttr("id");
		this._trigger("blur");
		this.active = null;
	},

	next: function(event) {
		this.move("next", ".ui-menu-item:first", event);
	},

	previous: function(event) {
		this.move("prev", ".ui-menu-item:last", event);
	},

	first: function() {
		return this.active && !this.active.prevAll(".ui-menu-item").length;
	},

	last: function() {
		return this.active && !this.active.nextAll(".ui-menu-item").length;
	},

	move: function(direction, edge, event) {
		if (!this.active) {
			this.activate(event, this.element.children(edge));
			return;
		}
		var next = this.active[direction + "All"](".ui-menu-item").eq(0);
		if (next.length) {
			this.activate(event, next);
		} else {
			this.activate(event, this.element.children(edge));
		}
	},

	// TODO merge with previousPage
	nextPage: function(event) {
		if (this.hasScroll()) {
			// TODO merge with no-scroll-else
			if (!this.active || this.last()) {
				this.activate(event, this.element.children(".ui-menu-item:first"));
				return;
			}
			var base = this.active.offset().top,
				height = this.element.height(),
				result = this.element.children(".ui-menu-item").filter(function() {
					var close = $(this).offset().top - base - height + $(this).height();
					// TODO improve approximation
					return close < 10 && close > -10;
				});

			// TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(".ui-menu-item:last");
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(".ui-menu-item")
				.filter(!this.active || this.last() ? ":first" : ":last"));
		}
	},

	// TODO merge with nextPage
	previousPage: function(event) {
		if (this.hasScroll()) {
			// TODO merge with no-scroll-else
			if (!this.active || this.first()) {
				this.activate(event, this.element.children(".ui-menu-item:last"));
				return;
			}

			var base = this.active.offset().top,
				height = this.element.height();
				result = this.element.children(".ui-menu-item").filter(function() {
					var close = $(this).offset().top - base + height - $(this).height();
					// TODO improve approximation
					return close < 10 && close > -10;
				});

			// TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(".ui-menu-item:first");
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(".ui-menu-item")
				.filter(!this.active || this.first() ? ":last" : ":first"));
		}
	},

	hasScroll: function() {
		return this.element.height() < this.element.attr("scrollHeight");
	},

	select: function( event ) {
		this._trigger("selected", event, { item: this.active });
	}
});

}(jQuery));

/*
 * jQuery UI Slider 1.8.6
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {

	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var self = this,
			o = this.options;

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );
		
		if ( o.disabled ) {
			this.element.addClass( "ui-slider-disabled ui-disabled" );
		}

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				this.range = $( "<div></div>" );
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length && o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			} else {
				this.range = $( "<div></div>" );
			}

			this.range
				.appendTo( this.element )
				.addClass( "ui-slider-range" );

			if ( o.range === "min" || o.range === "max" ) {
				this.range.addClass( "ui-slider-range-" + o.range );
			}

			// note: this isn't the most fittingly semantic framework class for this element,
			// but worked best visually with a variety of themes
			this.range.addClass( "ui-widget-header" );
		}

		if ( $( ".ui-slider-handle", this.element ).length === 0 ) {
			$( "<a href='#'></a>" )
				.appendTo( this.element )
				.addClass( "ui-slider-handle" );
		}

		if ( o.values && o.values.length ) {
			while ( $(".ui-slider-handle", this.element).length < o.values.length ) {
				$( "<a href='#'></a>" )
					.appendTo( this.element )
					.addClass( "ui-slider-handle" );
			}
		}

		this.handles = $( ".ui-slider-handle", this.element )
			.addClass( "ui-state-default" +
				" ui-corner-all" );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( "a" )
			.click(function( event ) {
				event.preventDefault();
			})
			.hover(function() {
				if ( !o.disabled ) {
					$( this ).addClass( "ui-state-hover" );
				}
			}, function() {
				$( this ).removeClass( "ui-state-hover" );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
					$( this ).addClass( "ui-state-focus" );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( "ui-state-focus" );
			});

		this.handles.each(function( i ) {
			$( this ).data( "index.ui-slider-handle", i );
		});

		this.handles
			.keydown(function( event ) {
				var ret = true,
					index = $( this ).data( "index.ui-slider-handle" ),
					allowed,
					curVal,
					newVal,
					step;
	
				if ( self.options.disabled ) {
					return;
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						ret = false;
						if ( !self._keySliding ) {
							self._keySliding = true;
							$( this ).addClass( "ui-state-active" );
							allowed = self._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}
	
				step = self.options.step;
				if ( self.options.values && self.options.values.length ) {
					curVal = newVal = self.values( index );
				} else {
					curVal = newVal = self.value();
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = self._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = self._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = self._trimAlignValue( curVal + ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = self._trimAlignValue( curVal - ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === self._valueMax() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === self._valueMin() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal - step );
						break;
				}
	
				self._slide( event, index, newVal );
	
				return ret;
	
			})
			.keyup(function( event ) {
				var index = $( this ).data( "index.ui-slider-handle" );
	
				if ( self._keySliding ) {
					self._keySliding = false;
					self._stop( event, index );
					self._change( event, index );
					$( this ).removeClass( "ui-state-active" );
				}
	
			});

		this._refreshValue();

		this._animateOff = false;
	},

	destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-slider-disabled" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" )
			.removeData( "slider" )
			.unbind( ".slider" );

		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function( event ) {
		var o = this.options,
			position,
			normValue,
			distance,
			closestHandle,
			self,
			index,
			allowed,
			offset,
			mouseOverHandle;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		self = this;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - self.values(i) );
			if ( distance > thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true && this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		self._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();
		
		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		this._slide( event, index, normValue );
		this._animateOff = true;
		return true;
	},

	_mouseStart: function( event ) {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );
		
		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},
	
	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) && 
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "disabled":
				if ( value ) {
					this.handles.filter( ".ui-state-focus" ).blur();
					this.handles.removeClass( "ui-state-hover" );
					this.handles.attr( "disabled", "disabled" );
					this.element.addClass( "ui-disabled" );
				} else {
					this.handles.removeAttr( "disabled" );
					this.element.removeClass( "ui-disabled" );
				}
				break;
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},
	
	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val < this._valueMin() ) {
			return this._valueMin();
		}
		if ( val > this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = val % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},
	
	_refreshValue: function() {
		var oRange = this.options.range,
			o = this.options,
			self = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			valPercent,
			_set = {},
			lastValPercent,
			value,
			valueMin,
			valueMax;

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i, j ) {
				valPercent = ( self.values(i) - self._valueMin() ) / ( self._valueMax() - self._valueMin() ) * 100;
				_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( self.options.range === true ) {
					if ( self.orientation === "horizontal" ) {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	}

});

$.extend( $.ui.slider, {
	version: "1.8.6"
});

}(jQuery));

/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author Dominik Bonsch <dominik.bonsch@webfrap.net>
 * 
 * @smell Use templates instead of inline code
 * @smell Should be a widget
 * @smell redundancy is very high, nearly the same as minimenu, it's required to combine both
 */
(function($S){

  var overlayID = "menuSelectorOverlay";

  // The actual function
  $S.fn.menuSelector = function(options){

    return this.each(function(){
      // Save reference
      var self = $S(this);

      // Merge default options with passed options
      var opts = $S.extend({}, $S.fn.menuSelector.defaults, options);
      
      // Save options to element
      self.data('menuSelectorOptions', opts);

      if (self.hasClass('hasMenuSelector'))
        return this;

      // Initialise the overlay box
      initOverlay(opts);
      self.addClass('hasMenuSelector');
      
      // Set click handler
      self.click(function() {
        initOverlay(opts);
        $S.fn.menuSelector.openOverlay(this);
      });

    });

  };
	
  // Closes the overlay box
  $S.fn.menuSelector.closeOverlay = function(){
    
    if ($S('#'+ overlayID +':visible').length){
      
      /*
      $S('#'+overlayID).slideUp('fast', function(){
        
        $S('.menuSelectorOverlay').removeClass('menuSelectorOverlay');
      });
      */
      
      $S('#'+overlayID).hide();
      $S('.menuSelectorOverlay').removeClass('menuSelectorOverlay');
    }
  };
	
  // Opens the overlay box
  $S.fn.menuSelector.openOverlay = function(target){

    var $target = $S(target);
    // Get options of the element
    var opts = $target.data('menuSelectorOptions');
    
    // Close overlay box in case it's still open
    $S.fn.menuSelector.closeOverlay();		
    $target.addClass('hasMenuSelectorOverlay');
		
    // get $S object of overlay box
    var $overlay 	= $S('#'+overlayID);
		
    // get current value of the passed input field
    var currentVal = typeof opts.stringField != 'undefined' ? opts.stringField.val() : '';	
				
    // get the offset coordiantes
    var style = $target.offset();
    // adjust top coordinate
    style.top = style.top + $target.outerHeight();		
    $overlay.css(style);	
		
    // Content of the overlay box
    var content = "";
		
    // If there are any additional menu items to be shown ...
    if (opts.menuItems != null){
      
      var length = opts.menuItems.length;
      for (var i = 0; i < length; i++) {
        
        var item = opts.menuItems[i];
        content += '<div class="menuSelectorMenuButton">'
          +'<a style="cursor: pointer;width:98%;" onclick="$R.get( \''+item.onClickLink+'\', {callback:function(){$S.fn.menuSelector.closeOverlay();}} )"' 
          +'   onmouseover="$S(this).removeClass(\'default\').addClass(\'ui-state-hover\');" '
          +'   onmouseout="$S(this).removeClass(\'ui-state-hover\').addClass(\'default\');"'
          +'   class="ui-corner-all default">'
          +'<img class="icon xsmall" src="'+ item.iconPath +'" /> '
          +'<b>'+ item.caption +'</b>'
          +'</a>'
          +'<br style="clear: both;" />'
          +'</div>';			
							
      }
    }		

    if( currentVal == '' ){
      
      content = content
      + '<div class="menuSelectorMenuButton">'
      + '<a style="cursor: pointer;width:98%;"  onclick="$R.get( '+opts.add_link+' , {callback:function(){$S.fn.menuSelector.closeOverlay();}} )"'
      + ' onmouseover="$S(this).removeClass(\'default\').addClass(\'ui-state-hover\');" '
      + ' onmouseout="$S(this).removeClass(\'ui-state-hover\').addClass(\'default\');" class="ui-corner-all default">'			      
      + '<img class="icon xsmall" src=\''+$C.iconAdd+'\' /> '
      + '<b>append</b>'				
      + '</a>'
      + '<br style="clear: both;" />' 
      + '</div>';
    }
    else{
      //  if(opts.add && !opts.edit)
      
      content = content 
      + '<div class="menuSelectorMenuButton">'
      + '<a style="cursor: pointer;width:98%;"  onclick="$R.get( '+opts.add_link+', {callback:function(){$S.fn.menuSelector.closeOverlay();}} )" '
      +   'onmouseover="$S(this).removeClass(\'default\').addClass(\'ui-state-hover\');" '
      +	'onmouseout="$S(this).removeClass(\'ui-state-hover\').addClass(\'default\');" class="ui-corner-all default">'		      
      +	'<img class="icon xsmall" src=\''+$C.iconAdd+'\' /> '
      + '<b>change</b>'				
      + '</a>'
      + '<br style="clear: both;" />'
      + '</div>';
    }
		
    if (opts.edit && currentVal != ''){
      
      content = content
      +	'<div class="menuSelectorMenuButton">'
      + '<a style="cursor: pointer;width:98%;" onclick="$S.fn.menuSelector.closeOverlay();$R.showEntity( '+opts.edit_link+' );"'
      +	'onmouseover="$S(this).removeClass(\'default\').addClass(\'ui-state-hover\');" '
      +	'onmouseout="$S(this).removeClass(\'ui-state-hover\').addClass(\'default\');"'
      +	'class="ui-corner-all default">'
      +	'<img class="icon xsmall " src="'+$C.iconEdit+'" />'
      + '<b>   show data</b>'
      + '</a>'
      + '<br style="clear: both;" /></div>';
    }
		
    if (opts.remove && currentVal != ''){
      
      content = content
      +	'<div class="menuSelectorMenuButton">'
      + '<a style="cursor: pointer;width:98%;" onclick="$S.fn.menuSelector.closeOverlay(), $S.fn.menuSelector.emptyFields(\''+opts.stringField.attr("id")+'\',\''+opts.hiddenField.attr("id")+'\') ;"'
      +	'onmouseover="$S(this).removeClass(\'default\').addClass(\'ui-state-hover\');" '
      +	'onmouseout="$S(this).removeClass(\'ui-state-hover\').addClass(\'default\');"'
      +	'class="ui-corner-all default">'
      +	'<img class="icon xsmall " src="'+$C.iconDelete+'" />'
      + '<b>   disconnect</b>'
      + '</a>'
      + '<br style="clear: both;" /></div>';
    }	
		
    content += '<div style=""></div>';
    $overlay.find('#menuSelectorContent').html(content);
    $overlay.show();
  };
	
  // Reset input fields
  $S.fn.menuSelector.emptyFields = function(displayId, valId){
    
    alert( '#'+valId );
    
    $S('#'+valId).val("1");
    $S('#'+displayId).val("");
  };
	
  // Mousedown handler on the document
  function docMouseDown(e){
   
    if( $S(e.target).hasClass('menuSelectorMenuButton') ) {   

      $S(e.target).click();
      return;

    }
    else {
     
      if( $S(e.target).parent().hasClass('menuSelectorMenuButton') ) {   

       $S(e.target).parent().click();
       return;

      } 
      else {

        if ($S("#"+overlayID+":visible").length == 0) {	    		
          return;
        }
        else {

          $S.fn.menuSelector1.closeOverlay();

        }
      }
    }	
  	
  };//end function docMouseDown
	
  // Initialise overlay box and apply the style
  function initOverlay(opts){	
    
    if ($S("#"+overlayID).length == 0){
      
      $S("body").append(
        '<div id="'+overlayID+'" class="">'
        +'   <div class="ui-widget ui-widget-content">'
        +'	  <div class="ui-widget-content" style="padding: 0;">'
        +'	       <div id="menuSelectorContent"></div>'
        +'	       <div style="clear: left;"></div>'
        +'	  </div>'
        +'	  <div id="menuSelectorCloseButton">'
        +'	     <a href="javascript: void(0);" onclick="$S.fn.menuSelector.closeOverlay()"'
        +'           onmouseover="$S(this).removeClass(\'ui-state-default\').addClass(\'ui-state-hover\');" '
        +'	        onmouseout="$S(this).removeClass(\'ui-state-hover\').addClass(\'ui-state-default\');"'
        +'		   class="ui-corner-all ui-state-default">'
        +'				Close'
        +'		</a>'
        +'		<br style="clear: both;" /><div></div>'
        +'	</div>'
        +'	<!--[if lte IE 6.5]>'
        +'	<iframe style="display:block; position:absolute;top: 0;left:0;z-index:-1;'
        +'				filter:Alpha(Opacity=\'0\');width:3000px;height:3000px"></iframe>'
        +'	<![endif]-->'
        +'</div></div>'
      );
			
      $S(document).mousedown(function(e){docMouseDown(e)});
    }
    else{
    	
    	$S("#"+overlayID).html(
         '   <div class="ui-widget ui-widget-content">'
         +'	  <div class="ui-widget-content" style="padding: 0;">'
         +'	       <div id="menuSelectorContent"></div>'
         +'	       <div style="clear: left;"></div>'
         +'	  </div>'
         +'	  <div id="menuSelectorCloseButton">'
         +'	     <a href="javascript: void(0);" onclick="$S.fn.menuSelector.closeOverlay()"'
         +'           onmouseover="$S(this).removeClass(\'ui-state-default\').addClass(\'ui-state-hover\');" '
         +'	        onmouseout="$S(this).removeClass(\'ui-state-hover\').addClass(\'ui-state-default\');"'
         +'		   class="ui-corner-all ui-state-default">'
         +'				Close'
         +'		</a>'
         +'		<br style="clear: both;" /><div></div>'
         +'	</div>'
         +'	<!--[if lte IE 6.5]>'
         +'	<iframe style="display:block; position:absolute;top: 0;left:0;z-index:-1;'
         +'				filter:Alpha(Opacity=\'0\');width:3000px;height:3000px"></iframe>'
         +'	<![endif]-->'
         +'</div>'
      ).width('120px');
    	
    	
    }
    $S("#"+overlayID).attr("style", "");
    $S("#"+overlayID).css(opts.overlayStyle);
  };
	
  // Default options
  $S.fn.menuSelector.defaults = {
      overlayStyle: {},
      menuItems: null,
      add: 0,
      add_link: '',
      add_image: '',
      edit: 0,
      edit_link: ''
  };
	
})($S);

/* Licence see: /LICENCES/wgt/licence.txt */

;(function(jQuery,undefined) {
  
  jQuery.extend({
	  
    createUploadIframe: function(id, uri){
    	
      //create frame
      var frameId = 'wgtUploadFrame' + id;
      
      if( window.ActiveXObject && jQuery.browser.version < 9 ){
    	  
        var io = document.createElement('<iframe id="' + frameId + '" name="' + frameId + '" class="meta" />');
        if( typeof uri == 'boolean' ){
        	
          io.src = 'javascript:false';
        }
        else if( typeof uri== 'string' ){
        	
          io.src = uri;
        }
      }
      else{
    	  
        var io = document.createElement( 'iframe' );
        io.id = frameId;
        io.name = frameId;
      }
      
      io.style.position = 'absolute';
      io.style.top = '-1000px';
      io.style.left = '-1000px';

      document.body.appendChild(io);

      return io;          
    },
      
    createUploadForm: function( id, oldFormId ){
      
      //create form   
      var formId = 'wgtUploadForm' + id;
      //var fileId = 'wgtUploadFile' + id;
      var form = jQuery('<form  action="" method="POST" name="' + formId + '" id="' + formId + '" enctype="multipart/form-data"></form>');    
      
      
      
      jQuery("#"+oldFormId).find(":input").not('.asgd-'+oldFormId).not("input[type='submit']").each(function(){
        
        var oldAttr = jQuery(this);
        
        var newid = 'wgtUploadForm'+oldAttr.attr('id');
        var newElement = oldAttr.clone();  
        
        if( newElement.is('input[type="checkbox"]') && !newElement.is(':checked') ){
          form.append('<input type="text" value="0" name="'+newElement.attr('name')+'" id="'+newid+'" />');
        }
        else{
          /*
          newElement.attr('id',  newid );
          newElement.appendTo(form);
          */
          oldAttr.attr('id',  newid );
          oldAttr.before(newElement);
          oldAttr.appendTo(form);
          
        } 
      });

      jQuery('.asgd-'+oldFormId).each(function(){
        var oldAttr = jQuery(this);
        var newid = 'wgtUploadForm'+oldAttr.attr('id');
        var newElement = oldAttr.clone();  
        
        if( newElement.is('input[type="checkbox"]') && !newElement.is(':checked') ){
          form.append('<input type="text" value="0" name="'+newElement.attr('name')+'" id="'+newid+'" />');
        }
        else{
          /*
          newElement.attr('id',  newid );
          newElement.appendTo(form);
          */
          oldAttr.attr('id',  newid );
          oldAttr.before(newElement);
          oldAttr.appendTo(form);
          
        } 

      });
   
      //set attributes
      jQuery(form).css('position', 'absolute');
      jQuery(form).css('top', '-1200px');
      jQuery(form).css('left', '-1200px');
      jQuery(form).appendTo('body');      
      return form;
      
      //create form   
      /*
      var formId = 'wgtUploadForm' + id;
      var fileId = 'wgtUploadFile' + id;
      var form = jQuery('<form  action="" method="POST" name="' + formId + '" id="' + formId + '" enctype="multipart/form-data"></form>'); 
      var oldElement = jQuery('#' + fileElementId);
      var newElement = jQuery(oldElement).clone();
      jQuery(oldElement).attr('id', fileId);
      jQuery(oldElement).before(newElement);
      jQuery(oldElement).appendTo(form);
      //set attributes
      jQuery(form).css('position', 'absolute');
      jQuery(form).css('top', '-1200px');
      jQuery(form).css('left', '-1200px');
      jQuery(form).appendTo('body');       
      return form;
      */
    },

    ajaxFileUpload: function(s){

      // TODO introduce global settings, allowing the client to modify them for all requests, not only timeout        
      s = jQuery.extend({}, jQuery.ajaxSettings, s);
      var id = new Date().getTime();       
      var form = jQuery.createUploadForm(id, s.formid);
      var io = jQuery.createUploadIframe(id, s.secureuri);
      
      var frameId = 'wgtUploadFrame' + id;
      var formId = 'wgtUploadForm' + id; 
      
      // Watch for a new set of requests
      if ( s.global && ! jQuery.active++ ){
        jQuery.event.trigger( "ajaxStart" );
      }            
      var requestDone = false;
        
      // Create the request object
      var xml = {};
        
      if ( s.global )
        jQuery.event.trigger("ajaxSend", [xml, s]);
          
      // Wait for a response to come back
      var uploadCallback = function(isTimeout){
    	  
        var io = document.getElementById(frameId);
        try{               
          if(io.contentWindow){
            xml.responseText = io.contentWindow.document.body?io.contentWindow.document.body.innerHTML:null;
            xml.responseXML = io.contentWindow.document.XMLDocument?io.contentWindow.document.XMLDocument:io.contentWindow.document;
          }
          else if(io.contentDocument){
            xml.responseText = io.contentDocument.document.body?io.contentDocument.document.body.innerHTML:null;
            xml.responseXML = io.contentDocument.document.XMLDocument?io.contentDocument.document.XMLDocument:io.contentDocument.document;
          }                       
        }
        catch(e){
        	
          jQuery.handleError(s, xml, null, e);
        }
        
        if ( xml || isTimeout == "timeout") {               
          requestDone = true;
          var status;
          try {
            status = isTimeout != "timeout" ? "success" : "error";
            // Make sure that the request was successful or notmodified
            if ( status != "error" ) {
              // process the data (runs the xml through httpData regardless of callback)
              var data = jQuery.uploadHttpData( xml, s.dataType );    
              
              // If a local callback was specified, fire it and pass it the data
              if ( s.success )
                s.success( data, status );

              // Fire the global callback
              if( s.global )
                jQuery.event.trigger( "ajaxSuccess", [xml, s] );
            } 
            else {
              jQuery.handleError(s, xml, status);
            }
          } 
          catch(e){
        	
          status = "error";
          jQuery.handleError(s, xml, status, e);
        }

        // The request was completed
        if( s.global )
            jQuery.event.trigger( "ajaxComplete", [xml, s] );

        // Handle the global AJAX counter
        if ( s.global && ! --jQuery.active )
            jQuery.event.trigger( "ajaxStop" );

        // Process result
        if ( s.complete )
            s.complete(xml, status);

        jQuery(io).unbind();

        setTimeout(function(){   
          try{
        	  
            jQuery(io).remove();
            jQuery(form).remove();   
                                    
          } 
          catch(e){
        	  
            jQuery.handleError(s, xml, null, e);
          }                                   

        }, 100);

        xml = null;

        }
      }
      
      // Timeout checker
      if ( s.timeout > 0 ) {
        
        setTimeout( function(){
          
            // Check to see if the request is still happening
            if( !requestDone ) 
              uploadCallback( "timeout" );
            
          }, 
          s.timeout
        );
      }
      try {
        
        // var io = jQuery('#' + frameId);
        var form = jQuery('#' + formId);
        form.attr('action', s.url);
        form.attr('method', 'POST');
        form.attr('target', frameId);
        
        if(form.encoding){
          form.encoding = 'multipart/form-data';              
        }
        else{               
          form.enctype = 'multipart/form-data';
        }    

        form.submit();

      } 
      catch(e) {           
        jQuery.handleError(s, xml, null, e);
      }
      
      if(window.attachEvent){
        document.getElementById(frameId).attachEvent('onload', uploadCallback);
      }
      else{
        document.getElementById(frameId).addEventListener('load', uploadCallback, false);
      }       
      return {abort: function () {}}; 

    },

    uploadHttpData: function( r, type ) {
      var data = !type;
      data = type == "xml" || data ? r.responseXML : r.responseText;
      
      // If the type is "script", eval it in global context
      if ( type == "script" )
        jQuery.globalEval( data );
      
      // Get the JavaScript object, if JSON is used.
      if ( type == "json" )
        eval( "data = " + data );
      
      // evaluate scripts within html
      if ( type == "html" )
        jQuery("<div>").html(data).evalScripts();
          //alert(jQuery('param', data).each(function(){alert(jQuery(this).attr('value'));}));
      
      return data;
    }
    
  });

})(jQuery);






/*
* jQuery timepicker addon
* By: Trent Richardson [http://trentrichardson.com]
* Version 0.9.6
* Last Modified: 07/20/2011
* 
* Copyright 2011 Trent Richardson
* Dual licensed under the MIT and GPL licenses.
* http://trentrichardson.com/Impromptu/GPL-LICENSE.txt
* http://trentrichardson.com/Impromptu/MIT-LICENSE.txt
* 
* HERES THE CSS:
* .ui-timepicker-div .ui-widget-header{ margin-bottom: 8px; }
* .ui-timepicker-div dl{ text-align: left; }
* .ui-timepicker-div dl dt{ height: 25px; }
* .ui-timepicker-div dl dd{ margin: -25px 10px 10px 65px; }
* .ui-timepicker-div td { font-size: 90%; }
*/

(function($) {

$.extend($.ui, { timepicker: { version: "0.9.6" } });

/* Time picker manager.
   Use the singleton instance of this class, $.timepicker, to interact with the time picker.
   Settings for (groups of) time pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Timepicker() {
       this.regional = []; // Available regional settings, indexed by language code
       this.regional[''] = { // Default regional settings
              currentText: 'Now',
              closeText: 'Done',
              ampm: false,
              timeFormat: 'hh:mm tt',
              timeSuffix: '',
              timeOnlyTitle: 'Choose Time',
              timeText: 'Time',
              hourText: 'Hour',
              minuteText: 'Minute',
              secondText: 'Second',
              timezoneText: 'Time Zone'
       };
       this._defaults = { // Global defaults for all the datetime picker instances
              showButtonPanel: true,
              timeOnly: false,
              showHour: true,
              showMinute: true,
              showSecond: false,
              showTimezone: false,
              showTime: true,
              stepHour: 0.05,
              stepMinute: 0.05,
              stepSecond: 0.05,
              hour: 0,
              minute: 0,
              second: 0,
              timezone: '+0000',
              hourMin: 0,
              minuteMin: 0,
              secondMin: 0,
              hourMax: 23,
              minuteMax: 59,
              secondMax: 59,
              minDateTime: null,
              maxDateTime: null,
              hourGrid: 0,
              minuteGrid: 0,
              secondGrid: 0,
              alwaysSetTime: true,
              separator: ' ',
              altFieldTimeOnly: true,
              showTimepicker: true,
              timezoneList: ["-1100", "-1000", "-0900", "-0800", "-0700", "-0600",
                            "-0500", "-0400", "-0300", "-0200", "-0100", "+0000",
                            "+0100", "+0200", "+0300", "+0400", "+0500", "+0600",
                            "+0700", "+0800", "+0900", "+1000", "+1100", "+1200"]
       };
       $.extend(this._defaults, this.regional['']);
}

$.extend(Timepicker.prototype, {
       $input: null,
       $altInput: null,
       $timeObj: null,
       inst: null,
       hour_slider: null,
       minute_slider: null,
       second_slider: null,
       timezone_select: null,
       hour: 0,
       minute: 0,
       second: 0,
       timezone: '+0000',
       hourMinOriginal: null,
       minuteMinOriginal: null,
       secondMinOriginal: null,
       hourMaxOriginal: null,
       minuteMaxOriginal: null,
       secondMaxOriginal: null,
       ampm: '',
       formattedDate: '',
       formattedTime: '',
       formattedDateTime: '',
       timezoneList: ["-1100", "-1000", "-0900", "-0800", "-0700", "-0600",
                     "-0500", "-0400", "-0300", "-0200", "-0100", "+0000",
                     "+0100", "+0200", "+0300", "+0400", "+0500", "+0600",
                     "+0700", "+0800", "+0900", "+1000", "+1100", "+1200"],

       /* Override the default settings for all instances of the time picker.
          @param  settings  object - the new settings to use as defaults (anonymous object)
          @return the manager object */
       setDefaults: function(settings) {
              extendRemove(this._defaults, settings || {});
              return this;
       },

       //########################################################################
       // Create a new Timepicker instance
       //########################################################################
       _newInst: function($input, o) {
              var tp_inst = new Timepicker(),
                     inlineSettings = {};
                     
              for (var attrName in this._defaults) {
                     var attrValue = $input.attr('time:' + attrName);
                     if (attrValue) {
                            try {
                                   inlineSettings[attrName] = eval(attrValue);
                            } catch (err) {
                                   inlineSettings[attrName] = attrValue;
                            }
                     }
              }
              tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, o, {
                     beforeShow: function(input, dp_inst) {
                            if ($.isFunction(o.beforeShow))
                                   o.beforeShow(input, dp_inst, tp_inst);
                     },
                     onChangeMonthYear: function(year, month, dp_inst) {
                            // Update the time as well : this prevents the time from disappearing from the $input field.
                            tp_inst._updateDateTime(dp_inst);
                            if ($.isFunction(o.onChangeMonthYear))
                                   o.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
                     },
                     onClose: function(dateText, dp_inst) {
                            if (tp_inst.timeDefined === true && $input.val() != '')
                                   tp_inst._updateDateTime(dp_inst);
                            if ($.isFunction(o.onClose))
                                   o.onClose.call($input[0], dateText, dp_inst, tp_inst);
                     },
                     timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
              });

              tp_inst.hour = tp_inst._defaults.hour;
              tp_inst.minute = tp_inst._defaults.minute;
              tp_inst.second = tp_inst._defaults.second;
              tp_inst.ampm = '';
              tp_inst.$input = $input;

              if (o.altField)
                     tp_inst.$altInput = $(o.altField)
                            .css({ cursor: 'pointer' })
                            .focus(function(){ $input.trigger("focus"); });
                                   
              // datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
              if(tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date)
                     tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
              if(tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date)
                     tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
              if(tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date)
                     tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
              if(tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date)
                     tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
              
              return tp_inst;
       },

       //########################################################################
       // add our sliders to the calendar
       //########################################################################
       _addTimePicker: function(dp_inst) {
              var currDT = (this.$altInput && this._defaults.altFieldTimeOnly) ?
                            this.$input.val() + ' ' + this.$altInput.val() : 
                            this.$input.val();

              this.timeDefined = this._parseTime(currDT);
              this._limitMinMaxDateTime(dp_inst, false);
              this._injectTimePicker();
       },

       //########################################################################
       // parse the time string from input value or _setTime
       //########################################################################
       _parseTime: function(timeString, withDate) {
              var regstr = this._defaults.timeFormat.toString()
                            .replace(/h{1,2}/ig, '(\\d?\\d)')
                            .replace(/m{1,2}/ig, '(\\d?\\d)')
                            .replace(/s{1,2}/ig, '(\\d?\\d)')
                            .replace(/t{1,2}/ig, '(am|pm|a|p)?')
                            .replace(/z{1}/ig, '((\\+|-)\\d\\d\\d\\d)?')
                            .replace(/\s/g, '\\s?') + this._defaults.timeSuffix + '$',
                     order = this._getFormatPositions(),
                     treg;

              if (!this.inst) this.inst = $.datepicker._getInst(this.$input[0]);

              if (withDate || !this._defaults.timeOnly) {
                     // the time should come after x number of characters and a space.
                     // x = at least the length of text specified by the date format
                     var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
                     // escape special regex characters in the seperator
                     var specials = new RegExp("[.*+?|()\\[\\]{}\\\\]", "g");
                     regstr = '.{' + dp_dateFormat.length + ',}' + this._defaults.separator.replace(specials, "\\$&") + regstr;
              }
              
              treg = timeString.match(new RegExp(regstr, 'i'));

              if (treg) {
                     if (order.t !== -1)
                            this.ampm = ((treg[order.t] === undefined || treg[order.t].length === 0) ?
                                   '' :
                                   (treg[order.t].charAt(0).toUpperCase() == 'A') ? 'AM' : 'PM').toUpperCase();

                     if (order.h !== -1) {
                            if (this.ampm == 'AM' && treg[order.h] == '12') 
                                   this.hour = 0; // 12am = 0 hour
                            else if (this.ampm == 'PM' && treg[order.h] != '12') 
                                   this.hour = (parseFloat(treg[order.h]) + 12).toFixed(0); // 12pm = 12 hour, any other pm = hour + 12
                            else this.hour = Number(treg[order.h]);
                     }

                     if (order.m !== -1) this.minute = Number(treg[order.m]);
                     if (order.s !== -1) this.second = Number(treg[order.s]);
                     if (order.z !== -1) this.timezone = treg[order.z];
                     
                     return true;

              }
              return false;
       },

       //########################################################################
       // figure out position of time elements.. cause js cant do named captures
       //########################################################################
       _getFormatPositions: function() {
              var finds = this._defaults.timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|t{1,2}|z)/g),
                     orders = { h: -1, m: -1, s: -1, t: -1, z: -1 };

              if (finds)
                     for (var i = 0; i < finds.length; i++)
                            if (orders[finds[i].toString().charAt(0)] == -1)
                                   orders[finds[i].toString().charAt(0)] = i + 1;

              return orders;
       },

       //########################################################################
       // generate and inject html for timepicker into ui datepicker
       //########################################################################
       _injectTimePicker: function() {
              var $dp = this.inst.dpDiv,
                     o = this._defaults,
                     tp_inst = this,
                     // Added by Peter Medeiros:
                     // - Figure out what the hour/minute/second max should be based on the step values.
                     // - Example: if stepMinute is 15, then minMax is 45.
                     hourMax = (o.hourMax - (o.hourMax % o.stepHour)).toFixed(0),
                     minMax  = (o.minuteMax - (o.minuteMax % o.stepMinute)).toFixed(0),
                     secMax  = (o.secondMax - (o.secondMax % o.stepSecond)).toFixed(0),
                     dp_id = this.inst.id.toString().replace(/([^A-Za-z0-9_])/g, '');

              // Prevent displaying twice
              //if ($dp.find("div#ui-timepicker-div-"+ dp_id).length === 0) {
              if ($dp.find("div#ui-timepicker-div-"+ dp_id).length === 0 && o.showTimepicker) {
                     var noDisplay = ' style="display:none;"',
                            html = '<div class="ui-timepicker-div" id="ui-timepicker-div-' + dp_id + '"><dl>' +
                                          '<dt class="ui_tpicker_time_label" id="ui_tpicker_time_label_' + dp_id + '"' +
                                          ((o.showTime) ? '' : noDisplay) + '>' + o.timeText + '</dt>' +
                                          '<dd class="ui_tpicker_time" id="ui_tpicker_time_' + dp_id + '"' +
                                          ((o.showTime) ? '' : noDisplay) + '></dd>' +
                                          '<dt class="ui_tpicker_hour_label" id="ui_tpicker_hour_label_' + dp_id + '"' +
                                          ((o.showHour) ? '' : noDisplay) + '>' + o.hourText + '</dt>',
                            hourGridSize = 0,
                            minuteGridSize = 0,
                            secondGridSize = 0,
                            size;
 
                     if (o.showHour && o.hourGrid > 0) {
                            html += '<dd class="ui_tpicker_hour">' +
                                          '<div id="ui_tpicker_hour_' + dp_id + '"' + ((o.showHour)   ? '' : noDisplay) + '></div>' +
                                          '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

                            for (var h = o.hourMin; h <= hourMax; h += o.hourGrid) {
                                   hourGridSize++;
                                   var tmph = (o.ampm && h > 12) ? h-12 : h;
                                   if (tmph < 10) tmph = '0' + tmph;
                                   if (o.ampm) {
                                          if (h == 0) tmph = 12 +'a';
                                          else if (h < 12) tmph += 'a';
                                          else tmph += 'p';
                                   }
                                   html += '<td>' + tmph + '</td>';
                            }

                            html += '</tr></table></div>' +
                                          '</dd>';
                     } else html += '<dd class="ui_tpicker_hour" id="ui_tpicker_hour_' + dp_id + '"' +
                                                 ((o.showHour) ? '' : noDisplay) + '></dd>';

                     html += '<dt class="ui_tpicker_minute_label" id="ui_tpicker_minute_label_' + dp_id + '"' +
                                   ((o.showMinute) ? '' : noDisplay) + '>' + o.minuteText + '</dt>';

                     if (o.showMinute && o.minuteGrid > 0) {
                            html += '<dd class="ui_tpicker_minute ui_tpicker_minute_' + o.minuteGrid + '">' +
                                          '<div id="ui_tpicker_minute_' + dp_id + '"' +
                                          ((o.showMinute) ? '' : noDisplay) + '></div>' +
                                          '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

                            for (var m = o.minuteMin; m <= minMax; m += o.minuteGrid) {
                                   minuteGridSize++;
                                   html += '<td>' + ((m < 10) ? '0' : '') + m + '</td>';
                            }

                            html += '</tr></table></div>' +
                                          '</dd>';
                     } else html += '<dd class="ui_tpicker_minute" id="ui_tpicker_minute_' + dp_id + '"' +
                                                 ((o.showMinute) ? '' : noDisplay) + '></dd>';

                     html += '<dt class="ui_tpicker_second_label" id="ui_tpicker_second_label_' + dp_id + '"' +
                                   ((o.showSecond) ? '' : noDisplay) + '>' + o.secondText + '</dt>';

                     if (o.showSecond && o.secondGrid > 0) {
                            html += '<dd class="ui_tpicker_second ui_tpicker_second_' + o.secondGrid + '">' +
                                          '<div id="ui_tpicker_second_' + dp_id + '"' +
                                          ((o.showSecond) ? '' : noDisplay) + '></div>' +
                                          '<div style="padding-left: 1px"><table><tr>';

                            for (var s = o.secondMin; s <= secMax; s += o.secondGrid) {
                                   secondGridSize++;
                                   html += '<td>' + ((s < 10) ? '0' : '') + s + '</td>';
                            }

                            html += '</tr></table></div>' +
                                          '</dd>';
                     } else html += '<dd class="ui_tpicker_second" id="ui_tpicker_second_' + dp_id + '"' +
                                                 ((o.showSecond) ? '' : noDisplay) + '></dd>';
                                                 
                     html += '<dt class="ui_tpicker_timezone_label" id="ui_tpicker_timezone_label_' + dp_id + '"' +
                                   ((o.showTimezone) ? '' : noDisplay) + '>' + o.timezoneText + '</dt>';
                     html += '<dd class="ui_tpicker_timezone" id="ui_tpicker_timezone_' + dp_id + '"'    +
                                                 ((o.showTimezone) ? '' : noDisplay) + '></dd>';

                     html += '</dl></div>';
                     $tp = $(html);

                            // if we only want time picker...
                     if (o.timeOnly === true) {
                            $tp.prepend(
                                   '<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' +
                                          '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' +
                                   '</div>');
                            $dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
                     }

                     this.hour_slider = $tp.find('#ui_tpicker_hour_'+ dp_id).slider({
                            orientation: "horizontal",
                            value: this.hour,
                            min: o.hourMin,
                            max: hourMax,
                            step: o.stepHour,
                            slide: function(event, ui) {
                                   tp_inst.hour_slider.slider( "option", "value", ui.value);
                                   tp_inst._onTimeChange();
                            }
                     });

                     // Updated by Peter Medeiros:
                     // - Pass in Event and UI instance into slide function
                     this.minute_slider = $tp.find('#ui_tpicker_minute_'+ dp_id).slider({
                            orientation: "horizontal",
                            value: this.minute,
                            min: o.minuteMin,
                            max: minMax,
                            step: o.stepMinute,
                            slide: function(event, ui) {
                                   // update the global minute slider instance value with the current slider value
                                   tp_inst.minute_slider.slider( "option", "value", ui.value);
                                   tp_inst._onTimeChange();
                            }
                     });

                     this.second_slider = $tp.find('#ui_tpicker_second_'+ dp_id).slider({
                            orientation: "horizontal",
                            value: this.second,
                            min: o.secondMin,
                            max: secMax,
                            step: o.stepSecond,
                            slide: function(event, ui) {
                                   tp_inst.second_slider.slider( "option", "value", ui.value);
                                   tp_inst._onTimeChange();
                            }
                     });
                     
                     
                     this.timezone_select = $tp.find('#ui_tpicker_timezone_'+ dp_id).append('<select></select>').find("select");
                     $.fn.append.apply(this.timezone_select,
                            $.map(o.timezoneList, function(val, idx) {
                                   return $("<option />")
                                          .val(typeof val == "object" ? val.value : val)
                                          .text(typeof val == "object" ? val.label : val);
                            })
                     );
                     this.timezone_select.val((typeof this.timezone != "undefined" && this.timezone != null && this.timezone != "") ? this.timezone : o.timezone);
                     this.timezone_select.change(function() {
                            tp_inst._onTimeChange();
                     });

                     // Add grid functionality
                     if (o.showHour && o.hourGrid > 0) {
                            size = 100 * hourGridSize * o.hourGrid / (hourMax - o.hourMin);

                            $tp.find(".ui_tpicker_hour table").css({
                                   width: size + "%",
                                   marginLeft: (size / (-2 * hourGridSize)) + "%",
                                   borderCollapse: 'collapse'
                            }).find("td").each( function(index) {
                                   $(this).click(function() {
                                          var h = $(this).html();
                                          if(o.ampm)    {
                                                 var ap = h.substring(2).toLowerCase(),
                                                        aph = parseInt(h.substring(0,2), 10);
                                                 if (ap == 'a') {
                                                        if (aph == 12) h = 0;
                                                        else h = aph;
                                                 } else if (aph == 12) h = 12;
                                                 else h = aph + 12;
                                          }
                                          tp_inst.hour_slider.slider("option", "value", h);
                                          tp_inst._onTimeChange();
                                          tp_inst._onSelectHandler();
                                   }).css({
                                          cursor: 'pointer',
                                          width: (100 / hourGridSize) + '%',
                                          textAlign: 'center',
                                          overflow: 'hidden'
                                   });
                            });
                     }

                     if (o.showMinute && o.minuteGrid > 0) {
                            size = 100 * minuteGridSize * o.minuteGrid / (minMax - o.minuteMin);
                            $tp.find(".ui_tpicker_minute table").css({
                                   width: size + "%",
                                   marginLeft: (size / (-2 * minuteGridSize)) + "%",
                                   borderCollapse: 'collapse'
                            }).find("td").each(function(index) {
                                   $(this).click(function() {
                                          tp_inst.minute_slider.slider("option", "value", $(this).html());
                                          tp_inst._onTimeChange();
                                          tp_inst._onSelectHandler();
                                   }).css({
                                          cursor: 'pointer',
                                          width: (100 / minuteGridSize) + '%',
                                          textAlign: 'center',
                                          overflow: 'hidden'
                                   });
                            });
                     }

                     if (o.showSecond && o.secondGrid > 0) {
                            $tp.find(".ui_tpicker_second table").css({
                                   width: size + "%",
                                   marginLeft: (size / (-2 * secondGridSize)) + "%",
                                   borderCollapse: 'collapse'
                            }).find("td").each(function(index) {
                                   $(this).click(function() {
                                          tp_inst.second_slider.slider("option", "value", $(this).html());
                                          tp_inst._onTimeChange();
                                          tp_inst._onSelectHandler();
                                   }).css({
                                          cursor: 'pointer',
                                          width: (100 / secondGridSize) + '%',
                                          textAlign: 'center',
                                          overflow: 'hidden'
                                   });
                            });
                     }

                     var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
                     if ($buttonPanel.length) $buttonPanel.before($tp);
                     else $dp.append($tp);

                     this.$timeObj = $tp.find('#ui_tpicker_time_'+ dp_id);

                     if (this.inst !== null) {
                            var timeDefined = this.timeDefined;
                            this._onTimeChange();
                            this.timeDefined = timeDefined;
                     }

                     //Emulate datepicker onSelect behavior. Call on slidestop.
                     var onSelectDelegate = function() {
                            tp_inst._onSelectHandler();
                     };
                     this.hour_slider.bind('slidestop',onSelectDelegate);
                     this.minute_slider.bind('slidestop',onSelectDelegate);
                     this.second_slider.bind('slidestop',onSelectDelegate);
              }
       },

       //########################################################################
       // This function tries to limit the ability to go outside the 
       // min/max date range
       //########################################################################
       _limitMinMaxDateTime: function(dp_inst, adjustSliders){
              var o = this._defaults,
                     dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

              if(!this._defaults.showTimepicker) return; // No time so nothing to check here

              if($.datepicker._get(dp_inst, 'minDateTime') !== null && dp_date){
                     var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
                            minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

                     if(this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null){
                            this.hourMinOriginal = o.hourMin;
                            this.minuteMinOriginal = o.minuteMin;
                            this.secondMinOriginal = o.secondMin;
                     }

                     if(dp_inst.settings.timeOnly || minDateTimeDate.getTime() == dp_date.getTime()) {
                            this._defaults.hourMin = minDateTime.getHours();
                            if (this.hour <= this._defaults.hourMin) {
                                   this.hour = this._defaults.hourMin;
                                   this._defaults.minuteMin = minDateTime.getMinutes();
                                   if (this.minute <= this._defaults.minuteMin) {
                                          this.minute = this._defaults.minuteMin;
                                          this._defaults.secondMin = minDateTime.getSeconds();
                                   } else {
                                          if(this.second < this._defaults.secondMin) this.second = this._defaults.secondMin;
                                          this._defaults.secondMin = this.secondMinOriginal;
                                   }
                            } else {
                                   this._defaults.minuteMin = this.minuteMinOriginal;
                                   this._defaults.secondMin = this.secondMinOriginal;
                            }
                     }else{
                            this._defaults.hourMin = this.hourMinOriginal;
                            this._defaults.minuteMin = this.minuteMinOriginal;
                            this._defaults.secondMin = this.secondMinOriginal;
                     }
              }

              if($.datepicker._get(dp_inst, 'maxDateTime') !== null && dp_date){
                     var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
                            maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);
       
                     if(this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null){
                            this.hourMaxOriginal = o.hourMax;
                            this.minuteMaxOriginal = o.minuteMax;
                            this.secondMaxOriginal = o.secondMax;
                     }

                     if(dp_inst.settings.timeOnly || maxDateTimeDate.getTime() == dp_date.getTime()){
                            this._defaults.hourMax = maxDateTime.getHours();
                            if (this.hour >= this._defaults.hourMax) {
                                   this.hour = this._defaults.hourMax;
                                   this._defaults.minuteMax = maxDateTime.getMinutes();
                                   if (this.minute >= this._defaults.minuteMax) {
                                          this.minute = this._defaults.minuteMax;
                                          this._defaults.secondMax = maxDateTime.getSeconds();
                                   } else {
                                          if(this.second > this._defaults.secondMax) this.second = this._defaults.secondMax;
                                          this._defaults.secondMax = this.secondMaxOriginal;
                                   }
                            } else {
                                   this._defaults.minuteMax = this.minuteMaxOriginal;
                                   this._defaults.secondMax = this.secondMaxOriginal;
                            }
                     }else{
                            this._defaults.hourMax = this.hourMaxOriginal;
                            this._defaults.minuteMax = this.minuteMaxOriginal;
                            this._defaults.secondMax = this.secondMaxOriginal;
                     }
              }

              if(adjustSliders !== undefined && adjustSliders === true){
                     var hourMax = (this._defaults.hourMax - (this._defaults.hourMax % this._defaults.stepHour)).toFixed(0),
                            minMax  = (this._defaults.minuteMax - (this._defaults.minuteMax % this._defaults.stepMinute)).toFixed(0),
                            secMax  = (this._defaults.secondMax - (this._defaults.secondMax % this._defaults.stepSecond)).toFixed(0);

                     if(this.hour_slider)
                            this.hour_slider.slider("option", { min: this._defaults.hourMin, max: hourMax }).slider('value', this.hour);
                     if(this.minute_slider)
                            this.minute_slider.slider("option", { min: this._defaults.minuteMin, max: minMax }).slider('value', this.minute);
                     if(this.second_slider)
                            this.second_slider.slider("option", { min: this._defaults.secondMin, max: secMax }).slider('value', this.second);
              }

       },

       
       //########################################################################
       // when a slider moves, set the internal time...
       // on time change is also called when the time is updated in the text field
       //########################################################################
       _onTimeChange: function() {
              var hour   = (this.hour_slider) ? this.hour_slider.slider('value') : false,
                     minute = (this.minute_slider) ? this.minute_slider.slider('value') : false,
                     second = (this.second_slider) ? this.second_slider.slider('value') : false,
                     timezone = (this.timezone_select) ? this.timezone_select.val() : false;

              if (typeof(hour) == 'object') hour = false;
              if (typeof(minute) == 'object') minute = false;
              if (typeof(second) == 'object') second = false;
              if (typeof(timezone) == 'object') timezone = false;

              if (hour !== false) hour = parseInt(hour,10);
              if (minute !== false) minute = parseInt(minute,10);
              if (second !== false) second = parseInt(second,10);

              var ampm = (hour < 12) ? 'AM' : 'PM';

              // If the update was done in the input field, the input field should not be updated.
              // If the update was done using the sliders, update the input field.
              var hasChanged = (hour != this.hour || minute != this.minute || second != this.second || (this.ampm.length > 0 && this.ampm != ampm) || timezone != this.timezone);
              
              if (hasChanged) {

                     if (hour !== false)this.hour = hour;
                     if (minute !== false) this.minute = minute;
                     if (second !== false) this.second = second;
                     if (timezone !== false) this.timezone = timezone;
                     
                     if (!this.inst) this.inst = $.datepicker._getInst(this.$input[0]);
                     
                     this._limitMinMaxDateTime(this.inst, true);
              }
              if (this._defaults.ampm) this.ampm = ampm;
              
              this._formatTime();
              if (this.$timeObj) this.$timeObj.text(this.formattedTime + this._defaults.timeSuffix);
              this.timeDefined = true;
              if (hasChanged) this._updateDateTime();
       },
    
       //########################################################################
       // call custom onSelect. 
       // bind to sliders slidestop, and grid click.
       //########################################################################
       _onSelectHandler: function() {
              var onSelect = this._defaults['onSelect'];
              var inputEl = this.$input ? this.$input[0] : null;
              if (onSelect && inputEl) {
                     onSelect.apply(inputEl, [this.formattedDateTime, this]);
              }
       },

       //########################################################################
       // format the time all pretty...
       //########################################################################
       _formatTime: function(time, format, ampm) {
              if (ampm == undefined) ampm = this._defaults.ampm;
              time = time || { hour: this.hour, minute: this.minute, second: this.second, ampm: this.ampm, timezone: this.timezone };
              var tmptime = format || this._defaults.timeFormat.toString();

              if (ampm) {
                     var hour12 = ((time.ampm == 'AM') ? (time.hour) : (time.hour % 12));
                     hour12 = (Number(hour12) === 0) ? 12 : hour12;
                     tmptime = tmptime.toString()
                            .replace(/hh/g, ((hour12 < 10) ? '0' : '') + hour12)
                            .replace(/h/g, hour12)
                            .replace(/mm/g, ((time.minute < 10) ? '0' : '') + time.minute)
                            .replace(/m/g, time.minute)
                            .replace(/ss/g, ((time.second < 10) ? '0' : '') + time.second)
                            .replace(/s/g, time.second)
                            .replace(/TT/g, time.ampm.toUpperCase())
                            .replace(/Tt/g, time.ampm.toUpperCase())
                            .replace(/tT/g, time.ampm.toLowerCase())
                            .replace(/tt/g, time.ampm.toLowerCase())
                            .replace(/T/g, time.ampm.charAt(0).toUpperCase())
                            .replace(/t/g, time.ampm.charAt(0).toLowerCase())
                            .replace(/z/g, time.timezone);
              } else {
                     tmptime = tmptime.toString()
                            .replace(/hh/g, ((time.hour < 10) ? '0' : '') + time.hour)
                            .replace(/h/g, time.hour)
                            .replace(/mm/g, ((time.minute < 10) ? '0' : '') + time.minute)
                            .replace(/m/g, time.minute)
                            .replace(/ss/g, ((time.second < 10) ? '0' : '') + time.second)
                            .replace(/s/g, time.second)
                            .replace(/z/g, time.timezone);
                     tmptime = $.trim(tmptime.replace(/t/gi, ''));
              }

              if (arguments.length) return tmptime;
              else this.formattedTime = tmptime;
       },

       //########################################################################
       // update our input with the new date time..
       //########################################################################
       _updateDateTime: function(dp_inst) {
              dp_inst = this.inst || dp_inst,
                     dt = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay),
                     dateFmt = $.datepicker._get(dp_inst, 'dateFormat'),
                     formatCfg = $.datepicker._getFormatConfig(dp_inst),
                     timeAvailable = dt !== null && this.timeDefined;
              this.formattedDate = $.datepicker.formatDate(dateFmt, (dt === null ? new Date() : dt), formatCfg);
              var formattedDateTime = this.formattedDate;
              if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0))
                     return;

              if (this._defaults.timeOnly === true) {
                     formattedDateTime = this.formattedTime;
              } else if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable)) {
                     formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
              }

              this.formattedDateTime = formattedDateTime;

              if(!this._defaults.showTimepicker) {
                     this.$input.val(this.formattedDate);
              } else if (this.$altInput && this._defaults.altFieldTimeOnly === true) {
                     this.$altInput.val(this.formattedTime);
                     this.$input.val(this.formattedDate);
              } else if(this.$altInput) {
                     this.$altInput.val(formattedDateTime);
                     this.$input.val(formattedDateTime);
              } else {
                     this.$input.val(formattedDateTime);
              }
              
              this.$input.trigger("change");
       }

});

$.fn.extend({
       //########################################################################
       // shorthand just to use timepicker..
       //########################################################################
       timepicker: function(o) {
              o = o || {};
              var tmp_args = arguments;

              if (typeof o == 'object') tmp_args[0] = $.extend(o, { timeOnly: true });

              return $(this).each(function() {
                     $.fn.datetimepicker.apply($(this), tmp_args);
              });
       },

       //########################################################################
       // extend timepicker to datepicker
       //########################################################################
       datetimepicker: function(o) {
              o = o || {};
              var $input = this,
              tmp_args = arguments;

              if (typeof(o) == 'string'){
                     if(o == 'getDate') 
                            return $.fn.datepicker.apply($(this[0]), tmp_args);
                     else 
                            return this.each(function() {
                                   var $t = $(this);
                                   $t.datepicker.apply($t, tmp_args);
                            });
              }
              else
                     return this.each(function() {
                            var $t = $(this);
                            $t.datepicker($.timepicker._newInst($t, o)._defaults);
                     });
       }
});

//########################################################################
// the bad hack :/ override datepicker so it doesnt close on select
// inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
//########################################################################
$.datepicker._base_selectDate = $.datepicker._selectDate;
$.datepicker._selectDate = function (id, dateStr) {
       var inst = this._getInst($(id)[0]),
              tp_inst = this._get(inst, 'timepicker');

       if (tp_inst) {
              tp_inst._limitMinMaxDateTime(inst, true);
              inst.inline = inst.stay_open = true;
              //This way the onSelect handler called from calendarpicker get the full dateTime
              this._base_selectDate(id, dateStr + tp_inst._defaults.separator + tp_inst.formattedTime + tp_inst._defaults.timeSuffix);
              inst.inline = inst.stay_open = false;
              this._notifyChange(inst);
              this._updateDatepicker(inst);
       }
       else this._base_selectDate(id, dateStr);
};

//#############################################################################################
// second bad hack :/ override datepicker so it triggers an event when changing the input field
// and does not redraw the datepicker on every selectDate event
//#############################################################################################
$.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
$.datepicker._updateDatepicker = function(inst) {

       // don't popup the datepicker if there is another instance already opened
       var input = inst.input[0];
       if($.datepicker._curInst &&
          $.datepicker._curInst != inst &&
          $.datepicker._datepickerShowing &&
          $.datepicker._lastInput != input) {
              return;
       }

       if (typeof(inst.stay_open) !== 'boolean' || inst.stay_open === false) {
                            
              this._base_updateDatepicker(inst);
              
              // Reload the time control when changing something in the input text field.
              var tp_inst = this._get(inst, 'timepicker');
              if(tp_inst) tp_inst._addTimePicker(inst);
       }
};

//#######################################################################################
// third bad hack :/ override datepicker so it allows spaces and colon in the input field
//#######################################################################################
$.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
$.datepicker._doKeyPress = function(event) {
       var inst = $.datepicker._getInst(event.target),
              tp_inst = $.datepicker._get(inst, 'timepicker');

       if (tp_inst) {
              if ($.datepicker._get(inst, 'constrainInput')) {
                     var ampm = tp_inst._defaults.ampm,
                            dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
                            datetimeChars = tp_inst._defaults.timeFormat.toString()
                                                        .replace(/[hms]/g, '')
                                                        .replace(/TT/g, ampm ? 'APM' : '')
                                                        .replace(/Tt/g, ampm ? 'AaPpMm' : '')
                                                        .replace(/tT/g, ampm ? 'AaPpMm' : '')
                                                        .replace(/T/g, ampm ? 'AP' : '')
                                                        .replace(/tt/g, ampm ? 'apm' : '')
                                                        .replace(/t/g, ampm ? 'ap' : '') +
                                                        " " +
                                                        tp_inst._defaults.separator +
                                                        tp_inst._defaults.timeSuffix +
                                                        (tp_inst._defaults.showTimezone ? tp_inst._defaults.timezoneList.join('') : '') +
                                                        dateChars,
                            chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
                     return event.ctrlKey || (chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1);
              }
       }
       
       return $.datepicker._base_doKeyPress(event);
};

//#######################################################################################
// Override key up event to sync manual input changes.
//#######################################################################################
$.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
$.datepicker._doKeyUp = function (event) {
       var inst = $.datepicker._getInst(event.target),
              tp_inst = $.datepicker._get(inst, 'timepicker');

       if (tp_inst) {
              if (tp_inst._defaults.timeOnly && (inst.input.val() != inst.lastVal)) {
                     try {
                            $.datepicker._updateDatepicker(inst);
                     }
                     catch (err) {
                            $.datepicker.log(err);
                     }
              }
       }

       return $.datepicker._base_doKeyUp(event);
};

//#######################################################################################
// override "Today" button to also grab the time.
//#######################################################################################
$.datepicker._base_gotoToday = $.datepicker._gotoToday;
$.datepicker._gotoToday = function(id) {
       this._base_gotoToday(id);
       this._setTime(this._getInst($(id)[0]), new Date());
};

//#######################################################################################
// Disable & enable the Time in the datetimepicker
//#######################################################################################
$.datepicker._disableTimepickerDatepicker = function(target, date, withDate) {
       var inst = this._getInst(target),
       tp_inst = this._get(inst, 'timepicker');
       $(target).datepicker('getDate'); // Init selected[Year|Month|Day]
       if (tp_inst) {
              tp_inst._defaults.showTimepicker = false;
              tp_inst._updateDateTime(inst);
       }
};

$.datepicker._enableTimepickerDatepicker = function(target, date, withDate) {
       var inst = this._getInst(target),
       tp_inst = this._get(inst, 'timepicker');
       $(target).datepicker('getDate'); // Init selected[Year|Month|Day]
       if (tp_inst) {
              tp_inst._defaults.showTimepicker = true;
              tp_inst._addTimePicker(inst); // Could be disabled on page load
              tp_inst._updateDateTime(inst);
       }
};

//#######################################################################################
// Create our own set time function
//#######################################################################################
$.datepicker._setTime = function(inst, date) {
       var tp_inst = this._get(inst, 'timepicker');
       if (tp_inst) {
              var defaults = tp_inst._defaults,
                     // calling _setTime with no date sets time to defaults
                     hour = date ? date.getHours() : defaults.hour,
                     minute = date ? date.getMinutes() : defaults.minute,
                     second = date ? date.getSeconds() : defaults.second;

              //check if within min/max times..
              if ((hour < defaults.hourMin || hour > defaults.hourMax) || (minute < defaults.minuteMin || minute > defaults.minuteMax) || (second < defaults.secondMin || second > defaults.secondMax)) {
                     hour = defaults.hourMin;
                     minute = defaults.minuteMin;
                     second = defaults.secondMin;
              }

              tp_inst.hour = hour;
              tp_inst.minute = minute;
              tp_inst.second = second;

              if (tp_inst.hour_slider) tp_inst.hour_slider.slider('value', hour);
              if (tp_inst.minute_slider) tp_inst.minute_slider.slider('value', minute);
              if (tp_inst.second_slider) tp_inst.second_slider.slider('value', second);

              tp_inst._onTimeChange();
              tp_inst._updateDateTime(inst);
       }
};

//#######################################################################################
// Create new public method to set only time, callable as $().datepicker('setTime', date)
//#######################################################################################
$.datepicker._setTimeDatepicker = function(target, date, withDate) {
       var inst = this._getInst(target),
              tp_inst = this._get(inst, 'timepicker');

       if (tp_inst) {
              this._setDateFromField(inst);
              var tp_date;
              if (date) {
                     if (typeof date == "string") {
                            tp_inst._parseTime(date, withDate);
                            tp_date = new Date();
                            tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second);
                     }
                     else tp_date = new Date(date.getTime());
                     if (tp_date.toString() == 'Invalid Date') tp_date = undefined;
                     this._setTime(inst, tp_date);
              }
       }

};

//#######################################################################################
// override setDate() to allow setting time too within Date object
//#######################################################################################
$.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
$.datepicker._setDateDatepicker = function(target, date) {
       var inst = this._getInst(target),
       tp_date = (date instanceof Date) ? new Date(date.getTime()) : date;

       this._updateDatepicker(inst);
       this._base_setDateDatepicker.apply(this, arguments);
       this._setTimeDatepicker(target, tp_date, true);
};

//#######################################################################################
// override getDate() to allow getting time too within Date object
//#######################################################################################
$.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
$.datepicker._getDateDatepicker = function(target, noDefault) {
       var inst = this._getInst(target),
              tp_inst = this._get(inst, 'timepicker');

       if (tp_inst) {
              this._setDateFromField(inst, noDefault);
              var date = this._getDate(inst);
              if (date && tp_inst._parseTime($(target).val(), tp_inst.timeOnly)) date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second);
              return date;
       }
       return this._base_getDateDatepicker(target, noDefault);
};

//#######################################################################################
// override parseDate() because UI 1.8.14 throws an error about "Extra characters"
// An option in datapicker to ignore extra format characters would be nicer.
//#######################################################################################
$.datepicker._base_parseDate = $.datepicker.parseDate;
$.datepicker.parseDate = function(format, value, settings) {
       var date;
       try {
              date = this._base_parseDate(format, value, settings);
       } catch (err) {
              // Hack!  The error message ends with a colon, a space, and
              // the "extra" characters.  We rely on that instead of
              // attempting to perfectly reproduce the parsing algorithm.
              date = this._base_parseDate(format, value.substring(0,value.length-(err.length-err.indexOf(':')-2)), settings);
       }
       return date;
};

//#######################################################################################
// override options setter to add time to maxDate(Time) and minDate(Time)
//#######################################################################################
$.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
$.datepicker._optionDatepicker = function(target, name, value) {
       this._base_optionDatepicker(target, name, value);
       var inst = this._getInst(target),
              tp_inst = this._get(inst, 'timepicker');
       if (tp_inst) {
              //Set minimum and maximum date values if we have timepicker
              if(name==='minDate') {
              if(tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date)
                            tp_inst._defaults.minDateTime = new Date(value);
                     if(tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date)
                            tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
                     tp_inst._limitMinMaxDateTime(inst,true);
              }
              if(name==='maxDate') {
                     if(tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date)
                            tp_inst._defaults.maxDateTime = new Date(value);
                     if(tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date)
                            tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
                     tp_inst._limitMinMaxDateTime(inst,true);
              }
       }
};

//#######################################################################################
// jQuery extend now ignores nulls!
//#######################################################################################
function extendRemove(target, props) {
       $.extend(target, props);
       for (var name in props)
              if (props[name] === null || props[name] === undefined)
                     target[name] = props[name];
       return target;
}

$.timepicker = new Timepicker(); // singleton instance
$.timepicker.version = "0.9.6";

})(jQuery);

/*************************************************************************
 jquery.dynatree.js
 Dynamic tree view control, with support for lazy loading of branches.

 Copyright (c) 2006-2012, Martin Wendt (http://wwWendt.de)
 Dual licensed under the MIT or GPL Version 2 licenses.
 http://code.google.com/p/dynatree/wiki/LicenseInfo

 A current version and some documentation is available at
        http://dynatree.googlecode.com/

 $Version: 1.2.1$
 $Revision: 606, 2012-06-12 08:10:04$

 @depends: jquery.js
 @depends: jquery.ui.core.js
 @depends: jquery.cookie.js
*************************************************************************/

// Note: We currently allow eval() to parse the 'data' attribtes, when initializing from HTML.

/* jsLint options*/
// TODO: does not pass jsLint
/*NOT_YET_jslint browser: true, evil: true, indent: 4, sloppy: true, nomen: true, vars: true, white: true, plusplus: true*/
/*global alert */

/* jsHint options*/
// TODO: pass jsHint with the options given in grunt.js only.
//       The following should not be required:
/*jshint nomen:false, smarttabs:true, eqeqeq:false, evil:true, regexp:false */

/*************************************************************************
 *     Debug functions
 */

var _canLog = true;

function _log(mode, msg) {
       /**
        * Usage: logMsg("%o was toggled", this);
        */
       if( !_canLog ){
              return;
       }
       // Remove first argument
       var args = Array.prototype.slice.apply(arguments, [1]);
       // Prepend timestamp
       var dt = new Date();
       var tag = dt.getHours()+":"+dt.getMinutes()+":"+dt.getSeconds()+"."+dt.getMilliseconds();
       args[0] = tag + " - " + args[0];

       try {
              switch( mode ) {
              case "info":
                     window.console.info.apply(window.console, args);
                     break;
              case "warn":
                     window.console.warn.apply(window.console, args);
                     break;
              default:
                     window.console.log.apply(window.console, args);
                     break;
              }
       } catch(e) {
              if( !window.console ){
                     _canLog = false; // Permanently disable, when logging is not supported by the browser
              }
       }
}

function logMsg(msg) {
       Array.prototype.unshift.apply(arguments, ["debug"]);
       _log.apply(this, arguments);
}


// Forward declaration
var getDynaTreePersistData = null;



/*************************************************************************
 *     Constants
 */
var DTNodeStatus_Error   = -1;
var DTNodeStatus_Loading = 1;
var DTNodeStatus_Ok      = 0;


// Start of local namespace
(function($) {

/*************************************************************************
 *     Common tool functions.
 */

var Class = {
       create: function() {
              return function() {
                     this.initialize.apply(this, arguments);
              };
       }
};

// Tool function to get dtnode from the event target:
function getDtNodeFromElement(el) {
       alert("getDtNodeFromElement is deprecated");
       return $.ui.dynatree.getNode(el);
/*
       var iMax = 5;
       while( el && iMax-- ) {
              if(el.dtnode) { return el.dtnode; }
              el = el.parentNode;
       }
       return null;
*/
}

function noop() {
}

/*************************************************************************
 *     Class DynaTreeNode
 */
var DynaTreeNode = Class.create();

DynaTreeNode.prototype = {
       initialize: function(parent, tree, data) {
              /**
               * @constructor
               */
              this.parent = parent;
              this.tree = tree;
              if ( typeof data === "string" ){
                     data = { title: data };
              }
              if( data.key === undefined ){
                     data.key = "_" + tree._nodeCount++;
              }
              this.data = $.extend({}, $.ui.dynatree.nodedatadefaults, data);
              this.li = null; // not yet created
              this.span = null; // not yet created
              this.ul = null; // not yet created
              this.childList = null; // no subnodes yet
              this._isLoading = false; // Lazy content is being loaded
              this.hasSubSel = false;
              this.bExpanded = false;
              this.bSelected = false;

       },

       toString: function() {
              return "DynaTreeNode<" + this.data.key + ">: '" + this.data.title + "'";
       },

       toDict: function(recursive, callback) {
              var dict = $.extend({}, this.data);
              dict.activate = ( this.tree.activeNode === this );
              dict.focus = ( this.tree.focusNode === this );
              dict.expand = this.bExpanded;
              dict.select = this.bSelected;
              if( callback ){
                     callback(dict);
              }
              if( recursive && this.childList ) {
                     dict.children = [];
                     for(var i=0, l=this.childList.length; i<l; i++ ){
                            dict.children.push(this.childList[i].toDict(true, callback));
                     }
              } else {
                     delete dict.children;
              }
              return dict;
       },

       fromDict: function(dict) {
              /**
               * Update node data. If dict contains 'children', then also replace
               * the hole sub tree.
               */
              var children = dict.children;
              if(children === undefined){
                     this.data = $.extend(this.data, dict);
                     this.render();
                     return;
              }
              dict = $.extend({}, dict);
              dict.children = undefined;
              this.data = $.extend(this.data, dict);
              this.removeChildren();
              this.addChild(children);
       },

       _getInnerHtml: function() {
              var tree = this.tree,
                     opts = tree.options,
                     cache = tree.cache,
                     level = this.getLevel(),
                     data = this.data,
                     res = "";
              // connector (expanded, expandable or simple)
              if( level < opts.minExpandLevel ) {
                     if(level > 1){
                            res += cache.tagConnector;
                     }
                     // .. else (i.e. for root level) skip expander/connector altogether
              } else if( this.hasChildren() !== false ) {
                     res += cache.tagExpander;
              } else {
                     res += cache.tagConnector;
              }
              // Checkbox mode
              if( opts.checkbox && data.hideCheckbox !== true && !data.isStatusNode ) {
                     res += cache.tagCheckbox;
              }
              // folder or doctype icon
              if ( data.icon ) {
                     res += "<img src='" + opts.imagePath + data.icon + "' alt='' />";
              } else if ( data.icon === false ) {
                     // icon == false means 'no icon'
                     noop(); // keep JSLint happy
              } else {
                     // icon == null means 'default icon'
                     res += cache.tagNodeIcon;
              }
              // node title
              var nodeTitle = "";
              if ( opts.onCustomRender ){
                     nodeTitle = opts.onCustomRender.call(tree, this) || "";
              }
              if(!nodeTitle){
                     var tooltip = data.tooltip ? ' title="' + data.tooltip.replace(/\"/g, '&quot;') + '"' : '',
                            href = data.href || "#";
                     if( opts.noLink || data.noLink ) {
                            nodeTitle = '<span style="display:inline-block;" class="' + opts.classNames.title + '"' + tooltip + '>' + data.title + '</span>';
//                          this.tree.logDebug("nodeTitle: " + nodeTitle);
                     } else {
                            nodeTitle = '<a href="' + href + '" class="' + opts.classNames.title + '"' + tooltip + '>' + data.title + '</a>';
                     }
              }
              res += nodeTitle;
              return res;
       },


       _fixOrder: function() {
              /**
               * Make sure, that <li> order matches childList order.
               */
              var cl = this.childList;
              if( !cl || !this.ul ){
                     return;
              }
              var childLI = this.ul.firstChild;
              for(var i=0, l=cl.length-1; i<l; i++) {
                     var childNode1 = cl[i];
                     var childNode2 = childLI.dtnode;
                     if( childNode1 !== childNode2 ) {
                            this.tree.logDebug("_fixOrder: mismatch at index " + i + ": " + childNode1 + " != " + childNode2);
                            this.ul.insertBefore(childNode1.li, childNode2.li);
                     } else {
                            childLI = childLI.nextSibling;
                     }
              }
       },


       render: function(useEffects, includeInvisible) {
              /**
               * Create <li><span>..</span> .. </li> tags for this node.
               *
               * <li id='KEY' dtnode=NODE> // This div contains the node's span and list of child div's.
               *   <span class='title'>S S S A</span> // Span contains graphic spans and title <a> tag
               *   <ul> // only present, when node has children
               *       <li id='KEY' dtnode=NODE>child1</li>
               *       <li id='KEY' dtnode=NODE>child2</li>
               *   </ul>
               * </li>
               */
//            this.tree.logDebug("%s.render(%s)", this, useEffects);
              // ---
              var tree = this.tree,
                     parent = this.parent,
                     data = this.data,
                     opts = tree.options,
                     cn = opts.classNames,
                     isLastSib = this.isLastSibling(),
                     firstTime = false;

              if( !parent && !this.ul ) {
                     // Root node has only a <ul>
                     this.li = this.span = null;
                     this.ul = document.createElement("ul");
                     if( opts.minExpandLevel > 1 ){
                            this.ul.className = cn.container + " " + cn.noConnector;
                     }else{
                            this.ul.className = cn.container;
                     }
              } else if( parent ) {
                     // Create <li><span /> </li>
                     if( ! this.li ) {
                            firstTime = true;
                            this.li = document.createElement("li");
                            this.li.dtnode = this;
                            if( data.key && opts.generateIds ){
                                   this.li.id = opts.idPrefix + data.key;
                            }
                            this.span = document.createElement("span");
                            this.span.className = cn.title;
                            this.li.appendChild(this.span);

                            if( !parent.ul ) {
                                   // This is the parent's first child: create UL tag
                                   // (Hidden, because it will be
                                   parent.ul = document.createElement("ul");
                                   parent.ul.style.display = "none";
                                   parent.li.appendChild(parent.ul);
//                                 if( opts.minExpandLevel > this.getLevel() ){
//                                        parent.ul.className = cn.noConnector;
//                                 }
                            }
                            // set node connector images, links and text
//                          this.span.innerHTML = this._getInnerHtml();

                            parent.ul.appendChild(this.li);
                     }
                     // set node connector images, links and text
                     this.span.innerHTML = this._getInnerHtml();
                     // Set classes for current status
                     var cnList = [];
                     cnList.push(cn.node);
                     if( data.isFolder ){
                            cnList.push(cn.folder);
                     }
                     if( this.bExpanded ){
                            cnList.push(cn.expanded);
                     }
                     if( this.hasChildren() !== false ){
                            cnList.push(cn.hasChildren);
                     }
                     if( data.isLazy && this.childList === null ){
                            cnList.push(cn.lazy);
                     }
                     if( isLastSib ){
                            cnList.push(cn.lastsib);
                     }
                     if( this.bSelected ){
                            cnList.push(cn.selected);
                     }
                     if( this.hasSubSel ){
                            cnList.push(cn.partsel);
                     }
                     if( tree.activeNode === this ){
                            cnList.push(cn.active);
                     }
                     if( data.addClass ){
                            cnList.push(data.addClass);
                     }
                     // IE6 doesn't correctly evaluate multiple class names,
                     // so we create combined class names that can be used in the CSS
                     cnList.push(cn.combinedExpanderPrefix
                                   + (this.bExpanded ? "e" : "c")
                                   + (data.isLazy && this.childList === null ? "d" : "")
                                   + (isLastSib ? "l" : "")
                                   );
                     cnList.push(cn.combinedIconPrefix
                                   + (this.bExpanded ? "e" : "c")
                                   + (data.isFolder ? "f" : "")
                                   );
                     this.span.className = cnList.join(" ");

                     // TODO: we should not set this in the <span> tag also, if we set it here:
                     this.li.className = isLastSib ? cn.lastsib : "";

                     // Allow tweaking, binding, after node was created for the first time
                     if(firstTime && opts.onCreate){
                            opts.onCreate.call(tree, this, this.span);
                     }
                     // Hide children, if node is collapsed
//                   this.ul.style.display = ( this.bExpanded || !parent ) ? "" : "none";
                     // Allow tweaking after node state was rendered
                     if(opts.onRender){
                            opts.onRender.call(tree, this, this.span);
                     }
              }
              // Visit child nodes
              if( (this.bExpanded || includeInvisible === true) && this.childList ) {
                     for(var i=0, l=this.childList.length; i<l; i++) {
                            this.childList[i].render(false, includeInvisible);
                     }
                     // Make sure the tag order matches the child array
                     this._fixOrder();
              }
              // Hide children, if node is collapsed
              if( this.ul ) {
                     var isHidden = (this.ul.style.display === "none");
                     var isExpanded = !!this.bExpanded;
//                   logMsg("isHidden:%s", isHidden);
                     if( useEffects && opts.fx && (isHidden === isExpanded) ) {
                            var duration = opts.fx.duration || 200;
                            $(this.ul).animate(opts.fx, duration);
                     } else {
                            this.ul.style.display = ( this.bExpanded || !parent ) ? "" : "none";
                     }
              }
       },
       /** Return '/id1/id2/id3'. */
       getKeyPath: function(excludeSelf) {
              var path = [];
              this.visitParents(function(node){
                     if(node.parent){
                            path.unshift(node.data.key);
                     }
              }, !excludeSelf);
              return "/" + path.join(this.tree.options.keyPathSeparator);
       },

       getParent: function() {
              return this.parent;
       },

       getChildren: function() {
              if(this.hasChildren() === undefined){
                     return undefined; // Lazy node: unloaded, currently loading, or load error
              }
              return this.childList;
       },

       /** Check if node has children (returns undefined, if not sure). */
       hasChildren: function() {
              if(this.data.isLazy){
                     if(this.childList === null || this.childList === undefined){
                            // Not yet loaded
                            return undefined;
                     }else if(this.childList.length === 0){
                            // Loaded, but response was empty
                            return false;
                     }else if(this.childList.length === 1 && this.childList[0].isStatusNode()){
                            // Currently loading or load error
                            return undefined;
                     }
                     return true;
              }
              return !!this.childList;
       },

       isFirstSibling: function() {
              var p = this.parent;
              return !p || p.childList[0] === this;
       },

       isLastSibling: function() {
              var p = this.parent;
              return !p || p.childList[p.childList.length-1] === this;
       },

       isLoading: function() {
              return !!this._isLoading;
       },

       getPrevSibling: function() {
              if( !this.parent ){
                     return null;
              }
              var ac = this.parent.childList;
              for(var i=1, l=ac.length; i<l; i++){ // start with 1, so prev(first) = null
                     if( ac[i] === this ){
                            return ac[i-1];
                     }
              }
              return null;
       },

       getNextSibling: function() {
              if( !this.parent ){
                     return null;
              }
              var ac = this.parent.childList;
              for(var i=0, l=ac.length-1; i<l; i++){ // up to length-2, so next(last) = null
                     if( ac[i] === this ){
                            return ac[i+1];
                     }
              }
              return null;
       },

       isStatusNode: function() {
              return (this.data.isStatusNode === true);
       },

       isChildOf: function(otherNode) {
              return (this.parent && this.parent === otherNode);
       },

       isDescendantOf: function(otherNode) {
              if(!otherNode){
                     return false;
              }
              var p = this.parent;
              while( p ) {
                     if( p === otherNode ){
                            return true;
                     }
                     p = p.parent;
              }
              return false;
       },

       countChildren: function() {
              var cl = this.childList;
              if( !cl ){
                     return 0;
              }
              var n = cl.length;
              for(var i=0, l=n; i<l; i++){
                     var child = cl[i];
                     n += child.countChildren();
              }
              return n;
       },

       /**Sort child list by title.
        * cmd: optional compare function.
        * deep: optional: pass true to sort all descendant nodes.
        */
       sortChildren: function(cmp, deep) {
              var cl = this.childList;
              if( !cl ){
                     return;
              }
              cmp = cmp || function(a, b) {
//                   return a.data.title === b.data.title ? 0 : a.data.title > b.data.title ? 1 : -1;
                     var x = a.data.title.toLowerCase(),
                            y = b.data.title.toLowerCase();
                     return x === y ? 0 : x > y ? 1 : -1;
                     };
              cl.sort(cmp);
              if( deep ){
                     for(var i=0, l=cl.length; i<l; i++){
                            if( cl[i].childList ){
                                   cl[i].sortChildren(cmp, "$norender$");
                            }
                     }
              }
              if( deep !== "$norender$" ){
                     this.render();
              }
       },

       _setStatusNode: function(data) {
              // Create, modify or remove the status child node (pass 'null', to remove it).
              var firstChild = ( this.childList ? this.childList[0] : null );
              if( !data ) {
                     if ( firstChild && firstChild.isStatusNode()) {
                            try{
                                   // I've seen exceptions here with loadKeyPath...
                                   if(this.ul){
                                          this.ul.removeChild(firstChild.li);
                                          firstChild.li = null; // avoid leaks (issue 215)
                                   }
                            }catch(e){}
                            if( this.childList.length === 1 ){
                                   this.childList = [];
                            }else{
                                   this.childList.shift();
                            }
                     }
              } else if ( firstChild ) {
                     data.isStatusNode = true;
                     data.key = "_statusNode";
                     firstChild.data = data;
                     firstChild.render();
              } else {
                     data.isStatusNode = true;
                     data.key = "_statusNode";
                     firstChild = this.addChild(data);
              }
       },

       setLazyNodeStatus: function(lts, opts) {
              var tooltip = (opts && opts.tooltip) ? opts.tooltip : null,
                     info = (opts && opts.info) ? " (" + opts.info + ")" : "";
              switch( lts ) {
                     case DTNodeStatus_Ok:
                            this._setStatusNode(null);
                            $(this.span).removeClass(this.tree.options.classNames.nodeLoading);
                            this._isLoading = false;
//                          this.render();
                            if( this.tree.options.autoFocus ) {
                                   if( this === this.tree.tnRoot && this.childList && this.childList.length > 0) {
                                          // special case: using ajaxInit
                                          this.childList[0].focus();
                                   } else {
                                          this.focus();
                                   }
                            }
                            break;
                     case DTNodeStatus_Loading:
                            this._isLoading = true;
                            $(this.span).addClass(this.tree.options.classNames.nodeLoading);
                            // The root is hidden, so we set a temporary status child
                            if(!this.parent){
                                   this._setStatusNode({
                                          title: this.tree.options.strings.loading + info,
                                          tooltip: tooltip,
                                          addClass: this.tree.options.classNames.nodeWait
                                   });
                            }
                            break;
                     case DTNodeStatus_Error:
                            this._isLoading = false;
//                          $(this.span).addClass(this.tree.options.classNames.nodeError);
                            this._setStatusNode({
                                   title: this.tree.options.strings.loadError + info,
                                   tooltip: tooltip,
                                   addClass: this.tree.options.classNames.nodeError
                            });
                            break;
                     default:
                            throw "Bad LazyNodeStatus: '" + lts + "'.";
              }
       },

       _parentList: function(includeRoot, includeSelf) {
              var l = [];
              var dtn = includeSelf ? this : this.parent;
              while( dtn ) {
                     if( includeRoot || dtn.parent ){
                            l.unshift(dtn);
                     }
                     dtn = dtn.parent;
              }
              return l;
       },
       getLevel: function() {
              /**
               * Return node depth. 0: System root node, 1: visible top-level node.
               */
              var level = 0;
              var dtn = this.parent;
              while( dtn ) {
                     level++;
                     dtn = dtn.parent;
              }
              return level;
       },

       _getTypeForOuterNodeEvent: function(event) {
              /** Return the inner node span (title, checkbox or expander) if
               *  event.target points to the outer span.
               *  This function should fix issue #93:
               *  FF2 ignores empty spans, when generating events (returning the parent instead).
               */
              var cns = this.tree.options.classNames;
              var target = event.target;
              // Only process clicks on an outer node span (probably due to a FF2 event handling bug)
              if( target.className.indexOf(cns.node) < 0 ) {
                     return null;
              }
              // Event coordinates, relative to outer node span:
              var eventX = event.pageX - target.offsetLeft;
              var eventY = event.pageY - target.offsetTop;

              for(var i=0, l=target.childNodes.length; i<l; i++) {
                     var cn = target.childNodes[i];
                     var x = cn.offsetLeft - target.offsetLeft;
                     var y = cn.offsetTop - target.offsetTop;
                     var nx = cn.clientWidth, ny = cn.clientHeight;
//             alert (cn.className + ": " + x + ", " + y + ", s:" + nx + ", " + ny);
                     if( eventX >= x && eventX <= (x+nx) && eventY >= y && eventY <= (y+ny) ) {
//                 alert("HIT "+ cn.className);
                            if( cn.className==cns.title ){
                                   return "title";
                            }else if( cn.className==cns.expander ){
                                   return "expander";
                            }else if( cn.className==cns.checkbox ){
                                   return "checkbox";
                            }else if( cn.className==cns.nodeIcon ){
                                   return "icon";
                            }
                     }
              }
              return "prefix";
       },

       getEventTargetType: function(event) {
              // Return the part of a node, that a click event occured on.
              // Note: there is no check, if the event was fired on THIS node.
              var tcn = event && event.target ? event.target.className : "",
                     cns = this.tree.options.classNames;

              if( tcn === cns.title ){
                     return "title";
              }else if( tcn === cns.expander ){
                     return "expander";
              }else if( tcn === cns.checkbox ){
                     return "checkbox";
              }else if( tcn === cns.nodeIcon ){
                     return "icon";
              }else if( tcn === cns.empty || tcn === cns.vline || tcn === cns.connector ){
                     return "prefix";
              }else if( tcn.indexOf(cns.node) >= 0 ){
                     // FIX issue #93
                     return this._getTypeForOuterNodeEvent(event);
              }
              return null;
       },

       isVisible: function() {
              // Return true, if all parents are expanded.
              var parents = this._parentList(true, false);
              for(var i=0, l=parents.length; i<l; i++){
                     if( ! parents[i].bExpanded ){ return false; }
              }
              return true;
       },

       makeVisible: function() {
              // Make sure, all parents are expanded
              var parents = this._parentList(true, false);
              for(var i=0, l=parents.length; i<l; i++){
                     parents[i]._expand(true);
              }
       },

       focus: function() {
              // TODO: check, if we already have focus
//            this.tree.logDebug("dtnode.focus(): %o", this);
              this.makeVisible();
              try {
                     $(this.span).find(">a").focus();
              } catch(e) { }
       },

       isFocused: function() {
              return (this.tree.tnFocused === this);
       },

       _activate: function(flag, fireEvents) {
              // (De)Activate - but not focus - this node.
              this.tree.logDebug("dtnode._activate(%o, fireEvents=%o) - %o", flag, fireEvents, this);
              var opts = this.tree.options;
              if( this.data.isStatusNode ){
                     return;
              }
              if ( fireEvents && opts.onQueryActivate && opts.onQueryActivate.call(this.tree, flag, this) === false ){
                     return; // Callback returned false
              }
              if( flag ) {
                     // Activate
                     if( this.tree.activeNode ) {
                            if( this.tree.activeNode === this ){
                                   return;
                            }
                            this.tree.activeNode.deactivate();
                     }
                     if( opts.activeVisible ){
                            this.makeVisible();
                     }
                     this.tree.activeNode = this;
                     if( opts.persist ){
                            $.cookie(opts.cookieId+"-active", this.data.key, opts.cookie);
                     }
                     this.tree.persistence.activeKey = this.data.key;
                     $(this.span).addClass(opts.classNames.active);
                     if ( fireEvents && opts.onActivate ){
                            opts.onActivate.call(this.tree, this);
                     }
              } else {
                     // Deactivate
                     if( this.tree.activeNode === this ) {
                            if ( opts.onQueryActivate && opts.onQueryActivate.call(this.tree, false, this) === false ){
                                   return; // Callback returned false
                            }
                            $(this.span).removeClass(opts.classNames.active);
                            if( opts.persist ) {
                                   // Note: we don't pass null, but ''. So the cookie is not deleted.
                                   // If we pass null, we also have to pass a COPY of opts, because $cookie will override opts.expires (issue 84)
                                   $.cookie(opts.cookieId+"-active", "", opts.cookie);
                            }
                            this.tree.persistence.activeKey = null;
                            this.tree.activeNode = null;
                            if ( fireEvents && opts.onDeactivate ){
                                   opts.onDeactivate.call(this.tree, this);
                            }
                     }
              }
       },

       activate: function() {
              // Select - but not focus - this node.
//            this.tree.logDebug("dtnode.activate(): %o", this);
              this._activate(true, true);
       },

       activateSilently: function() {
              this._activate(true, false);
       },

       deactivate: function() {
//            this.tree.logDebug("dtnode.deactivate(): %o", this);
              this._activate(false, true);
       },

       isActive: function() {
              return (this.tree.activeNode === this);
       },

       _userActivate: function() {
              // Handle user click / [space] / [enter], according to clickFolderMode.
              var activate = true;
              var expand = false;
              if ( this.data.isFolder ) {
                     switch( this.tree.options.clickFolderMode ) {
                     case 2:
                            activate = false;
                            expand = true;
                            break;
                     case 3:
                            activate = expand = true;
                            break;
                     }
              }
              if( this.parent === null ) {
                     expand = false;
              }
              if( expand ) {
                     this.toggleExpand();
                     this.focus();
              }
              if( activate ) {
                     this.activate();
              }
       },

       _setSubSel: function(hasSubSel) {
              if( hasSubSel ) {
                     this.hasSubSel = true;
                     $(this.span).addClass(this.tree.options.classNames.partsel);
              } else {
                     this.hasSubSel = false;
                     $(this.span).removeClass(this.tree.options.classNames.partsel);
              }
       },
       /**
        * Fix selection and partsel status, of parent nodes, according to current status of
        * end nodes.
        */
       _updatePartSelectionState: function() {
//            alert("_updatePartSelectionState " + this);
//            this.tree.logDebug("_updatePartSelectionState() - %o", this);
              var sel;
              // Return `true` or `false` for end nodes and remove part-sel flag
              if( ! this.hasChildren() ){
                     sel = (this.bSelected && !this.data.unselectable && !this.data.isStatusNode);
                     this._setSubSel(false);
                     return sel;
              }
              // Return `true`, `false`, or `undefined` for parent nodes
              var i, l,
                     cl = this.childList,
                     allSelected = true,
                     allDeselected = true;
              for(i=0, l=cl.length; i<l;  i++) {
                     var n = cl[i],
                            s = n._updatePartSelectionState();
                     if( s !== false){
                            allDeselected = false;
                     }
                     if( s !== true){
                            allSelected = false;
                     }
              }
              if( allSelected ){
                     sel = true;
              } else if ( allDeselected ){
                     sel = false;
              } else {
                     sel = undefined;
              }
              this._setSubSel(sel === undefined);
              this.bSelected = (sel === true);
              return sel;
       },

       /**
        * Fix selection status, after this node was (de)selected in multi-hier mode.
        * This includes (de)selecting all children.
        */
       _fixSelectionState: function() {
//            alert("_fixSelectionState " + this);
//            this.tree.logDebug("_fixSelectionState(%s) - %o", this.bSelected, this);
              var p, i, l;
              if( this.bSelected ) {
                     // Select all children
                     this.visit(function(node){
                            node.parent._setSubSel(true);
                            if(!node.data.unselectable){
                                   node._select(true, false, false);
                            }
                     });
                     // Select parents, if all children are selected
                     p = this.parent;
                     while( p ) {
                            p._setSubSel(true);
                            var allChildsSelected = true;
                            for(i=0, l=p.childList.length; i<l;  i++) {
                                   var n = p.childList[i];
                                   if( !n.bSelected && !n.data.isStatusNode && !n.data.unselectable) {
                                   // issue 305 proposes this:
//                                 if( !n.bSelected && !n.data.isStatusNode ) {
                                          allChildsSelected = false;
                                          break;
                                   }
                            }
                            if( allChildsSelected ){
                                   p._select(true, false, false);
                            }
                            p = p.parent;
                     }
              } else {
                     // Deselect all children
                     this._setSubSel(false);
                     this.visit(function(node){
                            node._setSubSel(false);
                            node._select(false, false, false);
                     });
                     // Deselect parents, and recalc hasSubSel
                     p = this.parent;
                     while( p ) {
                            p._select(false, false, false);
                            var isPartSel = false;
                            for(i=0, l=p.childList.length; i<l;  i++) {
                                   if( p.childList[i].bSelected || p.childList[i].hasSubSel ) {
                                          isPartSel = true;
                                          break;
                                   }
                            }
                            p._setSubSel(isPartSel);
                            p = p.parent;
                     }
              }
       },

       _select: function(sel, fireEvents, deep) {
              // Select - but not focus - this node.
//            this.tree.logDebug("dtnode._select(%o) - %o", sel, this);
              var opts = this.tree.options;
              if( this.data.isStatusNode ){
                     return;
              }
              //
              if( this.bSelected === sel ) {
//                   this.tree.logDebug("dtnode._select(%o) IGNORED - %o", sel, this);
                     return;
              }
              // Allow event listener to abort selection
              if ( fireEvents && opts.onQuerySelect && opts.onQuerySelect.call(this.tree, sel, this) === false ){
                     return; // Callback returned false
              }
              // Force single-selection
              if( opts.selectMode==1 && sel ) {
                     this.tree.visit(function(node){
                            if( node.bSelected ) {
                                   // Deselect; assuming that in selectMode:1 there's max. one other selected node
                                   node._select(false, false, false);
                                   return false;
                            }
                     });
              }

              this.bSelected = sel;
//        this.tree._changeNodeList("select", this, sel);

              if( sel ) {
                     if( opts.persist ){
                            this.tree.persistence.addSelect(this.data.key);
                     }
                     $(this.span).addClass(opts.classNames.selected);

                     if( deep && opts.selectMode === 3 ){
                            this._fixSelectionState();
                     }
                     if ( fireEvents && opts.onSelect ){
                            opts.onSelect.call(this.tree, true, this);
                     }
              } else {
                     if( opts.persist ){
                            this.tree.persistence.clearSelect(this.data.key);
                     }
                     $(this.span).removeClass(opts.classNames.selected);

                     if( deep && opts.selectMode === 3 ){
                            this._fixSelectionState();
                     }
                     if ( fireEvents && opts.onSelect ){
                            opts.onSelect.call(this.tree, false, this);
                     }
              }
       },

       select: function(sel) {
              // Select - but not focus - this node.
//            this.tree.logDebug("dtnode.select(%o) - %o", sel, this);
              if( this.data.unselectable ){
                     return this.bSelected;
              }
              return this._select(sel!==false, true, true);
       },

       toggleSelect: function() {
//            this.tree.logDebug("dtnode.toggleSelect() - %o", this);
              return this.select(!this.bSelected);
       },

       isSelected: function() {
              return this.bSelected;
       },

       isLazy: function() {
              return !!this.data.isLazy;
       },

       _loadContent: function() {
              try {
                     var opts = this.tree.options;
                     this.tree.logDebug("_loadContent: start - %o", this);
                     this.setLazyNodeStatus(DTNodeStatus_Loading);
                     if( true === opts.onLazyRead.call(this.tree, this) ) {
                            // If function returns 'true', we assume that the loading is done:
                            this.setLazyNodeStatus(DTNodeStatus_Ok);
                            // Otherwise (i.e. if the loading was started as an asynchronous process)
                            // the onLazyRead(dtnode) handler is expected to call dtnode.setLazyNodeStatus(DTNodeStatus_Ok/_Error) when done.
                            this.tree.logDebug("_loadContent: succeeded - %o", this);
                     }
              } catch(e) {
                     this.tree.logWarning("_loadContent: failed - %o", e);
                     this.setLazyNodeStatus(DTNodeStatus_Error, {tooltip: ""+e});
              }
       },

       _expand: function(bExpand, forceSync) {
              if( this.bExpanded === bExpand ) {
                     this.tree.logDebug("dtnode._expand(%o) IGNORED - %o", bExpand, this);
                     return;
              }
              this.tree.logDebug("dtnode._expand(%o) - %o", bExpand, this);
              var opts = this.tree.options;
              if( !bExpand && this.getLevel() < opts.minExpandLevel ) {
                     this.tree.logDebug("dtnode._expand(%o) prevented collapse - %o", bExpand, this);
                     return;
              }
              if ( opts.onQueryExpand && opts.onQueryExpand.call(this.tree, bExpand, this) === false ){
                     return; // Callback returned false
              }
              this.bExpanded = bExpand;

              // Persist expand state
              if( opts.persist ) {
                     if( bExpand ){
                            this.tree.persistence.addExpand(this.data.key);
                     }else{
                            this.tree.persistence.clearExpand(this.data.key);
                     }
              }
              // Do not apply animations in init phase, or before lazy-loading
              var allowEffects = !(this.data.isLazy && this.childList === null)
                     && !this._isLoading
                     && !forceSync;
              this.render(allowEffects);

              // Auto-collapse mode: collapse all siblings
              if( this.bExpanded && this.parent && opts.autoCollapse ) {
                     var parents = this._parentList(false, true);
                     for(var i=0, l=parents.length; i<l; i++){
                            parents[i].collapseSiblings();
                     }
              }
              // If the currently active node is now hidden, deactivate it
              if( opts.activeVisible && this.tree.activeNode && ! this.tree.activeNode.isVisible() ) {
                     this.tree.activeNode.deactivate();
              }
              // Expanding a lazy node: set 'loading...' and call callback
              if( bExpand && this.data.isLazy && this.childList === null && !this._isLoading ) {
                     this._loadContent();
                     return;
              }
              if ( opts.onExpand ){
                     opts.onExpand.call(this.tree, bExpand, this);
              }
       },

       isExpanded: function() {
              return this.bExpanded;
       },

       expand: function(flag) {
              flag = (flag !== false);
              if( !this.childList && !this.data.isLazy && flag ){
                     return; // Prevent expanding empty nodes
              } else if( this.parent === null && !flag ){
                     return; // Prevent collapsing the root
              }
              this._expand(flag);
       },

       scheduleAction: function(mode, ms) {
              /** Schedule activity for delayed execution (cancel any pending request).
               *  scheduleAction('cancel') will cancel the request.
               */
              if( this.tree.timer ) {
                     clearTimeout(this.tree.timer);
                     this.tree.logDebug("clearTimeout(%o)", this.tree.timer);
              }
              var self = this; // required for closures
              switch (mode) {
              case "cancel":
                     // Simply made sure that timer was cleared
                     break;
              case "expand":
                     this.tree.timer = setTimeout(function(){
                            self.tree.logDebug("setTimeout: trigger expand");
                            self.expand(true);
                     }, ms);
                     break;
              case "activate":
                     this.tree.timer = setTimeout(function(){
                            self.tree.logDebug("setTimeout: trigger activate");
                            self.activate();
                     }, ms);
                     break;
              default:
                     throw "Invalid mode " + mode;
              }
              this.tree.logDebug("setTimeout(%s, %s): %s", mode, ms, this.tree.timer);
       },

       toggleExpand: function() {
              this.expand(!this.bExpanded);
       },

       collapseSiblings: function() {
              if( this.parent === null ){
                     return;
              }
              var ac = this.parent.childList;
              for (var i=0, l=ac.length; i<l; i++) {
                     if ( ac[i] !== this && ac[i].bExpanded ){
                            ac[i]._expand(false);
                     }
              }
       },

       _onClick: function(event) {
//            this.tree.logDebug("dtnode.onClick(" + event.type + "): dtnode:" + this + ", button:" + event.button + ", which: " + event.which);
              var targetType = this.getEventTargetType(event);
              if( targetType === "expander" ) {
                     // Clicking the expander icon always expands/collapses
                     this.toggleExpand();
                     this.focus(); // issue 95
              } else if( targetType === "checkbox" ) {
                     // Clicking the checkbox always (de)selects
                     this.toggleSelect();
                     this.focus(); // issue 95
              } else {
                     this._userActivate();
                     var aTag = this.span.getElementsByTagName("a");
                     if(aTag[0]){
                            // issue 154, 313
                            if(!($.browser.msie && parseInt($.browser.version, 10) < 9)){
                                   aTag[0].focus();
                            }
                     }else{
                            // 'noLink' option was set
                            return true;
                     }
              }
              // Make sure that clicks stop, otherwise <a href='#'> jumps to the top
              event.preventDefault();
       },

       _onDblClick: function(event) {
//            this.tree.logDebug("dtnode.onDblClick(" + event.type + "): dtnode:" + this + ", button:" + event.button + ", which: " + event.which);
       },

       _onKeydown: function(event) {
//            this.tree.logDebug("dtnode.onKeydown(" + event.type + "): dtnode:" + this + ", charCode:" + event.charCode + ", keyCode: " + event.keyCode + ", which: " + event.which);
              var handled = true,
                     sib;
//            alert("keyDown" + event.which);

              switch( event.which ) {
                     // charCodes:
//                   case 43: // '+'
                     case 107: // '+'
                     case 187: // '+' @ Chrome, Safari
                            if( !this.bExpanded ){ this.toggleExpand(); }
                            break;
//                   case 45: // '-'
                     case 109: // '-'
                     case 189: // '+' @ Chrome, Safari
                            if( this.bExpanded ){ this.toggleExpand(); }
                            break;
                     //~ case 42: // '*'
                            //~ break;
                     //~ case 47: // '/'
                            //~ break;
                     // case 13: // <enter>
                            // <enter> on a focused <a> tag seems to generate a click-event.
                            // this._userActivate();
                            // break;
                     case 32: // <space>
                            this._userActivate();
                            break;
                     case 8: // <backspace>
                            if( this.parent ){
                                   this.parent.focus();
                            }
                            break;
                     case 37: // <left>
                            if( this.bExpanded ) {
                                   this.toggleExpand();
                                   this.focus();
//                          } else if( this.parent && (this.tree.options.rootVisible || this.parent.parent) ) {
                            } else if( this.parent && this.parent.parent ) {
                                   this.parent.focus();
                            }
                            break;
                     case 39: // <right>
                            if( !this.bExpanded && (this.childList || this.data.isLazy) ) {
                                   this.toggleExpand();
                                   this.focus();
                            } else if( this.childList ) {
                                   this.childList[0].focus();
                            }
                            break;
                     case 38: // <up>
                            sib = this.getPrevSibling();
                            while( sib && sib.bExpanded && sib.childList ){
                                   sib = sib.childList[sib.childList.length-1];
                            }
//                          if( !sib && this.parent && (this.tree.options.rootVisible || this.parent.parent) )
                            if( !sib && this.parent && this.parent.parent ){
                                   sib = this.parent;
                            }
                            if( sib ){
                                   sib.focus();
                            }
                            break;
                     case 40: // <down>
                            if( this.bExpanded && this.childList ) {
                                   sib = this.childList[0];
                            } else {
                                   var parents = this._parentList(false, true);
                                   for(var i=parents.length-1; i>=0; i--) {
                                          sib = parents[i].getNextSibling();
                                          if( sib ){ break; }
                                   }
                            }
                            if( sib ){
                                   sib.focus();
                            }
                            break;
                     default:
                            handled = false;
              }
              // Return false, if handled, to prevent default processing
//            return !handled;
              if(handled){
                     event.preventDefault();
              }
       },

       _onKeypress: function(event) {
              // onKeypress is only hooked to allow user callbacks.
              // We don't process it, because IE and Safari don't fire keypress for cursor keys.
//            this.tree.logDebug("dtnode.onKeypress(" + event.type + "): dtnode:" + this + ", charCode:" + event.charCode + ", keyCode: " + event.keyCode + ", which: " + event.which);
       },

       _onFocus: function(event) {
              // Handles blur and focus events.
//            this.tree.logDebug("dtnode._onFocus(%o): %o", event, this);
              var opts = this.tree.options;
              if ( event.type == "blur" || event.type == "focusout" ) {
                     if ( opts.onBlur ){
                            opts.onBlur.call(this.tree, this);
                     }
                     if( this.tree.tnFocused ){
                            $(this.tree.tnFocused.span).removeClass(opts.classNames.focused);
                     }
                     this.tree.tnFocused = null;
                     if( opts.persist ){
                            $.cookie(opts.cookieId+"-focus", "", opts.cookie);
                     }
              } else if ( event.type=="focus" || event.type=="focusin") {
                     // Fix: sometimes the blur event is not generated
                     if( this.tree.tnFocused && this.tree.tnFocused !== this ) {
                            this.tree.logDebug("dtnode.onFocus: out of sync: curFocus: %o", this.tree.tnFocused);
                            $(this.tree.tnFocused.span).removeClass(opts.classNames.focused);
                     }
                     this.tree.tnFocused = this;
                     if ( opts.onFocus ){
                            opts.onFocus.call(this.tree, this);
                     }
                     $(this.tree.tnFocused.span).addClass(opts.classNames.focused);
                     if( opts.persist ){
                            $.cookie(opts.cookieId+"-focus", this.data.key, opts.cookie);
                     }
              }
              // TODO: return anything?
//            return false;
       },

       visit: function(fn, includeSelf) {
              // Call fn(node) for all child nodes. Stop iteration, if fn() returns false.
              var res = true;
              if( includeSelf === true ) {
                     res = fn(this);
                     if( res === false || res == "skip" ){
                            return res;
                     }
              }
              if(this.childList){
                     for(var i=0, l=this.childList.length; i<l; i++){
                            res = this.childList[i].visit(fn, true);
                            if( res === false ){
                                   break;
                            }
                     }
              }
              return res;
       },

       visitParents: function(fn, includeSelf) {
              // Visit parent nodes (bottom up)
              if(includeSelf && fn(this) === false){
                     return false;
              }
              var p = this.parent;
              while( p ) {
                     if(fn(p) === false){
                            return false;
                     }
                     p = p.parent;
              }
              return true;
       },

       remove: function() {
              // Remove this node
//            this.tree.logDebug ("%s.remove()", this);
              if ( this === this.tree.root ){
                     throw "Cannot remove system root";
              }
              return this.parent.removeChild(this);
       },

       removeChild: function(tn) {
              // Remove tn from list of direct children.
              var ac = this.childList;
              if( ac.length == 1 ) {
                     if( tn !== ac[0] ){
                            throw "removeChild: invalid child";
                     }
                     return this.removeChildren();
              }
              if( tn === this.tree.activeNode ){
                     tn.deactivate();
              }
              if( this.tree.options.persist ) {
                     if( tn.bSelected ){
                            this.tree.persistence.clearSelect(tn.data.key);
                     }
                     if ( tn.bExpanded ){
                            this.tree.persistence.clearExpand(tn.data.key);
                     }
              }
              tn.removeChildren(true);
//            this.div.removeChild(tn.div);
              this.ul.removeChild(tn.li);
              for(var i=0, l=ac.length; i<l; i++) {
                     if( ac[i] === tn ) {
                            this.childList.splice(i, 1);
//                          delete tn;  // JSLint complained
                            break;
                     }
              }
       },

       removeChildren: function(isRecursiveCall, retainPersistence) {
              // Remove all child nodes (more efficiently than recursive remove())
              this.tree.logDebug("%s.removeChildren(%o)", this, isRecursiveCall);
              var tree = this.tree;
              var ac = this.childList;
              if( ac ) {
                     for(var i=0, l=ac.length; i<l; i++) {
                            var tn = ac[i];
                            if ( tn === tree.activeNode && !retainPersistence ){
                                   tn.deactivate();
                            }
                            if( this.tree.options.persist && !retainPersistence ) {
                                   if( tn.bSelected ){
                                          this.tree.persistence.clearSelect(tn.data.key);
                                   }
                                   if ( tn.bExpanded ){
                                          this.tree.persistence.clearExpand(tn.data.key);
                                   }
                            }
                            tn.removeChildren(true, retainPersistence);
                            if(this.ul){
//                                 this.ul.removeChild(tn.li);
                                   $("li", $(this.ul)).remove(); // issue 231
                            }
//                          delete tn;  JSLint complained
                     }
                     // Set to 'null' which is interpreted as 'not yet loaded' for lazy
                     // nodes
                     this.childList = null;
              }
              if( ! isRecursiveCall ) {
//                   this._expand(false);
//                   this.isRead = false;
                     this._isLoading = false;
                     this.render();
              }
       },

       setTitle: function(title) {
              this.fromDict({title: title});
       },

       reload: function(force) {
              throw "Use reloadChildren() instead";
       },

       reloadChildren: function(callback) {
              // Reload lazy content (expansion state is maintained).
              if( this.parent === null ){
                     throw "Use tree.reload() instead";
              }else if( ! this.data.isLazy ){
                     throw "node.reloadChildren() requires lazy nodes.";
              }
              // appendAjax triggers 'nodeLoaded' event.
              // We listen to this, if a callback was passed to reloadChildren
              if(callback){
                     var self = this;
                     var eventType = "nodeLoaded.dynatree." + this.tree.$tree.attr("id")
                            + "." + this.data.key;
                     this.tree.$tree.bind(eventType, function(e, node, isOk){
                            self.tree.$tree.unbind(eventType);
                            self.tree.logDebug("loaded %o, %o, %o", e, node, isOk);
                            if(node !== self){
                                   throw "got invalid load event";
                            }
                            callback.call(self.tree, node, isOk);
                     });
              }
              // The expansion state is maintained
              this.removeChildren();
              this._loadContent();
//            if( this.bExpanded ) {
//                   // Remove children first, to prevent effects being applied
//                   this.removeChildren();
//                   // then force re-expand to trigger lazy loading
////                 this.expand(false);
////                 this.expand(true);
//                   this._loadContent();
//            } else {
//                   this.removeChildren();
//                   this._loadContent();
//            }
       },

       /**
        * Make sure the node with a given key path is available in the tree.
        */
       _loadKeyPath: function(keyPath, callback) {
              var tree = this.tree;
              tree.logDebug("%s._loadKeyPath(%s)", this, keyPath);
              if(keyPath === ""){
                     throw "Key path must not be empty";
              }
              var segList = keyPath.split(tree.options.keyPathSeparator);
              if(segList[0] === ""){
                     throw "Key path must be relative (don't start with '/')";
              }
              var seg = segList.shift();
              if(this.childList){
                     for(var i=0, l=this.childList.length; i < l; i++){
                            var child = this.childList[i];
                            if( child.data.key === seg ){
                                   if(segList.length === 0) {
                                          // Found the end node
                                          callback.call(tree, child, "ok");

                                   }else if(child.data.isLazy && (child.childList === null || child.childList === undefined)){
                                          tree.logDebug("%s._loadKeyPath(%s) -> reloading %s...", this, keyPath, child);
                                          var self = this;
                                          // Note: this line gives a JSLint warning (Don't make functions within a loop)
                                          /*jshint loopfunc:true */
                                          child.reloadChildren(function(node, isOk){
                                                 // After loading, look for direct child with that key
                                                 if(isOk){
                                                        tree.logDebug("%s._loadKeyPath(%s) -> reloaded %s.", node, keyPath, node);
                                                        callback.call(tree, child, "loaded");
                                                        node._loadKeyPath(segList.join(tree.options.keyPathSeparator), callback);
                                                 }else{
                                                        tree.logWarning("%s._loadKeyPath(%s) -> reloadChildren() failed.", self, keyPath);
                                                        callback.call(tree, child, "error");
                                                 }
                                          });
                                          // we can ignore it, since it will only be exectuted once, the the loop is ended
                                          // See also http://stackoverflow.com/questions/3037598/how-to-get-around-the-jslint-error-dont-make-functions-within-a-loop
                                   } else {
                                          callback.call(tree, child, "loaded");
                                          // Look for direct child with that key
                                          child._loadKeyPath(segList.join(tree.options.keyPathSeparator), callback);
                                   }
                                   return;
                            }
                     }
              }
              // Could not find key
              // Callback params: child: undefined, the segment, isEndNode (segList.length === 0)
              callback.call(tree, undefined, "notfound", seg, segList.length === 0);
              tree.logWarning("Node not found: " + seg);
              return;
       },

       resetLazy: function() {
              // Discard lazy content.
              if( this.parent === null ){
                     throw "Use tree.reload() instead";
              }else if( ! this.data.isLazy ){
                     throw "node.resetLazy() requires lazy nodes.";
              }
              this.expand(false);
              this.removeChildren();
       },

       _addChildNode: function(dtnode, beforeNode) {
              /**
               * Internal function to add one single DynatreeNode as a child.
               *
               */
              var tree = this.tree,
                     opts = tree.options,
                     pers = tree.persistence;

//            tree.logDebug("%s._addChildNode(%o)", this, dtnode);

              // --- Update and fix dtnode attributes if necessary
              dtnode.parent = this;
//            if( beforeNode && (beforeNode.parent !== this || beforeNode === dtnode ) )
//                   throw "<beforeNode> must be another child of <this>";

              // --- Add dtnode as a child
              if ( this.childList === null ) {
                     this.childList = [];
              } else if( ! beforeNode ) {
                     // Fix 'lastsib'
                     if(this.childList.length > 0) {
                            $(this.childList[this.childList.length-1].span).removeClass(opts.classNames.lastsib);
                     }
              }
              if( beforeNode ) {
                     var iBefore = $.inArray(beforeNode, this.childList);
                     if( iBefore < 0 ){
                            throw "<beforeNode> must be a child of <this>";
                     }
                     this.childList.splice(iBefore, 0, dtnode);
              } else {
                     // Append node
                     this.childList.push(dtnode);
              }

              // --- Handle persistence
              // Initial status is read from cookies, if persistence is active and
              // cookies are already present.
              // Otherwise the status is read from the data attributes and then persisted.
              var isInitializing = tree.isInitializing();
              if( opts.persist && pers.cookiesFound && isInitializing ) {
                     // Init status from cookies
//                   tree.logDebug("init from cookie, pa=%o, dk=%o", pers.activeKey, dtnode.data.key);
                     if( pers.activeKey === dtnode.data.key ){
                            tree.activeNode = dtnode;
                     }
                     if( pers.focusedKey === dtnode.data.key ){
                            tree.focusNode = dtnode;
                     }
                     dtnode.bExpanded = ($.inArray(dtnode.data.key, pers.expandedKeyList) >= 0);
                     dtnode.bSelected = ($.inArray(dtnode.data.key, pers.selectedKeyList) >= 0);
//                   tree.logDebug("    key=%o, bSelected=%o", dtnode.data.key, dtnode.bSelected);
              } else {
                     // Init status from data (Note: we write the cookies after the init phase)
//                   tree.logDebug("init from data");
                     if( dtnode.data.activate ) {
                            tree.activeNode = dtnode;
                            if( opts.persist ){
                                   pers.activeKey = dtnode.data.key;
                            }
                     }
                     if( dtnode.data.focus ) {
                            tree.focusNode = dtnode;
                            if( opts.persist ){
                                   pers.focusedKey = dtnode.data.key;
                            }
                     }
                     dtnode.bExpanded = ( dtnode.data.expand === true ); // Collapsed by default
                     if( dtnode.bExpanded && opts.persist ){
                            pers.addExpand(dtnode.data.key);
                     }
                     dtnode.bSelected = ( dtnode.data.select === true ); // Deselected by default
/*
                     Doesn't work, cause pers.selectedKeyList may be null
                     if( dtnode.bSelected && opts.selectMode==1
                            && pers.selectedKeyList && pers.selectedKeyList.length>0 ) {
                            tree.logWarning("Ignored multi-selection in single-mode for %o", dtnode);
                            dtnode.bSelected = false; // Fixing bad input data (multi selection for mode:1)
                     }
*/
                     if( dtnode.bSelected && opts.persist ){
                            pers.addSelect(dtnode.data.key);
                     }
              }

              // Always expand, if it's below minExpandLevel
//            tree.logDebug ("%s._addChildNode(%o), l=%o", this, dtnode, dtnode.getLevel());
              if ( opts.minExpandLevel >= dtnode.getLevel() ) {
//                   tree.logDebug ("Force expand for %o", dtnode);
                     this.bExpanded = true;
              }

              // In multi-hier mode, update the parents selection state
              // issue #82: only if not initializing, because the children may not exist yet
//            if( !dtnode.data.isStatusNode && opts.selectMode==3 && !isInitializing )
//                   dtnode._fixSelectionState();

              // In multi-hier mode, update the parents selection state
              if( dtnode.bSelected && opts.selectMode==3 ) {
                     var p = this;
                     while( p ) {
                            if( !p.hasSubSel ){
                                   p._setSubSel(true);
                            }
                            p = p.parent;
                     }
              }
              // render this node and the new child
              if ( tree.bEnableUpdate ){
                     this.render();
              }
              return dtnode;
       },

       addChild: function(obj, beforeNode) {
              /**
               * Add a node object as child.
               *
               * This should be the only place, where a DynaTreeNode is constructed!
               * (Except for the root node creation in the tree constructor)
               *
               * @param obj A JS object (may be recursive) or an array of those.
               * @param {DynaTreeNode} beforeNode (optional) sibling node.
               *
               * Data format: array of node objects, with optional 'children' attributes.
               * [
               *     { title: "t1", isFolder: true, ... }
               *     { title: "t2", isFolder: true, ...,
               *            children: [
               *                   {title: "t2.1", ..},
               *                   {..}
               *                   ]
               *     }
               * ]
               * A simple object is also accepted instead of an array.
               *
               */
//            this.tree.logDebug("%s.addChild(%o, %o)", this, obj, beforeNode);
              if(typeof(obj) == "string"){
                     throw "Invalid data type for " + obj;
              }else if( !obj || obj.length === 0 ){ // Passed null or undefined or empty array
                     return;
              }else if( obj instanceof DynaTreeNode ){
                     return this._addChildNode(obj, beforeNode);
              }

              if( !obj.length ){ // Passed a single data object
                     obj = [ obj ];
              }
              var prevFlag = this.tree.enableUpdate(false);

              var tnFirst = null;
              for (var i=0, l=obj.length; i<l; i++) {
                     var data = obj[i];
                     var dtnode = this._addChildNode(new DynaTreeNode(this, this.tree, data), beforeNode);
                     if( !tnFirst ){
                            tnFirst = dtnode;
                     }
                     // Add child nodes recursively
                     if( data.children ){
                            dtnode.addChild(data.children, null);
                     }
              }
              this.tree.enableUpdate(prevFlag);
              return tnFirst;
       },

       append: function(obj) {
              this.tree.logWarning("node.append() is deprecated (use node.addChild() instead).");
              return this.addChild(obj, null);
       },

       appendAjax: function(ajaxOptions) {
              var self = this;
              this.removeChildren(false, true);
              this.setLazyNodeStatus(DTNodeStatus_Loading);
              // Debug feature: force a delay, to simulate slow loading...
              if(ajaxOptions.debugLazyDelay){
                     var ms = ajaxOptions.debugLazyDelay;
                     ajaxOptions.debugLazyDelay = 0;
                     this.tree.logInfo("appendAjax: waiting for debugLazyDelay " + ms);
                     setTimeout(function(){self.appendAjax(ajaxOptions);}, ms);
                     return;
              }
              // Ajax option inheritance: $.ajaxSetup < $.ui.dynatree.prototype.options.ajaxDefaults < tree.options.ajaxDefaults < ajaxOptions
              var orgSuccess = ajaxOptions.success,
                     orgError = ajaxOptions.error,
                     eventType = "nodeLoaded.dynatree." + this.tree.$tree.attr("id") + "." + this.data.key;
              var options = $.extend({}, this.tree.options.ajaxDefaults, ajaxOptions, {
                     success: function(data, textStatus, jqXHR){
                            // <this> is the request options
//                          self.tree.logDebug("appendAjax().success");
                            var prevPhase = self.tree.phase;
                            self.tree.phase = "init";
                            // postProcess is similar to the standard dataFilter hook,
                            // but it is also called for JSONP
                            if( options.postProcess ){
                                   data = options.postProcess.call(this, data, this.dataType);
                            }
                            // Process ASPX WebMethod JSON object inside "d" property
                            // http://code.google.com/p/dynatree/issues/detail?id=202
                            else if (data && data.hasOwnProperty("d")) {
                               data = (typeof data.d) == "string" ? $.parseJSON(data.d) : data.d;
                            }
                            if(!$.isArray(data) || data.length !== 0){
                                   self.addChild(data, null);
                            }
                            self.tree.phase = "postInit";
                            if( orgSuccess ){
                                   orgSuccess.call(options, self, data, textStatus);
                            }
                            self.tree.logDebug("trigger " + eventType);
                            self.tree.$tree.trigger(eventType, [self, true]);
                            self.tree.phase = prevPhase;
                            // This should be the last command, so node._isLoading is true
                            // while the callbacks run
                            self.setLazyNodeStatus(DTNodeStatus_Ok);
                            if($.isArray(data) && data.length === 0){
                                   // Set to [] which is interpreted as 'no children' for lazy
                                   // nodes
                                   self.childList = [];
                                   self.render();
                            }
                            },
                     error: function(jqXHR, textStatus, errorThrown){
                            // <this> is the request options
                            self.tree.logWarning("appendAjax failed:", textStatus, ":\n", jqXHR, "\n", errorThrown);
                            if( orgError ){
                                   orgError.call(options, self, jqXHR, textStatus, errorThrown);
                            }
                            self.tree.$tree.trigger(eventType, [self, false]);
                            self.setLazyNodeStatus(DTNodeStatus_Error, {info: textStatus, tooltip: "" + errorThrown});
                            }
              });
              $.ajax(options);
       },

       move: function(targetNode, mode) {
              /**Move this node to targetNode.
               *  mode 'child': append this node as last child of targetNode.
               *                This is the default. To be compatble with the D'n'd
               *                hitMode, we also accept 'over'.
               *  mode 'before': add this node as sibling before targetNode.
               *  mode 'after': add this node as sibling after targetNode.
               */
              var pos;
              if(this === targetNode){
                     return;
              }
              if( !this.parent  ){
                     throw "Cannot move system root";
              }
              if(mode === undefined || mode == "over"){
                     mode = "child";
              }
              var prevParent = this.parent;
              var targetParent = (mode === "child") ? targetNode : targetNode.parent;
              if( targetParent.isDescendantOf(this) ){
                     throw "Cannot move a node to it's own descendant";
              }
              // Unlink this node from current parent
              if( this.parent.childList.length == 1 ) {
                     this.parent.childList = this.parent.data.isLazy ? [] : null;
                     this.parent.bExpanded = false;
              } else {
                     pos = $.inArray(this, this.parent.childList);
                     if( pos < 0 ){
                            throw "Internal error";
                     }
                     this.parent.childList.splice(pos, 1);
              }
              // Remove from source DOM parent
              if(this.parent.ul){
                     this.parent.ul.removeChild(this.li);
              }

              // Insert this node to target parent's child list
              this.parent = targetParent;
              if( targetParent.hasChildren() ) {
                     switch(mode) {
                     case "child":
                            // Append to existing target children
                            targetParent.childList.push(this);
                            break;
                     case "before":
                            // Insert this node before target node
                            pos = $.inArray(targetNode, targetParent.childList);
                            if( pos < 0 ){
                                   throw "Internal error";
                            }
                            targetParent.childList.splice(pos, 0, this);
                            break;
                     case "after":
                            // Insert this node after target node
                            pos = $.inArray(targetNode, targetParent.childList);
                            if( pos < 0 ){
                                   throw "Internal error";
                            }
                            targetParent.childList.splice(pos+1, 0, this);
                            break;
                     default:
                            throw "Invalid mode " + mode;
                     }
              } else {
                     targetParent.childList = [ this ];
              }
              // Parent has no <ul> tag yet:
              if( !targetParent.ul ) {
                     // This is the parent's first child: create UL tag
                     // (Hidden, because it will be
                     targetParent.ul = document.createElement("ul");
                     targetParent.ul.style.display = "none";
                     targetParent.li.appendChild(targetParent.ul);
              }
              // Issue 319: Add to target DOM parent (only if node was already rendered(expanded))
              if(this.li){
                     targetParent.ul.appendChild(this.li);
              }

              if( this.tree !== targetNode.tree ) {
                     // Fix node.tree for all source nodes
                     this.visit(function(node){
                            node.tree = targetNode.tree;
                     }, null, true);
                     throw "Not yet implemented.";
              }
              // TODO: fix selection state
              // TODO: fix active state
              if( !prevParent.isDescendantOf(targetParent)) {
                     prevParent.render();
              }
              if( !targetParent.isDescendantOf(prevParent) ) {
                     targetParent.render();
              }
//            this.tree.redraw();
/*
              var tree = this.tree;
              var opts = tree.options;
              var pers = tree.persistence;


              // Always expand, if it's below minExpandLevel
//            tree.logDebug ("%s._addChildNode(%o), l=%o", this, dtnode, dtnode.getLevel());
              if ( opts.minExpandLevel >= dtnode.getLevel() ) {
//                   tree.logDebug ("Force expand for %o", dtnode);
                     this.bExpanded = true;
              }

              // In multi-hier mode, update the parents selection state
              // issue #82: only if not initializing, because the children may not exist yet
//            if( !dtnode.data.isStatusNode && opts.selectMode==3 && !isInitializing )
//                   dtnode._fixSelectionState();

              // In multi-hier mode, update the parents selection state
              if( dtnode.bSelected && opts.selectMode==3 ) {
                     var p = this;
                     while( p ) {
                            if( !p.hasSubSel )
                                   p._setSubSel(true);
                            p = p.parent;
                     }
              }
              // render this node and the new child
              if ( tree.bEnableUpdate )
                     this.render();

              return dtnode;

*/
       },

       // --- end of class
       lastentry: undefined
};

/*************************************************************************
 * class DynaTreeStatus
 */

var DynaTreeStatus = Class.create();


DynaTreeStatus._getTreePersistData = function(cookieId, cookieOpts) {
       // Static member: Return persistence information from cookies
       var ts = new DynaTreeStatus(cookieId, cookieOpts);
       ts.read();
       return ts.toDict();
};
// Make available in global scope
getDynaTreePersistData = DynaTreeStatus._getTreePersistData; // TODO: deprecated


DynaTreeStatus.prototype = {
       // Constructor
       initialize: function(cookieId, cookieOpts) {
//            this._log("DynaTreeStatus: initialize");
              if( cookieId === undefined ){
                     cookieId = $.ui.dynatree.prototype.options.cookieId;
              }
              cookieOpts = $.extend({}, $.ui.dynatree.prototype.options.cookie, cookieOpts);

              this.cookieId = cookieId;
              this.cookieOpts = cookieOpts;
              this.cookiesFound = undefined;
              this.activeKey = null;
              this.focusedKey = null;
              this.expandedKeyList = null;
              this.selectedKeyList = null;
       },
       // member functions
       _log: function(msg) {
              //     this.logDebug("_changeNodeList(%o): nodeList:%o, idx:%o", mode, nodeList, idx);
              Array.prototype.unshift.apply(arguments, ["debug"]);
              _log.apply(this, arguments);
       },
       read: function() {
//            this._log("DynaTreeStatus: read");
              // Read or init cookies.
              this.cookiesFound = false;

              var cookie = $.cookie(this.cookieId + "-active");
              this.activeKey = ( cookie === null ) ? "" : cookie;
              if( cookie !== null ){
                     this.cookiesFound = true;
              }
              cookie = $.cookie(this.cookieId + "-focus");
              this.focusedKey = ( cookie === null ) ? "" : cookie;
              if( cookie !== null ){
                     this.cookiesFound = true;
              }
              cookie = $.cookie(this.cookieId + "-expand");
              this.expandedKeyList = ( cookie === null ) ? [] : cookie.split(",");
              if( cookie !== null ){
                     this.cookiesFound = true;
              }
              cookie = $.cookie(this.cookieId + "-select");
              this.selectedKeyList = ( cookie === null ) ? [] : cookie.split(",");
              if( cookie !== null ){
                     this.cookiesFound = true;
              }
       },
       write: function() {
//            this._log("DynaTreeStatus: write");
              $.cookie(this.cookieId + "-active", ( this.activeKey === null ) ? "" : this.activeKey, this.cookieOpts);
              $.cookie(this.cookieId + "-focus", ( this.focusedKey === null ) ? "" : this.focusedKey, this.cookieOpts);
              $.cookie(this.cookieId + "-expand", ( this.expandedKeyList === null ) ? "" : this.expandedKeyList.join(","), this.cookieOpts);
              $.cookie(this.cookieId + "-select", ( this.selectedKeyList === null ) ? "" : this.selectedKeyList.join(","), this.cookieOpts);
       },
       addExpand: function(key) {
//            this._log("addExpand(%o)", key);
              if( $.inArray(key, this.expandedKeyList) < 0 ) {
                     this.expandedKeyList.push(key);
                     $.cookie(this.cookieId + "-expand", this.expandedKeyList.join(","), this.cookieOpts);
              }
       },
       clearExpand: function(key) {
//            this._log("clearExpand(%o)", key);
              var idx = $.inArray(key, this.expandedKeyList);
              if( idx >= 0 ) {
                     this.expandedKeyList.splice(idx, 1);
                     $.cookie(this.cookieId + "-expand", this.expandedKeyList.join(","), this.cookieOpts);
              }
       },
       addSelect: function(key) {
//            this._log("addSelect(%o)", key);
              if( $.inArray(key, this.selectedKeyList) < 0 ) {
                     this.selectedKeyList.push(key);
                     $.cookie(this.cookieId + "-select", this.selectedKeyList.join(","), this.cookieOpts);
              }
       },
       clearSelect: function(key) {
//            this._log("clearSelect(%o)", key);
              var idx = $.inArray(key, this.selectedKeyList);
              if( idx >= 0 ) {
                     this.selectedKeyList.splice(idx, 1);
                     $.cookie(this.cookieId + "-select", this.selectedKeyList.join(","), this.cookieOpts);
              }
       },
       isReloading: function() {
              return this.cookiesFound === true;
       },
       toDict: function() {
              return {
                     cookiesFound: this.cookiesFound,
                     activeKey: this.activeKey,
                     focusedKey: this.activeKey,
                     expandedKeyList: this.expandedKeyList,
                     selectedKeyList: this.selectedKeyList
              };
       },
       // --- end of class
       lastentry: undefined
};


/*************************************************************************
 * class DynaTree
 */

var DynaTree = Class.create();

// --- Static members ----------------------------------------------------------

DynaTree.version = "$Version: 1.2.1$";

/*
DynaTree._initTree = function() {
};

DynaTree._bind = function() {
};
*/
//--- Class members ------------------------------------------------------------

DynaTree.prototype = {
       // Constructor
//     initialize: function(divContainer, options) {
       initialize: function($widget) {
              // instance members
              this.phase = "init";
              this.$widget = $widget;
              this.options = $widget.options;
              this.$tree = $widget.element;
              this.timer = null;
              // find container element
              this.divTree = this.$tree.get(0);

//            var parentPos = $(this.divTree).parent().offset();
//            this.parentTop = parentPos.top;
//            this.parentLeft = parentPos.left;

              _initDragAndDrop(this);
       },

       // member functions

       _load: function(callback) {
              var $widget = this.$widget;
              var opts = this.options,
                     self = this;
              this.bEnableUpdate = true;
              this._nodeCount = 1;
              this.activeNode = null;
              this.focusNode = null;

              // Some deprecation warnings to help with migration
              if( opts.rootVisible !== undefined ){
                     this.logWarning("Option 'rootVisible' is no longer supported.");
              }
              if( opts.minExpandLevel < 1 ) {
                     this.logWarning("Option 'minExpandLevel' must be >= 1.");
                     opts.minExpandLevel = 1;
              }
//            _log("warn", "jQuery.support.boxModel " + jQuery.support.boxModel);

              // If a 'options.classNames' dictionary was passed, still use defaults
              // for undefined classes:
              if( opts.classNames !== $.ui.dynatree.prototype.options.classNames ) {
                     opts.classNames = $.extend({}, $.ui.dynatree.prototype.options.classNames, opts.classNames);
              }
              if( opts.ajaxDefaults !== $.ui.dynatree.prototype.options.ajaxDefaults ) {
                     opts.ajaxDefaults = $.extend({}, $.ui.dynatree.prototype.options.ajaxDefaults, opts.ajaxDefaults);
              }
              if( opts.dnd !== $.ui.dynatree.prototype.options.dnd ) {
                     opts.dnd = $.extend({}, $.ui.dynatree.prototype.options.dnd, opts.dnd);
              }
              // Guess skin path, if not specified
              if(!opts.imagePath) {
                     $("script").each( function () {
                            var _rexDtLibName = /.*dynatree[^\/]*\.js$/i;
                            if( this.src.search(_rexDtLibName) >= 0 ) {
                                   if( this.src.indexOf("/")>=0 ){ // issue #47
                                          opts.imagePath = this.src.slice(0, this.src.lastIndexOf("/")) + "/skin/";
                                   }else{
                                          opts.imagePath = "skin/";
                                   }
                                   self.logDebug("Guessing imagePath from '%s': '%s'", this.src, opts.imagePath);
                                   return false; // first match
                            }
                     });
              }

              this.persistence = new DynaTreeStatus(opts.cookieId, opts.cookie);
              if( opts.persist ) {
                     if( !$.cookie ){
                            _log("warn", "Please include jquery.cookie.js to use persistence.");
                     }
                     this.persistence.read();
              }
              this.logDebug("DynaTree.persistence: %o", this.persistence.toDict());

              // Cached tag strings
              this.cache = {
                     tagEmpty: "<span class='" + opts.classNames.empty + "'></span>",
                     tagVline: "<span class='" + opts.classNames.vline + "'></span>",
                     tagExpander: "<span class='" + opts.classNames.expander + "'></span>",
                     tagConnector: "<span class='" + opts.classNames.connector + "'></span>",
                     tagNodeIcon: "<span class='" + opts.classNames.nodeIcon + "'></span>",
                     tagCheckbox: "<span class='" + opts.classNames.checkbox + "'></span>",
                     lastentry: undefined
              };

              // Clear container, in case it contained some 'waiting' or 'error' text
              // for clients that don't support JS.
              // We don't do this however, if we try to load from an embedded UL element.
              if( opts.children || (opts.initAjax && opts.initAjax.url) || opts.initId ){
                     $(this.divTree).empty();
              }
              var $ulInitialize = this.$tree.find(">ul:first").hide();

              // Create the root element
              this.tnRoot = new DynaTreeNode(null, this, {});
              this.tnRoot.bExpanded = true;
              this.tnRoot.render();
              this.divTree.appendChild(this.tnRoot.ul);

              var root = this.tnRoot,
                     isReloading = ( opts.persist && this.persistence.isReloading() ),
                     isLazy = false,
                     prevFlag = this.enableUpdate(false);

              this.logDebug("Dynatree._load(): read tree structure...");

              // Init tree structure
              if( opts.children ) {
                     // Read structure from node array
                     root.addChild(opts.children);

              } else if( opts.initAjax && opts.initAjax.url ) {
                     // Init tree from AJAX request
                     isLazy = true;
                     root.data.isLazy = true;
                     this._reloadAjax(callback);

              } else if( opts.initId ) {
                     // Init tree from another UL element
                     this._createFromTag(root, $("#"+opts.initId));

              } else {
                     // Init tree from the first UL element inside the container <div>
//                   var $ul = this.$tree.find(">ul:first").hide();
                     this._createFromTag(root, $ulInitialize);
                     $ulInitialize.remove();
              }

              this._checkConsistency();
              // Fix part-sel flags
              if(!isLazy && opts.selectMode == 3){
                     root._updatePartSelectionState();
              }
              // Render html markup
              this.logDebug("Dynatree._load(): render nodes...");
              this.enableUpdate(prevFlag);

              // bind event handlers
              this.logDebug("Dynatree._load(): bind events...");
              this.$widget.bind();

              // --- Post-load processing
              this.logDebug("Dynatree._load(): postInit...");
              this.phase = "postInit";

              // In persist mode, make sure that cookies are written, even if they are empty
              if( opts.persist ) {
                     this.persistence.write();
              }
              // Set focus, if possible (this will also fire an event and write a cookie)
              if( this.focusNode && this.focusNode.isVisible() ) {
                     this.logDebug("Focus on init: %o", this.focusNode);
                     this.focusNode.focus();
              }
              if( !isLazy ) {
                     if( opts.onPostInit ) {
                            opts.onPostInit.call(this, isReloading, false);
                     }
                     if( callback ){
                            callback.call(this, "ok");
                     }
              }
              this.phase = "idle";
       },

       _reloadAjax: function(callback) {
              // Reload
              var opts = this.options;
              if( ! opts.initAjax || ! opts.initAjax.url ){
                     throw "tree.reload() requires 'initAjax' mode.";
              }
              var pers = this.persistence;
              var ajaxOpts = $.extend({}, opts.initAjax);
              // Append cookie info to the request
//            this.logDebug("reloadAjax: key=%o, an.key:%o", pers.activeKey, this.activeNode?this.activeNode.data.key:"?");
              if( ajaxOpts.addActiveKey ){
                     ajaxOpts.data.activeKey = pers.activeKey;
              }
              if( ajaxOpts.addFocusedKey ){
                     ajaxOpts.data.focusedKey = pers.focusedKey;
              }
              if( ajaxOpts.addExpandedKeyList ){
                     ajaxOpts.data.expandedKeyList = pers.expandedKeyList.join(",");
              }
              if( ajaxOpts.addSelectedKeyList ){
                     ajaxOpts.data.selectedKeyList = pers.selectedKeyList.join(",");
              }
              // Set up onPostInit callback to be called when Ajax returns
              if( ajaxOpts.success ){
                     this.logWarning("initAjax: success callback is ignored; use onPostInit instead.");
              }
              if( ajaxOpts.error ){
                     this.logWarning("initAjax: error callback is ignored; use onPostInit instead.");
              }
              var isReloading = pers.isReloading();
              ajaxOpts.success = function(dtnode, data, textStatus) {
                     if(opts.selectMode == 3){
                            dtnode.tree.tnRoot._updatePartSelectionState();
                     }
                     if(opts.onPostInit){
                            opts.onPostInit.call(dtnode.tree, isReloading, false);
                     }
                     if(callback){
                            callback.call(dtnode.tree, "ok");
                     }
              };
              ajaxOpts.error = function(dtnode, XMLHttpRequest, textStatus, errorThrown) {
                     if(opts.onPostInit){
                            opts.onPostInit.call(dtnode.tree, isReloading, true, XMLHttpRequest, textStatus, errorThrown);
                     }
                     if(callback){
                            callback.call(dtnode.tree, "error", XMLHttpRequest, textStatus, errorThrown);
                     }
              };
//            }
              this.logDebug("Dynatree._init(): send Ajax request...");
              this.tnRoot.appendAjax(ajaxOpts);
       },

       toString: function() {
//            return "DynaTree '" + this.options.title + "'";
              return "Dynatree '" + this.$tree.attr("id") + "'";
       },

       toDict: function() {
              return this.tnRoot.toDict(true);
       },

       serializeArray: function(stopOnParents) {
              // Return a JavaScript array of objects, ready to be encoded as a JSON
              // string for selected nodes
              var nodeList = this.getSelectedNodes(stopOnParents),
                     name = this.$tree.attr("name") || this.$tree.attr("id"),
                     arr = [];
              for(var i=0, l=nodeList.length; i<l; i++){
                     arr.push({name: name, value: nodeList[i].data.key});
              }
              return arr;
       },

       getPersistData: function() {
              return this.persistence.toDict();
       },

       logDebug: function(msg) {
              if( this.options.debugLevel >= 2 ) {
                     Array.prototype.unshift.apply(arguments, ["debug"]);
                     _log.apply(this, arguments);
              }
       },

       logInfo: function(msg) {
              if( this.options.debugLevel >= 1 ) {
                     Array.prototype.unshift.apply(arguments, ["info"]);
                     _log.apply(this, arguments);
              }
       },

       logWarning: function(msg) {
              Array.prototype.unshift.apply(arguments, ["warn"]);
              _log.apply(this, arguments);
       },

       isInitializing: function() {
              return ( this.phase=="init" || this.phase=="postInit" );
       },
       isReloading: function() {
              return ( this.phase=="init" || this.phase=="postInit" ) && this.options.persist && this.persistence.cookiesFound;
       },
       isUserEvent: function() {
              return ( this.phase=="userEvent" );
       },

       redraw: function() {
//            this.logDebug("dynatree.redraw()...");
              this.tnRoot.render(false, false);
//            this.logDebug("dynatree.redraw() done.");
       },
       renderInvisibleNodes: function() {
              this.tnRoot.render(false, true);
       },
       reload: function(callback) {
              this._load(callback);
       },

       getRoot: function() {
              return this.tnRoot;
       },

       enable: function() {
              this.$widget.enable();
       },

       disable: function() {
              this.$widget.disable();
       },

       getNodeByKey: function(key) {
              // Search the DOM by element ID (assuming this is faster than traversing all nodes).
              // $("#...") has problems, if the key contains '.', so we use getElementById()
              var el = document.getElementById(this.options.idPrefix + key);
              if( el ){
                     return el.dtnode ? el.dtnode : null;
              }
              // Not found in the DOM, but still may be in an unrendered part of tree
              var match = null;
              this.visit(function(node){
//                   window.console.log("%s", node);
                     if(node.data.key == key) {
                            match = node;
                            return false;
                     }
              }, true);
              return match;
       },

       getActiveNode: function() {
              return this.activeNode;
       },

       reactivate: function(setFocus) {
              // Re-fire onQueryActivate and onActivate events.
              var node = this.activeNode;
//            this.logDebug("reactivate %o", node);
              if( node ) {
                     this.activeNode = null; // Force re-activating
                     node.activate();
                     if( setFocus ){
                            node.focus();
                     }
              }
       },

       getSelectedNodes: function(stopOnParents) {
              var nodeList = [];
              this.tnRoot.visit(function(node){
                     if( node.bSelected ) {
                            nodeList.push(node);
                            if( stopOnParents === true ){
                                   return "skip"; // stop processing this branch
                            }
                     }
              });
              return nodeList;
       },

       activateKey: function(key) {
              var dtnode = (key === null) ? null : this.getNodeByKey(key);
              if( !dtnode ) {
                     if( this.activeNode ){
                            this.activeNode.deactivate();
                     }
                     this.activeNode = null;
                     return null;
              }
              dtnode.focus();
              dtnode.activate();
              return dtnode;
       },

       loadKeyPath: function(keyPath, callback) {
              var segList = keyPath.split(this.options.keyPathSeparator);
              // Remove leading '/'
              if(segList[0] === ""){
                     segList.shift();
              }
              // Remove leading system root key
              if(segList[0] == this.tnRoot.data.key){
                     this.logDebug("Removed leading root key.");
                     segList.shift();
              }
              keyPath = segList.join(this.options.keyPathSeparator);
              return this.tnRoot._loadKeyPath(keyPath, callback);
       },

       selectKey: function(key, select) {
              var dtnode = this.getNodeByKey(key);
              if( !dtnode ){
                     return null;
              }
              dtnode.select(select);
              return dtnode;
       },

       enableUpdate: function(bEnable) {
              if ( this.bEnableUpdate==bEnable ){
                     return bEnable;
              }
              this.bEnableUpdate = bEnable;
              if ( bEnable ){
                     this.redraw();
              }
              return !bEnable; // return previous value
       },

       count: function() {
              return this.tnRoot.countChildren();
       },

       visit: function(fn, includeRoot) {
              return this.tnRoot.visit(fn, includeRoot);
       },

       _createFromTag: function(parentTreeNode, $ulParent) {
              // Convert a <UL>...</UL> list into children of the parent tree node.
              var self = this;
/*
TODO: better?
              this.$lis = $("li:has(a[href])", this.element);
              this.$tabs = this.$lis.map(function() { return $("a", this)[0]; });
 */
              $ulParent.find(">li").each(function() {
                     var $li = $(this),
                            $liSpan = $li.find(">span:first"),
                            $liA = $li.find(">a:first"),
                            title,
                            href = null,
                            target = null,
                            tooltip;
                     if( $liSpan.length ) {
                            // If a <li><span> tag is specified, use it literally.
                            title = $liSpan.html();
                     } else if( $liA.length ) {
                            title = $liA.html();
                            href = $liA.attr("href");
                            target = $liA.attr("target");
                            tooltip = $liA.attr("title");
                     } else {
                            // If only a <li> tag is specified, use the trimmed string up to
                            // the next child <ul> tag.
                            title = $li.html();
                            var iPos = title.search(/<ul/i);
                            if( iPos >= 0 ){
                                   title = $.trim(title.substring(0, iPos));
                            }else{
                                   title = $.trim(title);
                            }
//                          self.logDebug("%o", title);
                     }
                     // Parse node options from ID, title and class attributes
                     var data = {
                            title: title,
                            tooltip: tooltip,
                            isFolder: $li.hasClass("folder"),
                            isLazy: $li.hasClass("lazy"),
                            expand: $li.hasClass("expanded"),
                            select: $li.hasClass("selected"),
                            activate: $li.hasClass("active"),
                            focus: $li.hasClass("focused"),
                            noLink: $li.hasClass("noLink")
                     };
                     if( href ){
                            data.href = href;
                            data.target = target;
                     }
                     if( $li.attr("title") ){
                            data.tooltip = $li.attr("title"); // overrides <a title='...'>
                     }
                     if( $li.attr("id") ){
                            data.key = $li.attr("id");
                     }
                     // If a data attribute is present, evaluate as a JavaScript object
                     if( $li.attr("data") ) {
                            var dataAttr = $.trim($li.attr("data"));
                            if( dataAttr ) {
                                   if( dataAttr.charAt(0) != "{" ){
                                          dataAttr = "{" + dataAttr + "}";
                                   }
                                   try {
                                          $.extend(data, eval("(" + dataAttr + ")"));
                                   } catch(e) {
                                          throw ("Error parsing node data: " + e + "\ndata:\n'" + dataAttr + "'");
                                   }
                            }
                     }
                     var childNode = parentTreeNode.addChild(data);
                     // Recursive reading of child nodes, if LI tag contains an UL tag
                     var $ul = $li.find(">ul:first");
                     if( $ul.length ) {
                            self._createFromTag(childNode, $ul); // must use 'self', because 'this' is the each() context
                     }
              });
       },

       _checkConsistency: function() {
//            this.logDebug("tree._checkConsistency() NOT IMPLEMENTED - %o", this);
       },

       _setDndStatus: function(sourceNode, targetNode, helper, hitMode, accept) {
              // hitMode: 'after', 'before', 'over', 'out', 'start', 'stop'
              var $source = sourceNode ? $(sourceNode.span) : null,
                     $target = $(targetNode.span);
              if( !this.$dndMarker ) {
                     this.$dndMarker = $("<div id='dynatree-drop-marker'></div>")
                            .hide()
                            .prependTo($(this.divTree).parent());
//                          .prependTo("body");
//                   logMsg("Creating marker: %o", this.$dndMarker);
              }
/*
              if(hitMode === "start"){
              }
              if(hitMode === "stop"){
//                   sourceNode.removeClass("dynatree-drop-target");
              }
*/
//            this.$dndMarker.attr("class", hitMode);
              if(hitMode === "after" || hitMode === "before" || hitMode === "over"){
//                   $source && $source.addClass("dynatree-drag-source");
                     var pos = $target.offset();

//                   $target.addClass("dynatree-drop-target");

                     switch(hitMode){
                     case "before":
                            this.$dndMarker.removeClass("dynatree-drop-after dynatree-drop-over");
                            this.$dndMarker.addClass("dynatree-drop-before");
                            pos.top -= 8;
                            break;
                     case "after":
                            this.$dndMarker.removeClass("dynatree-drop-before dynatree-drop-over");
                            this.$dndMarker.addClass("dynatree-drop-after");
                            pos.top += 8;
                            break;
                     default:
                            this.$dndMarker.removeClass("dynatree-drop-after dynatree-drop-before");
                            this.$dndMarker.addClass("dynatree-drop-over");
                            $target.addClass("dynatree-drop-target");
                            pos.left += 8;
                     }
//                   logMsg("Creating marker: %o", this.$dndMarker);
//                   logMsg("    $target.offset=%o", $target);
//                   logMsg("    pos/$target.offset=%o", pos);
//                   logMsg("    $target.position=%o", $target.position());
//                   logMsg("    $target.offsetParent=%o, ot:%o", $target.offsetParent(), $target.offsetParent().offset());
//                   logMsg("    $(this.divTree).offset=%o", $(this.divTree).offset());
//                   logMsg("    $(this.divTree).parent=%o", $(this.divTree).parent());
//                   var pos = $target.offset();
//                   var parentPos = $target.offsetParent().offset();
//                   var bodyPos = $target.offsetParent().offset();

                     this.$dndMarker //.offset({left: pos.left, top: pos.top})
                            .css({
                                   "left": pos.left,
                                   "top": pos.top,
                                   "z-index": 1000
                            })
                            .show();
//                   helper.addClass("dynatree-drop-hover");
              } else {
//                   $source && $source.removeClass("dynatree-drag-source");
                     $target.removeClass("dynatree-drop-target");
                     this.$dndMarker.hide();
//                   helper.removeClass("dynatree-drop-hover");
              }
              if(hitMode === "after"){
                     $target.addClass("dynatree-drop-after");
              } else {
                     $target.removeClass("dynatree-drop-after");
              }
              if(hitMode === "before"){
                     $target.addClass("dynatree-drop-before");
              } else {
                     $target.removeClass("dynatree-drop-before");
              }
              if(accept === true){
                     if($source){
                            $source.addClass("dynatree-drop-accept");
                     }
                     $target.addClass("dynatree-drop-accept");
                     helper.addClass("dynatree-drop-accept");
              }else{
                     if($source){
                            $source.removeClass("dynatree-drop-accept");
                     }
                     $target.removeClass("dynatree-drop-accept");
                     helper.removeClass("dynatree-drop-accept");
              }
              if(accept === false){
                     if($source){
                            $source.addClass("dynatree-drop-reject");
                     }
                     $target.addClass("dynatree-drop-reject");
                     helper.addClass("dynatree-drop-reject");
              }else{
                     if($source){
                            $source.removeClass("dynatree-drop-reject");
                     }
                     $target.removeClass("dynatree-drop-reject");
                     helper.removeClass("dynatree-drop-reject");
              }
       },

       _onDragEvent: function(eventName, node, otherNode, event, ui, draggable) {
              /**
               * Handles drag'n'drop functionality.
               *
               * A standard jQuery drag-and-drop process may generate these calls:
               *
               * draggable helper():
               *     _onDragEvent("helper", sourceNode, null, event, null, null);
               * start:
               *     _onDragEvent("start", sourceNode, null, event, ui, draggable);
               * drag:
               *     _onDragEvent("leave", prevTargetNode, sourceNode, event, ui, draggable);
               *     _onDragEvent("over", targetNode, sourceNode, event, ui, draggable);
               *     _onDragEvent("enter", targetNode, sourceNode, event, ui, draggable);
               * stop:
               *     _onDragEvent("drop", targetNode, sourceNode, event, ui, draggable);
               *     _onDragEvent("leave", targetNode, sourceNode, event, ui, draggable);
               *     _onDragEvent("stop", sourceNode, null, event, ui, draggable);
               */
//            if(eventName !== "over"){
//                   this.logDebug("tree._onDragEvent(%s, %o, %o) - %o", eventName, node, otherNode, this);
//            }
              var opts = this.options,
                     dnd = this.options.dnd,
                     res = null,
                     nodeTag = $(node.span),
                     hitMode,
                     enterResponse;

              switch (eventName) {
              case "helper":
                     // Only event and node argument is available
                     var $helper = $("<div class='dynatree-drag-helper'><span class='dynatree-drag-helper-img' /></div>")
                            .append($(event.target).closest('a').clone());
                     // issue 244: helper should be child of scrollParent
                     $("ul.dynatree-container", node.tree.divTree).append($helper);
//                   $(node.tree.divTree).append($helper);
                     // Attach node reference to helper object
                     $helper.data("dtSourceNode", node);
//                   this.logDebug("helper=%o", $helper);
//                   this.logDebug("helper.sourceNode=%o", $helper.data("dtSourceNode"));
                     res = $helper;
                     break;
              case "start":
                     if(node.isStatusNode()) {
                            res = false;
                     } else if(dnd.onDragStart) {
                            res = dnd.onDragStart(node);
                     }
                     if(res === false) {
                            this.logDebug("tree.onDragStart() cancelled");
                            //draggable._clear();
                            // NOTE: the return value seems to be ignored (drag is not canceled, when false is returned)
                            ui.helper.trigger("mouseup");
                            ui.helper.hide();
                     } else {
                            nodeTag.addClass("dynatree-drag-source");
                     }
                     break;
              case "enter":
                     res = dnd.onDragEnter ? dnd.onDragEnter(node, otherNode) : null;
                     res = {
                            over: (res !== false) && ((res === true) || (res === "over") || $.inArray("over", res) >= 0),
                            before: (res !== false) && ((res === true) || (res === "before") || $.inArray("before", res) >= 0),
                            after: (res !== false) && ((res === true) || (res === "after") || $.inArray("after", res) >= 0)
                     };
                     ui.helper.data("enterResponse", res);
//                   this.logDebug("helper.enterResponse: %o", res);
                     break;
              case "over":
                     enterResponse = ui.helper.data("enterResponse");
                     hitMode = null;
                     if(enterResponse === false){
                            // Don't call onDragOver if onEnter returned false.
                            break;
                     } else if(typeof enterResponse === "string") {
                            // Use hitMode from onEnter if provided.
                            hitMode = enterResponse;
                     } else {
                            // Calculate hitMode from relative cursor position.
                            var nodeOfs = nodeTag.offset();
//                          var relPos = { x: event.clientX - nodeOfs.left,
//                                               y: event.clientY - nodeOfs.top };
//                          nodeOfs.top += this.parentTop;
//                          nodeOfs.left += this.parentLeft;
                            var relPos = { x: event.pageX - nodeOfs.left,
                                                    y: event.pageY - nodeOfs.top };
                            var relPos2 = { x: relPos.x / nodeTag.width(),
                                                        y: relPos.y / nodeTag.height() };
//                          this.logDebug("event.page: %s/%s", event.pageX, event.pageY);
//                          this.logDebug("event.client: %s/%s", event.clientX, event.clientY);
//                          this.logDebug("nodeOfs: %s/%s", nodeOfs.left, nodeOfs.top);
////                        this.logDebug("parent: %s/%s", this.parentLeft, this.parentTop);
//                          this.logDebug("relPos: %s/%s", relPos.x, relPos.y);
//                          this.logDebug("relPos2: %s/%s", relPos2.x, relPos2.y);
                            if( enterResponse.after && relPos2.y > 0.75 ){
                                   hitMode = "after";
                            } else if(!enterResponse.over && enterResponse.after && relPos2.y > 0.5 ){
                                   hitMode = "after";
                            } else if(enterResponse.before && relPos2.y <= 0.25) {
                                   hitMode = "before";
                            } else if(!enterResponse.over && enterResponse.before && relPos2.y <= 0.5) {
                                   hitMode = "before";
                            } else if(enterResponse.over) {
                                   hitMode = "over";
                            }
                            // Prevent no-ops like 'before source node'
                            // TODO: these are no-ops when moving nodes, but not in copy mode
                            if( dnd.preventVoidMoves ){
                                   if(node === otherNode){
//                                        this.logDebug("    drop over source node prevented");
                                          hitMode = null;
                                   }else if(hitMode === "before" && otherNode && node === otherNode.getNextSibling()){
//                                        this.logDebug("    drop after source node prevented");
                                          hitMode = null;
                                   }else if(hitMode === "after" && otherNode && node === otherNode.getPrevSibling()){
//                                        this.logDebug("    drop before source node prevented");
                                          hitMode = null;
                                   }else if(hitMode === "over" && otherNode
                                                 && otherNode.parent === node && otherNode.isLastSibling() ){
//                                        this.logDebug("    drop last child over own parent prevented");
                                          hitMode = null;
                                   }
                            }
//                          this.logDebug("hitMode: %s - %s - %s", hitMode, (node.parent === otherNode), node.isLastSibling());
                            ui.helper.data("hitMode", hitMode);
                     }
                     // Auto-expand node (only when 'over' the node, not 'before', or 'after')
                     if(hitMode === "over"
                            && dnd.autoExpandMS && node.hasChildren() !== false && !node.bExpanded) {
                            node.scheduleAction("expand", dnd.autoExpandMS);
                     }
                     if(hitMode && dnd.onDragOver){
                            res = dnd.onDragOver(node, otherNode, hitMode);
                     }
                     this._setDndStatus(otherNode, node, ui.helper, hitMode, res!==false);
                     break;
              case "drop":
                     // issue 286: don't trigger onDrop, if DnD status is 'reject'
                     var isForbidden = ui.helper.hasClass("dynatree-drop-reject");
                     hitMode = ui.helper.data("hitMode");
                     if(hitMode && dnd.onDrop && !isForbidden){
                            dnd.onDrop(node, otherNode, hitMode, ui, draggable);
                     }
                     break;
              case "leave":
                     // Cancel pending expand request
                     node.scheduleAction("cancel");
                     ui.helper.data("enterResponse", null);
                     ui.helper.data("hitMode", null);
                     this._setDndStatus(otherNode, node, ui.helper, "out", undefined);
                     if(dnd.onDragLeave){
                            dnd.onDragLeave(node, otherNode);
                     }
                     break;
              case "stop":
                     nodeTag.removeClass("dynatree-drag-source");
                     if(dnd.onDragStop){
                            dnd.onDragStop(node);
                     }
                     break;
              default:
                     throw "Unsupported drag event: " + eventName;
              }
              return res;
       },

       cancelDrag: function() {
               var dd = $.ui.ddmanager.current;
               if(dd){
                      dd.cancel();
               }
       },

       // --- end of class
       lastentry: undefined
};

/*************************************************************************
 * Widget $(..).dynatree
 */

$.widget("ui.dynatree", {
/*
       init: function() {
              // ui.core 1.6 renamed init() to _init(): this stub assures backward compatibility
              _log("warn", "ui.dynatree.init() was called; you should upgrade to jquery.ui.core.js v1.8 or higher.");
              return this._init();
       },
 */
       _init: function() {
              if( parseFloat($.ui.version) < 1.8 ) {
                     // jquery.ui.core 1.8 renamed _init() to _create(): this stub assures backward compatibility
                     if(this.options.debugLevel >= 0){
                            _log("warn", "ui.dynatree._init() was called; you should upgrade to jquery.ui.core.js v1.8 or higher.");
                     }
                     return this._create();
              }
              // jquery.ui.core 1.8 still uses _init() to perform "default functionality"
              if(this.options.debugLevel >= 2){
                     _log("debug", "ui.dynatree._init() was called; no current default functionality.");
              }
       },

       _create: function() {
              var opts = this.options;
              if(opts.debugLevel >= 1){
                     logMsg("Dynatree._create(): version='%s', debugLevel=%o.", $.ui.dynatree.version, this.options.debugLevel);
              }
              // The widget framework supplies this.element and this.options.
              this.options.event += ".dynatree"; // namespace event

              var divTree = this.element.get(0);
/*            // Clear container, in case it contained some 'waiting' or 'error' text
              // for clients that don't support JS
              if( opts.children || (opts.initAjax && opts.initAjax.url) || opts.initId )
                     $(divTree).empty();
*/
              // Create the DynaTree object
              this.tree = new DynaTree(this);
              this.tree._load();
              this.tree.logDebug("Dynatree._init(): done.");
       },

       bind: function() {
              // Prevent duplicate binding
              this.unbind();

              var eventNames = "click.dynatree dblclick.dynatree";
              if( this.options.keyboard ){
                     // Note: leading ' '!
                     eventNames += " keypress.dynatree keydown.dynatree";
              }
              this.element.bind(eventNames, function(event){
                     var dtnode = $.ui.dynatree.getNode(event.target);
                     if( !dtnode ){
                            return true;  // Allow bubbling of other events
                     }
                     var tree = dtnode.tree;
                     var o = tree.options;
                     tree.logDebug("event(%s): dtnode: %s", event.type, dtnode);
                     var prevPhase = tree.phase;
                     tree.phase = "userEvent";
                     try {
                            switch(event.type) {
                            case "click":
                                   return ( o.onClick && o.onClick.call(tree, dtnode, event)===false ) ? false : dtnode._onClick(event);
                            case "dblclick":
                                   return ( o.onDblClick && o.onDblClick.call(tree, dtnode, event)===false ) ? false : dtnode._onDblClick(event);
                            case "keydown":
                                   return ( o.onKeydown && o.onKeydown.call(tree, dtnode, event)===false ) ? false : dtnode._onKeydown(event);
                            case "keypress":
                                   return ( o.onKeypress && o.onKeypress.call(tree, dtnode, event)===false ) ? false : dtnode._onKeypress(event);
                            }
                     } catch(e) {
                            var _ = null; // issue 117
                            tree.logWarning("bind(%o): dtnode: %o, error: %o", event, dtnode, e);
                     } finally {
                            tree.phase = prevPhase;
                     }
              });

              // focus/blur don't bubble, i.e. are not delegated to parent <div> tags,
              // so we use the addEventListener capturing phase.
              // See http://www.howtocreate.co.uk/tutorials/javascript/domevents
              function __focusHandler(event) {
                     // Handles blur and focus.
                     // Fix event for IE:
                     // doesn't pass JSLint:
//                   event = arguments[0] = $.event.fix( event || window.event );
                     // what jQuery does:
//                   var args = jQuery.makeArray( arguments );
//                   event = args[0] = jQuery.event.fix( event || window.event );
                     event = $.event.fix( event || window.event );
                     var dtnode = $.ui.dynatree.getNode(event.target);
                     return dtnode ? dtnode._onFocus(event) : false;
              }
              var div = this.tree.divTree;

              if( div.addEventListener ) {
                     div.addEventListener("focus", __focusHandler, true);
                     div.addEventListener("blur", __focusHandler, true);
              } else {
                     div.onfocusin = div.onfocusout = __focusHandler;
              }
              // EVENTS
              // disable click if event is configured to something else
//            if (!(/^click/).test(o.event))
//                   this.$tabs.bind("click.tabs", function() { return false; });

       },

       unbind: function() {
              this.element.unbind(".dynatree");
       },

/* TODO: we could handle option changes during runtime here (maybe to re-render, ...)
       setData: function(key, value) {
              this.tree.logDebug("dynatree.setData('" + key + "', '" + value + "')");
       },
*/
       enable: function() {
              this.bind();
              // Call default disable(): remove -disabled from css:
              $.Widget.prototype.enable.apply(this, arguments);
       },

       disable: function() {
              this.unbind();
              // Call default disable(): add -disabled to css:
              $.Widget.prototype.disable.apply(this, arguments);
       },

       // --- getter methods (i.e. NOT returning a reference to $)
       getTree: function() {
              return this.tree;
       },

       getRoot: function() {
              return this.tree.getRoot();
       },

       getActiveNode: function() {
              return this.tree.getActiveNode();
       },

       getSelectedNodes: function() {
              return this.tree.getSelectedNodes();
       },

       // ------------------------------------------------------------------------
       lastentry: undefined
});


// The following methods return a value (thus breaking the jQuery call chain):
if( parseFloat($.ui.version) < 1.8 ) {
       $.ui.dynatree.getter = "getTree getRoot getActiveNode getSelectedNodes";
}

/*******************************************************************************
 * Tools in ui.dynatree namespace
 */
$.ui.dynatree.version = "$Version: 1.2.1$";

/**
 * Return a DynaTreeNode object for a given DOM element
 */
$.ui.dynatree.getNode = function(el) {
       if(el instanceof DynaTreeNode){
              return el; // el already was a DynaTreeNode
       }
       if(el.selector !== undefined){
              el = el[0]; // el was a jQuery object: use the DOM element
       }
       // TODO: for some reason $el.parents("[dtnode]") does not work (jQuery 1.6.1)
       // maybe, because dtnode is a property, not an attribute
       while( el ) {
              if(el.dtnode) {
                     return el.dtnode;
              }
              el = el.parentNode;
       }
       return null;
/*
       var $el = el.selector === undefined ? $(el) : el,
//            parent = $el.closest("[dtnode]"),
//            parent = $el.parents("[dtnode]").first(),
              useProp = (typeof $el.prop == "function"),
              node;
       $el.parents().each(function(){
              node = useProp ? $(this).prop("dtnode") : $(this).attr("dtnode");
              if(node){
                     return false;
              }
       });
       return node;
*/
};

/**Return persistence information from cookies.*/
$.ui.dynatree.getPersistData = DynaTreeStatus._getTreePersistData;

/*******************************************************************************
 * Plugin default options:
 */
$.ui.dynatree.prototype.options = {
       title: "Dynatree", // Tree's name (only used for debug output)
       minExpandLevel: 1, // 1: root node is not collapsible
       imagePath: null, // Path to a folder containing icons. Defaults to 'skin/' subdirectory.
       children: null, // Init tree structure from this object array.
       initId: null, // Init tree structure from a <ul> element with this ID.
       initAjax: null, // Ajax options used to initialize the tree strucuture.
       autoFocus: true, // Set focus to first child, when expanding or lazy-loading.
       keyboard: true, // Support keyboard navigation.
       persist: false, // Persist expand-status to a cookie
       autoCollapse: false, // Automatically collapse all siblings, when a node is expanded.
       clickFolderMode: 3, // 1:activate, 2:expand, 3:activate and expand
       activeVisible: true, // Make sure, active nodes are visible (expanded).
       checkbox: false, // Show checkboxes.
       selectMode: 2, // 1:single, 2:multi, 3:multi-hier
       fx: null, // Animations, e.g. null or { height: "toggle", duration: 200 }
       noLink: false, // Use <span> instead of <a> tags for all nodes
       // Low level event handlers: onEvent(dtnode, event): return false, to stop default processing
       onClick: null, // null: generate focus, expand, activate, select events.
       onDblClick: null, // (No default actions.)
       onKeydown: null, // null: generate keyboard navigation (focus, expand, activate).
       onKeypress: null, // (No default actions.)
       onFocus: null, // null: set focus to node.
       onBlur: null, // null: remove focus from node.

       // Pre-event handlers onQueryEvent(flag, dtnode): return false, to stop processing
       onQueryActivate: null, // Callback(flag, dtnode) before a node is (de)activated.
       onQuerySelect: null, // Callback(flag, dtnode) before a node is (de)selected.
       onQueryExpand: null, // Callback(flag, dtnode) before a node is expanded/collpsed.

       // High level event handlers
       onPostInit: null, // Callback(isReloading, isError) when tree was (re)loaded.
       onActivate: null, // Callback(dtnode) when a node is activated.
       onDeactivate: null, // Callback(dtnode) when a node is deactivated.
       onSelect: null, // Callback(flag, dtnode) when a node is (de)selected.
       onExpand: null, // Callback(flag, dtnode) when a node is expanded/collapsed.
       onLazyRead: null, // Callback(dtnode) when a lazy node is expanded for the first time.
       onCustomRender: null, // Callback(dtnode) before a node is rendered. Return a HTML string to override.
       onCreate: null, // Callback(dtnode, nodeSpan) after a node was rendered for the first time.
       onRender: null, // Callback(dtnode, nodeSpan) after a node was rendered.
                            // postProcess is similar to the standard dataFilter hook,
                            // but it is also called for JSONP
       postProcess: null, // Callback(data, dataType) before an Ajax result is passed to dynatree

       // Drag'n'drop support
       dnd: {
              // Make tree nodes draggable:
              onDragStart: null, // Callback(sourceNode), return true, to enable dnd
              onDragStop: null, // Callback(sourceNode)
//            helper: null,
              // Make tree nodes accept draggables
              autoExpandMS: 1000, // Expand nodes after n milliseconds of hovering.
              preventVoidMoves: true, // Prevent dropping nodes 'before self', etc.
              onDragEnter: null, // Callback(targetNode, sourceNode)
              onDragOver: null, // Callback(targetNode, sourceNode, hitMode)
              onDrop: null, // Callback(targetNode, sourceNode, hitMode)
              onDragLeave: null // Callback(targetNode, sourceNode)
       },
       ajaxDefaults: { // Used by initAjax option
              cache: false, // false: Append random '_' argument to the request url to prevent caching.
              timeout: 0, // >0: Make sure we get an ajax error for invalid URLs
              dataType: "json" // Expect json format and pass json object to callbacks.
       },
       strings: {
              loading: "Loading&#8230;",
              loadError: "Load error!"
       },
       generateIds: false, // Generate id attributes like <span id='dynatree-id-KEY'>
       idPrefix: "dynatree-id-", // Used to generate node id's like <span id="dynatree-id-<key>">.
       keyPathSeparator: "/", // Used by node.getKeyPath() and tree.loadKeyPath().
//    cookieId: "dynatree-cookie", // Choose a more unique name, to allow multiple trees.
       cookieId: "dynatree", // Choose a more unique name, to allow multiple trees.
       cookie: {
              expires: null //7, // Days or Date; null: session cookie
//            path: "/", // Defaults to current page
//            domain: "jquery.com",
//            secure: true
       },
       // Class names used, when rendering the HTML markup.
       // Note: if only single entries are passed for options.classNames, all other
       // values are still set to default.
       classNames: {
              container: "dynatree-container",
              node: "dynatree-node",
              folder: "dynatree-folder",
//            document: "dynatree-document",

              empty: "dynatree-empty",
              vline: "dynatree-vline",
              expander: "dynatree-expander",
              connector: "dynatree-connector",
              checkbox: "dynatree-checkbox",
              nodeIcon: "dynatree-icon",
              title: "dynatree-title",
              noConnector: "dynatree-no-connector",

              nodeError: "dynatree-statusnode-error",
              nodeWait: "dynatree-statusnode-wait",
              hidden: "dynatree-hidden",
              combinedExpanderPrefix: "dynatree-exp-",
              combinedIconPrefix: "dynatree-ico-",
              nodeLoading: "dynatree-loading",
//            disabled: "dynatree-disabled",
              hasChildren: "dynatree-has-children",
              active: "dynatree-active",
              selected: "dynatree-selected",
              expanded: "dynatree-expanded",
              lazy: "dynatree-lazy",
              focused: "dynatree-focused",
              partsel: "dynatree-partsel",
              lastsib: "dynatree-lastsib"
       },
       debugLevel: 1,

       // ------------------------------------------------------------------------
       lastentry: undefined
};
//
if( parseFloat($.ui.version) < 1.8 ) {
       $.ui.dynatree.defaults = $.ui.dynatree.prototype.options;
}

/*******************************************************************************
 * Reserved data attributes for a tree node.
 */
$.ui.dynatree.nodedatadefaults = {
       title: null, // (required) Displayed name of the node (html is allowed here)
       key: null, // May be used with activate(), select(), find(), ...
       isFolder: false, // Use a folder icon. Also the node is expandable but not selectable.
       isLazy: false, // Call onLazyRead(), when the node is expanded for the first time to allow for delayed creation of children.
       tooltip: null, // Show this popup text.
       href: null, // Added to the generated <a> tag.
       icon: null, // Use a custom image (filename relative to tree.options.imagePath). 'null' for default icon, 'false' for no icon.
       addClass: null, // Class name added to the node's span tag.
       noLink: false, // Use <span> instead of <a> tag for this node
       activate: false, // Initial active status.
       focus: false, // Initial focused status.
       expand: false, // Initial expanded status.
       select: false, // Initial selected status.
       hideCheckbox: false, // Suppress checkbox display for this node.
       unselectable: false, // Prevent selection.
//  disabled: false,
       // The following attributes are only valid if passed to some functions:
       children: null, // Array of child nodes.
       // NOTE: we can also add custom attributes here.
       // This may then also be used in the onActivate(), onSelect() or onLazyTree() callbacks.
       // ------------------------------------------------------------------------
       lastentry: undefined
};

/*******************************************************************************
 * Drag and drop support
 */
function _initDragAndDrop(tree) {
       var dnd = tree.options.dnd || null;
       // Register 'connectToDynatree' option with ui.draggable
       if(dnd && (dnd.onDragStart || dnd.onDrop)) {
              _registerDnd();
       }
       // Attach ui.draggable to this Dynatree instance
       if(dnd && dnd.onDragStart ) {
              tree.$tree.draggable({
                     addClasses: false,
                     appendTo: "body",
                     containment: false,
                     delay: 0,
                     distance: 4,
                     revert: false,
                     scroll: true, // issue 244: enable scrolling (if ul.dynatree-container)
                     scrollSpeed: 7,
                     scrollSensitivity: 10,
                     // Delegate draggable.start, drag, and stop events to our handler
                     connectToDynatree: true,
                     // Let source tree create the helper element
                     helper: function(event) {
                            var sourceNode = $.ui.dynatree.getNode(event.target);
                            if(!sourceNode){ // issue 211
                                   return "<div></div>";
                            }
                            return sourceNode.tree._onDragEvent("helper", sourceNode, null, event, null, null);
                     },
                     start: function(event, ui) {
                            // See issues 211, 268, 278
//                          var sourceNode = $.ui.dynatree.getNode(event.target);
                            var sourceNode = ui.helper.data("dtSourceNode");
                            return !!sourceNode; // Abort dragging if no Node could be found
                     },
                     _last: null
              });
       }
       // Attach ui.droppable to this Dynatree instance
       if(dnd && dnd.onDrop) {
              tree.$tree.droppable({
                     addClasses: false,
                     tolerance: "intersect",
                     greedy: false,
                     _last: null
              });
       }
}

//--- Extend ui.draggable event handling --------------------------------------
var didRegisterDnd = false;
var _registerDnd = function() {
       if(didRegisterDnd){
              return;
       }
       // Register proxy-functions for draggable.start/drag/stop
       $.ui.plugin.add("draggable", "connectToDynatree", {
              start: function(event, ui) {
                     var draggable = $(this).data("draggable"),
                            sourceNode = ui.helper.data("dtSourceNode") || null;
//                   logMsg("draggable-connectToDynatree.start, %s", sourceNode);
//                   logMsg("    this: %o", this);
//                   logMsg("    event: %o", event);
//                   logMsg("    draggable: %o", draggable);
//                   logMsg("    ui: %o", ui);

                     if(sourceNode) {
                            // Adjust helper offset, so cursor is slightly outside top/left corner
//                          draggable.offset.click.top -= event.target.offsetTop;
//                          draggable.offset.click.left -= event.target.offsetLeft;
                            draggable.offset.click.top = -2;
                            draggable.offset.click.left = + 16;
//                          logMsg("    draggable2: %o", draggable);
//                          logMsg("    draggable.offset.click FIXED: %s/%s", draggable.offset.click.left, draggable.offset.click.top);
                            // Trigger onDragStart event
                            // TODO: when called as connectTo..., the return value is ignored(?)
                            return sourceNode.tree._onDragEvent("start", sourceNode, null, event, ui, draggable);
                     }
              },
              drag: function(event, ui) {
                     var draggable = $(this).data("draggable"),
                            sourceNode = ui.helper.data("dtSourceNode") || null,
                            prevTargetNode = ui.helper.data("dtTargetNode") || null,
                            targetNode = $.ui.dynatree.getNode(event.target);
//                   logMsg("$.ui.dynatree.getNode(%o): %s", event.target, targetNode);
//                   logMsg("connectToDynatree.drag: helper: %o", ui.helper[0]);
                     if(event.target && !targetNode){
                            // We got a drag event, but the targetNode could not be found
                            // at the event location. This may happen,
                            // 1. if the mouse jumped over the drag helper,
                            // 2. or if non-dynatree element is dragged
                            // We ignore it:
                            var isHelper = $(event.target).closest("div.dynatree-drag-helper,#dynatree-drop-marker").length > 0;
                            if(isHelper){
//                                 logMsg("Drag event over helper: ignored.");
                                   return;
                            }
                     }
//                   logMsg("draggable-connectToDynatree.drag: targetNode(from event): %s, dtTargetNode: %s", targetNode, ui.helper.data("dtTargetNode"));
                     ui.helper.data("dtTargetNode", targetNode);
                     // Leaving a tree node
                     if(prevTargetNode && prevTargetNode !== targetNode ) {
                            prevTargetNode.tree._onDragEvent("leave", prevTargetNode, sourceNode, event, ui, draggable);
                     }
                     if(targetNode){
                            if(!targetNode.tree.options.dnd.onDrop) {
                                   // not enabled as drop target
                                   noop(); // Keep JSLint happy
                            } else if(targetNode === prevTargetNode) {
                                   // Moving over same node
                                   targetNode.tree._onDragEvent("over", targetNode, sourceNode, event, ui, draggable);
                            }else{
                                   // Entering this node first time
                                   targetNode.tree._onDragEvent("enter", targetNode, sourceNode, event, ui, draggable);
                            }
                     }
                     // else go ahead with standard event handling
              },
              stop: function(event, ui) {
                     var draggable = $(this).data("draggable"),
                            sourceNode = ui.helper.data("dtSourceNode") || null,
                            targetNode = ui.helper.data("dtTargetNode") || null,
                            mouseDownEvent = draggable._mouseDownEvent,
                            eventType = event.type,
                            dropped = (eventType == "mouseup" && event.which == 1);
//                   logMsg("draggable-connectToDynatree.stop: targetNode(from event): %s, dtTargetNode: %s", targetNode, ui.helper.data("dtTargetNode"));
//                   logMsg("draggable-connectToDynatree.stop, %s", sourceNode);
//                   logMsg("    type: %o, downEvent: %o, upEvent: %o", eventType, mouseDownEvent, event);
//                   logMsg("    targetNode: %o", targetNode);
                     if(!dropped){
                            logMsg("Drag was cancelled");
                     }
                     if(targetNode) {
                            if(dropped){
                                   targetNode.tree._onDragEvent("drop", targetNode, sourceNode, event, ui, draggable);
                            }
                            targetNode.tree._onDragEvent("leave", targetNode, sourceNode, event, ui, draggable);
                     }
                     if(sourceNode){
                            sourceNode.tree._onDragEvent("stop", sourceNode, null, event, ui, draggable);
                     }
              }
       });
       didRegisterDnd = true;
};

// ---------------------------------------------------------------------------
}(jQuery));

/*
* jQuery timepicker addon
* By: Trent Richardson [http://trentrichardson.com]
* Version 1.0.2
* Last Modified: 07/01/2012
*
* Copyright 2012 Trent Richardson
* You may use this project under MIT or GPL licenses.
* http://trentrichardson.com/Impromptu/GPL-LICENSE.txt
* http://trentrichardson.com/Impromptu/MIT-LICENSE.txt
*
* HERES THE CSS:
* .ui-timepicker-div .ui-widget-header { margin-bottom: 8px; }
* .ui-timepicker-div dl { text-align: left; }
* .ui-timepicker-div dl dt { height: 25px; margin-bottom: -25px; }
* .ui-timepicker-div dl dd { margin: 0 10px 10px 65px; }
* .ui-timepicker-div td { font-size: 90%; }
* .ui-tpicker-grid-label { background: none; border: none; margin: 0; padding: 0; }
*/

/*jslint evil: true, maxlen: 300, white: false, undef: false, nomen: false, onevar: false */

(function($) {

// Prevent "Uncaught RangeError: Maximum call stack size exceeded"
$.ui.timepicker = $.ui.timepicker || {};
if ($.ui.timepicker.version) {
  return;
}

$.extend($.ui, { timepicker: { version: "1.0.2" } });

/* Time picker manager.
   Use the singleton instance of this class, $.timepicker, to interact with the time picker.
   Settings for (groups of) time pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Timepicker() {
  this.regional = []; // Available regional settings, indexed by language code
  this.regional[''] = { // Default regional settings
    currentText: 'Now',
    closeText: 'Done',
    ampm: false,
    amNames: ['AM', 'A'],
    pmNames: ['PM', 'P'],
    timeFormat: 'hh:mm tt',
    timeSuffix: '',
    timeOnlyTitle: 'Choose Time',
    timeText: 'Time',
    hourText: 'Hour',
    minuteText: 'Minute',
    secondText: 'Second',
    millisecText: 'Millisecond',
    timezoneText: 'Time Zone'
  };
  this._defaults = { // Global defaults for all the datetime picker instances
    showButtonPanel: true,
    timeOnly: false,
    showHour: true,
    showMinute: true,
    showSecond: false,
    showMillisec: false,
    showTimezone: false,
    showTime: true,
    stepHour: 1,
    stepMinute: 1,
    stepSecond: 1,
    stepMillisec: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisec: 0,
    timezone: null,
    useLocalTimezone: false,
    defaultTimezone: "+0000",
    hourMin: 0,
    minuteMin: 0,
    secondMin: 0,
    millisecMin: 0,
    hourMax: 23,
    minuteMax: 59,
    secondMax: 59,
    millisecMax: 999,
    minDateTime: null,
    maxDateTime: null,
    onSelect: null,
    hourGrid: 0,
    minuteGrid: 0,
    secondGrid: 0,
    millisecGrid: 0,
    alwaysSetTime: true,
    separator: ' ',
    altFieldTimeOnly: true,
    altSeparator: null,
    altTimeSuffix: null,
    showTimepicker: true,
    timezoneIso8601: false,
    timezoneList: null,
    addSliderAccess: false,
    sliderAccessArgs: null,
    defaultValue: null
  };
  $.extend(this._defaults, this.regional['']);
}

$.extend(Timepicker.prototype, {
  $input: null,
  $altInput: null,
  $timeObj: null,
  inst: null,
  hour_slider: null,
  minute_slider: null,
  second_slider: null,
  millisec_slider: null,
  timezone_select: null,
  hour: 0,
  minute: 0,
  second: 0,
  millisec: 0,
  timezone: null,
  defaultTimezone: "+0000",
  hourMinOriginal: null,
  minuteMinOriginal: null,
  secondMinOriginal: null,
  millisecMinOriginal: null,
  hourMaxOriginal: null,
  minuteMaxOriginal: null,
  secondMaxOriginal: null,
  millisecMaxOriginal: null,
  ampm: '',
  formattedDate: '',
  formattedTime: '',
  formattedDateTime: '',
  timezoneList: null,

  /* Override the default settings for all instances of the time picker.
     @param  settings  object - the new settings to use as defaults (anonymous object)
     @return the manager object */
  setDefaults: function(settings) {
    extendRemove(this._defaults, settings || {});
    return this;
  },

  //########################################################################
  // Create a new Timepicker instance
  //########################################################################
  _newInst: function($input, o) {
    var tp_inst = new Timepicker(),
      inlineSettings = {};

    for (var attrName in this._defaults) {
      var attrValue = $input.attr('time:' + attrName);
      if (attrValue) {
        try {
          inlineSettings[attrName] = eval(attrValue);
        } catch (err) {
          inlineSettings[attrName] = attrValue;
        }
      }
    }
    tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, o, {
      beforeShow: function(input, dp_inst) {
        if ($.isFunction(o.beforeShow)) {
          return o.beforeShow(input, dp_inst, tp_inst);
                }
      },
      onChangeMonthYear: function(year, month, dp_inst) {
        // Update the time as well : this prevents the time from disappearing from the $input field.
        tp_inst._updateDateTime(dp_inst);
        if ($.isFunction(o.onChangeMonthYear)) {
          o.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
                }
      },
      onClose: function(dateText, dp_inst) {
        if (tp_inst.timeDefined === true && $input.val() !== '') {
          tp_inst._updateDateTime(dp_inst);
                }
        if ($.isFunction(o.onClose)) {
          o.onClose.call($input[0], dateText, dp_inst, tp_inst);
                }
      },
      timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
    });
    tp_inst.amNames = $.map(tp_inst._defaults.amNames, function(val) { return val.toUpperCase(); });
    tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function(val) { return val.toUpperCase(); });

    if (tp_inst._defaults.timezoneList === null) {
      var timezoneList = ['-1200','-1100','-1000','-0930','-0900','-0800','-0700','-0600','-0500','-0430','-0400','-0330','-0300','-0200','-0100','+0000','+0100','+0200','+0300',
          '+0330','+0400','+0430','+0500','+0530','+0545','+0600','+0630','+0700','+0800','+0845','+0900','+0930','+1000','+1030','+1100','+1130','+1200','+1245','+1300','+1400'];
      
      if (tp_inst._defaults.timezoneIso8601) {
        timezoneList = $.map(timezoneList, function(val) {
          return val == '+0000' ? 'Z' : (val.substring(0, 3) + ':' + val.substring(3));
        });
      }
      tp_inst._defaults.timezoneList = timezoneList;
    }

    tp_inst.timezone = tp_inst._defaults.timezone;
    tp_inst.hour = tp_inst._defaults.hour;
    tp_inst.minute = tp_inst._defaults.minute;
    tp_inst.second = tp_inst._defaults.second;
    tp_inst.millisec = tp_inst._defaults.millisec;
    tp_inst.ampm = '';
    tp_inst.$input = $input;

    if (o.altField) {
      tp_inst.$altInput = $(o.altField)
        .css({ cursor: 'pointer' })
        .focus(function(){ $input.trigger("focus"); });
        }

    if(tp_inst._defaults.minDate===0 || tp_inst._defaults.minDateTime===0)
    {
      tp_inst._defaults.minDate=new Date();
    }
    if(tp_inst._defaults.maxDate===0 || tp_inst._defaults.maxDateTime===0)
    {
      tp_inst._defaults.maxDate=new Date();
    }

    // datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
    if(tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
      tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
        }
    if(tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
      tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
        }
    if(tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
      tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
        }
    if(tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
      tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
        }
        tp_inst.$input.bind('focus', function() {
      tp_inst._onFocus();
        });

    return tp_inst;
  },

  //########################################################################
  // add our sliders to the calendar
  //########################################################################
  _addTimePicker: function(dp_inst) {
    var currDT = (this.$altInput && this._defaults.altFieldTimeOnly) ?
        this.$input.val() + ' ' + this.$altInput.val() :
        this.$input.val();

    this.timeDefined = this._parseTime(currDT);
    this._limitMinMaxDateTime(dp_inst, false);
    this._injectTimePicker();
  },

  //########################################################################
  // parse the time string from input value or _setTime
  //########################################################################
  _parseTime: function(timeString, withDate) {
    if (!this.inst) {
      this.inst = $.datepicker._getInst(this.$input[0]);
    }
    
    if (withDate || !this._defaults.timeOnly) 
    {
      var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
      try {
        var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
        if (!parseRes.timeObj) { return false; }
        $.extend(this, parseRes.timeObj);
      } catch (err)
      {
        return false;
      }
      return true;
    }
    else
    {
      var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
      if(!timeObj) { return false; }
      $.extend(this, timeObj);
      return true;
    }
  },
  
  //########################################################################
  // generate and inject html for timepicker into ui datepicker
  //########################################################################
  _injectTimePicker: function() {
    var $dp = this.inst.dpDiv,
      o = this.inst.settings,
      tp_inst = this,
      // Added by Peter Medeiros:
      // - Figure out what the hour/minute/second max should be based on the step values.
      // - Example: if stepMinute is 15, then minMax is 45.
      hourMax = parseInt((o.hourMax - ((o.hourMax - o.hourMin) % o.stepHour)) ,10),
      minMax  = parseInt((o.minuteMax - ((o.minuteMax - o.minuteMin) % o.stepMinute)) ,10),
      secMax  = parseInt((o.secondMax - ((o.secondMax - o.secondMin) % o.stepSecond)) ,10),
      millisecMax  = parseInt((o.millisecMax - ((o.millisecMax - o.millisecMin) % o.stepMillisec)) ,10);

    // Prevent displaying twice
    if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) {
      var noDisplay = ' style="display:none;"',
        html =  '<div class="ui-timepicker-div"><dl>' +
            '<dt class="ui_tpicker_time_label"' +
            ((o.showTime) ? '' : noDisplay) + '>' + o.timeText + '</dt>' +
            '<dd class="ui_tpicker_time"' +
            ((o.showTime) ? '' : noDisplay) + '></dd>' +
            '<dt class="ui_tpicker_hour_label"' +
            ((o.showHour) ? '' : noDisplay) + '>' + o.hourText + '</dt>',
        hourGridSize = 0,
        minuteGridSize = 0,
        secondGridSize = 0,
        millisecGridSize = 0,
        size = null;

      // Hours
      html += '<dd class="ui_tpicker_hour"><div class="ui_tpicker_hour_slider"' +
            ((o.showHour) ? '' : noDisplay) + '></div>';
      if (o.showHour && o.hourGrid > 0) {
        html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

        for (var h = o.hourMin; h <= hourMax; h += parseInt(o.hourGrid,10)) {
          hourGridSize++;
          var tmph = (o.ampm && h > 12) ? h-12 : h;
          if (tmph < 10) { tmph = '0' + tmph; }
          if (o.ampm) {
            if (h === 0) {
                            tmph = 12 +'a';
                        } else {
                            if (h < 12) { tmph += 'a'; }
                else { tmph += 'p'; }
                        }
          }
          html += '<td>' + tmph + '</td>';
        }

        html += '</tr></table></div>';
      }
      html += '</dd>';

      // Minutes
      html += '<dt class="ui_tpicker_minute_label"' +
          ((o.showMinute) ? '' : noDisplay) + '>' + o.minuteText + '</dt>'+
          '<dd class="ui_tpicker_minute"><div class="ui_tpicker_minute_slider"' +
              ((o.showMinute) ? '' : noDisplay) + '></div>';

      if (o.showMinute && o.minuteGrid > 0) {
        html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

        for (var m = o.minuteMin; m <= minMax; m += parseInt(o.minuteGrid,10)) {
          minuteGridSize++;
          html += '<td>' + ((m < 10) ? '0' : '') + m + '</td>';
        }

        html += '</tr></table></div>';
      }
      html += '</dd>';

      // Seconds
      html += '<dt class="ui_tpicker_second_label"' +
          ((o.showSecond) ? '' : noDisplay) + '>' + o.secondText + '</dt>'+
          '<dd class="ui_tpicker_second"><div class="ui_tpicker_second_slider"'+
              ((o.showSecond) ? '' : noDisplay) + '></div>';

      if (o.showSecond && o.secondGrid > 0) {
        html += '<div style="padding-left: 1px"><table><tr>';

        for (var s = o.secondMin; s <= secMax; s += parseInt(o.secondGrid,10)) {
          secondGridSize++;
          html += '<td>' + ((s < 10) ? '0' : '') + s + '</td>';
        }

        html += '</tr></table></div>';
      }
      html += '</dd>';

      // Milliseconds
      html += '<dt class="ui_tpicker_millisec_label"' +
          ((o.showMillisec) ? '' : noDisplay) + '>' + o.millisecText + '</dt>'+
          '<dd class="ui_tpicker_millisec"><div class="ui_tpicker_millisec_slider"'+
              ((o.showMillisec) ? '' : noDisplay) + '></div>';

      if (o.showMillisec && o.millisecGrid > 0) {
        html += '<div style="padding-left: 1px"><table><tr>';

        for (var l = o.millisecMin; l <= millisecMax; l += parseInt(o.millisecGrid,10)) {
          millisecGridSize++;
          html += '<td>' + ((l < 10) ? '0' : '') + l + '</td>';
        }

        html += '</tr></table></div>';
      }
      html += '</dd>';

      // Timezone
      html += '<dt class="ui_tpicker_timezone_label"' +
          ((o.showTimezone) ? '' : noDisplay) + '>' + o.timezoneText + '</dt>';
      html += '<dd class="ui_tpicker_timezone" '  +
              ((o.showTimezone) ? '' : noDisplay) + '></dd>';

      html += '</dl></div>';
      var $tp = $(html);

        // if we only want time picker...
      if (o.timeOnly === true) {
        $tp.prepend(
          '<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' +
            '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' +
          '</div>');
        $dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
      }

      this.hour_slider = $tp.find('.ui_tpicker_hour_slider').slider({
        orientation: "horizontal",
        value: this.hour,
        min: o.hourMin,
        max: hourMax,
        step: o.stepHour,
        slide: function(event, ui) {
          tp_inst.hour_slider.slider( "option", "value", ui.value);
          tp_inst._onTimeChange();
        }
      });


      // Updated by Peter Medeiros:
      // - Pass in Event and UI instance into slide function
      this.minute_slider = $tp.find('.ui_tpicker_minute_slider').slider({
        orientation: "horizontal",
        value: this.minute,
        min: o.minuteMin,
        max: minMax,
        step: o.stepMinute,
        slide: function(event, ui) {
          tp_inst.minute_slider.slider( "option", "value", ui.value);
          tp_inst._onTimeChange();
        }
      });

      this.second_slider = $tp.find('.ui_tpicker_second_slider').slider({
        orientation: "horizontal",
        value: this.second,
        min: o.secondMin,
        max: secMax,
        step: o.stepSecond,
        slide: function(event, ui) {
          tp_inst.second_slider.slider( "option", "value", ui.value);
          tp_inst._onTimeChange();
        }
      });

      this.millisec_slider = $tp.find('.ui_tpicker_millisec_slider').slider({
        orientation: "horizontal",
        value: this.millisec,
        min: o.millisecMin,
        max: millisecMax,
        step: o.stepMillisec,
        slide: function(event, ui) {
          tp_inst.millisec_slider.slider( "option", "value", ui.value);
          tp_inst._onTimeChange();
        }
      });

      this.timezone_select = $tp.find('.ui_tpicker_timezone').append('<select></select>').find("select");
      $.fn.append.apply(this.timezone_select,
        $.map(o.timezoneList, function(val, idx) {
          return $("<option />")
            .val(typeof val == "object" ? val.value : val)
            .text(typeof val == "object" ? val.label : val);
        })
      );
      if (typeof(this.timezone) != "undefined" && this.timezone !== null && this.timezone !== "") {
        var local_date = new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12);
        var local_timezone = $.timepicker.timeZoneOffsetString(local_date);
        if (local_timezone == this.timezone) {
          selectLocalTimeZone(tp_inst);
        } else {
          this.timezone_select.val(this.timezone);
        }
      } else {
        if (typeof(this.hour) != "undefined" && this.hour !== null && this.hour !== "") {
          this.timezone_select.val(o.defaultTimezone);
        } else {
          selectLocalTimeZone(tp_inst);
        }
      }
      this.timezone_select.change(function() {
        tp_inst._defaults.useLocalTimezone = false;
        tp_inst._onTimeChange();
      });

      // Add grid functionality
      if (o.showHour && o.hourGrid > 0) {
        size = 100 * hourGridSize * o.hourGrid / (hourMax - o.hourMin);

        $tp.find(".ui_tpicker_hour table").css({
          width: size + "%",
          marginLeft: (size / (-2 * hourGridSize)) + "%",
          borderCollapse: 'collapse'
        }).find("td").each( function(index) {
          $(this).click(function() {
            var h = $(this).html();
            if(o.ampm)  {
              var ap = h.substring(2).toLowerCase(),
                aph = parseInt(h.substring(0,2), 10);
              if (ap == 'a') {
                if (aph == 12) { h = 0; }
                else { h = aph; }
              } else if (aph == 12) { h = 12; }
              else { h = aph + 12; }
            }
            tp_inst.hour_slider.slider("option", "value", h);
            tp_inst._onTimeChange();
            tp_inst._onSelectHandler();
          }).css({
            cursor: 'pointer',
            width: (100 / hourGridSize) + '%',
            textAlign: 'center',
            overflow: 'hidden'
          });
        });
      }

      if (o.showMinute && o.minuteGrid > 0) {
        size = 100 * minuteGridSize * o.minuteGrid / (minMax - o.minuteMin);
        $tp.find(".ui_tpicker_minute table").css({
          width: size + "%",
          marginLeft: (size / (-2 * minuteGridSize)) + "%",
          borderCollapse: 'collapse'
        }).find("td").each(function(index) {
          $(this).click(function() {
            tp_inst.minute_slider.slider("option", "value", $(this).html());
            tp_inst._onTimeChange();
            tp_inst._onSelectHandler();
          }).css({
            cursor: 'pointer',
            width: (100 / minuteGridSize) + '%',
            textAlign: 'center',
            overflow: 'hidden'
          });
        });
      }

      if (o.showSecond && o.secondGrid > 0) {
        $tp.find(".ui_tpicker_second table").css({
          width: size + "%",
          marginLeft: (size / (-2 * secondGridSize)) + "%",
          borderCollapse: 'collapse'
        }).find("td").each(function(index) {
          $(this).click(function() {
            tp_inst.second_slider.slider("option", "value", $(this).html());
            tp_inst._onTimeChange();
            tp_inst._onSelectHandler();
          }).css({
            cursor: 'pointer',
            width: (100 / secondGridSize) + '%',
            textAlign: 'center',
            overflow: 'hidden'
          });
        });
      }

      if (o.showMillisec && o.millisecGrid > 0) {
        $tp.find(".ui_tpicker_millisec table").css({
          width: size + "%",
          marginLeft: (size / (-2 * millisecGridSize)) + "%",
          borderCollapse: 'collapse'
        }).find("td").each(function(index) {
          $(this).click(function() {
            tp_inst.millisec_slider.slider("option", "value", $(this).html());
            tp_inst._onTimeChange();
            tp_inst._onSelectHandler();
          }).css({
            cursor: 'pointer',
            width: (100 / millisecGridSize) + '%',
            textAlign: 'center',
            overflow: 'hidden'
          });
        });
      }

      var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
      if ($buttonPanel.length) { $buttonPanel.before($tp); }
      else { $dp.append($tp); }

      this.$timeObj = $tp.find('.ui_tpicker_time');

      if (this.inst !== null) {
        var timeDefined = this.timeDefined;
        this._onTimeChange();
        this.timeDefined = timeDefined;
      }

      //Emulate datepicker onSelect behavior. Call on slidestop.
      var onSelectDelegate = function() {
        tp_inst._onSelectHandler();
      };
      this.hour_slider.bind('slidestop',onSelectDelegate);
      this.minute_slider.bind('slidestop',onSelectDelegate);
      this.second_slider.bind('slidestop',onSelectDelegate);
      this.millisec_slider.bind('slidestop',onSelectDelegate);

      // slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
      if (this._defaults.addSliderAccess){
        var sliderAccessArgs = this._defaults.sliderAccessArgs;
        setTimeout(function(){ // fix for inline mode
          if($tp.find('.ui-slider-access').length === 0){
            $tp.find('.ui-slider:visible').sliderAccess(sliderAccessArgs);

            // fix any grids since sliders are shorter
            var sliderAccessWidth = $tp.find('.ui-slider-access:eq(0)').outerWidth(true);
            if(sliderAccessWidth){
              $tp.find('table:visible').each(function(){
                var $g = $(this),
                  oldWidth = $g.outerWidth(),
                  oldMarginLeft = $g.css('marginLeft').toString().replace('%',''),
                  newWidth = oldWidth - sliderAccessWidth,
                  newMarginLeft = ((oldMarginLeft * newWidth)/oldWidth) + '%';

                $g.css({ width: newWidth, marginLeft: newMarginLeft });
              });
            }
          }
        },0);
      }
      // end slideAccess integration

    }
  },

  //########################################################################
  // This function tries to limit the ability to go outside the
  // min/max date range
  //########################################################################
  _limitMinMaxDateTime: function(dp_inst, adjustSliders){
    var o = this._defaults,
      dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

    if(!this._defaults.showTimepicker) { return; } // No time so nothing to check here

    if($.datepicker._get(dp_inst, 'minDateTime') !== null && $.datepicker._get(dp_inst, 'minDateTime') !== undefined && dp_date){
      var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
        minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

      if(this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null){
        this.hourMinOriginal = o.hourMin;
        this.minuteMinOriginal = o.minuteMin;
        this.secondMinOriginal = o.secondMin;
        this.millisecMinOriginal = o.millisecMin;
      }

      if(dp_inst.settings.timeOnly || minDateTimeDate.getTime() == dp_date.getTime()) {
        this._defaults.hourMin = minDateTime.getHours();
        if (this.hour <= this._defaults.hourMin) {
          this.hour = this._defaults.hourMin;
          this._defaults.minuteMin = minDateTime.getMinutes();
          if (this.minute <= this._defaults.minuteMin) {
            this.minute = this._defaults.minuteMin;
            this._defaults.secondMin = minDateTime.getSeconds();
            if (this.second <= this._defaults.secondMin){
              this.second = this._defaults.secondMin;
              this._defaults.millisecMin = minDateTime.getMilliseconds();
            }
            else {
              if(this.millisec < this._defaults.millisecMin) {
                this.millisec = this._defaults.millisecMin;
              }
              this._defaults.millisecMin = this.millisecMinOriginal;
            }
          }
          else {
            this._defaults.secondMin = this.secondMinOriginal;
            this._defaults.millisecMin = this.millisecMinOriginal;
          }
        }
        else {
          this._defaults.minuteMin = this.minuteMinOriginal;
          this._defaults.secondMin = this.secondMinOriginal;
          this._defaults.millisecMin = this.millisecMinOriginal;
        }
      }
      else {
        this._defaults.hourMin = this.hourMinOriginal;
        this._defaults.minuteMin = this.minuteMinOriginal;
        this._defaults.secondMin = this.secondMinOriginal;
        this._defaults.millisecMin = this.millisecMinOriginal;
      }
    }

    if($.datepicker._get(dp_inst, 'maxDateTime') !== null && $.datepicker._get(dp_inst, 'maxDateTime') !== undefined && dp_date){
      var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
        maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);

      if(this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null){
        this.hourMaxOriginal = o.hourMax;
        this.minuteMaxOriginal = o.minuteMax;
        this.secondMaxOriginal = o.secondMax;
        this.millisecMaxOriginal = o.millisecMax;
      }

      if(dp_inst.settings.timeOnly || maxDateTimeDate.getTime() == dp_date.getTime()){
        this._defaults.hourMax = maxDateTime.getHours();
        if (this.hour >= this._defaults.hourMax) {
          this.hour = this._defaults.hourMax;
          this._defaults.minuteMax = maxDateTime.getMinutes();
          if (this.minute >= this._defaults.minuteMax) {
            this.minute = this._defaults.minuteMax;
            this._defaults.secondMax = maxDateTime.getSeconds();
          } else if (this.second >= this._defaults.secondMax) {
            this.second = this._defaults.secondMax;
            this._defaults.millisecMax = maxDateTime.getMilliseconds();
          } else {
            if(this.millisec > this._defaults.millisecMax) { this.millisec = this._defaults.millisecMax; }
            this._defaults.millisecMax = this.millisecMaxOriginal;
          }
        } else {
          this._defaults.minuteMax = this.minuteMaxOriginal;
          this._defaults.secondMax = this.secondMaxOriginal;
          this._defaults.millisecMax = this.millisecMaxOriginal;
        }
      }else{
        this._defaults.hourMax = this.hourMaxOriginal;
        this._defaults.minuteMax = this.minuteMaxOriginal;
        this._defaults.secondMax = this.secondMaxOriginal;
        this._defaults.millisecMax = this.millisecMaxOriginal;
      }
    }

    if(adjustSliders !== undefined && adjustSliders === true){
      var hourMax = parseInt((this._defaults.hourMax - ((this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour)) ,10),
                minMax  = parseInt((this._defaults.minuteMax - ((this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute)) ,10),
                secMax  = parseInt((this._defaults.secondMax - ((this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond)) ,10),
        millisecMax  = parseInt((this._defaults.millisecMax - ((this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec)) ,10);

      if(this.hour_slider) {
        this.hour_slider.slider("option", { min: this._defaults.hourMin, max: hourMax }).slider('value', this.hour);
            }
      if(this.minute_slider) {
        this.minute_slider.slider("option", { min: this._defaults.minuteMin, max: minMax }).slider('value', this.minute);
            }
      if(this.second_slider){
        this.second_slider.slider("option", { min: this._defaults.secondMin, max: secMax }).slider('value', this.second);
            }
      if(this.millisec_slider) {
        this.millisec_slider.slider("option", { min: this._defaults.millisecMin, max: millisecMax }).slider('value', this.millisec);
            }
    }

  },


  //########################################################################
  // when a slider moves, set the internal time...
  // on time change is also called when the time is updated in the text field
  //########################################################################
  _onTimeChange: function() {
    var hour   = (this.hour_slider) ? this.hour_slider.slider('value') : false,
      minute = (this.minute_slider) ? this.minute_slider.slider('value') : false,
      second = (this.second_slider) ? this.second_slider.slider('value') : false,
      millisec = (this.millisec_slider) ? this.millisec_slider.slider('value') : false,
      timezone = (this.timezone_select) ? this.timezone_select.val() : false,
      o = this._defaults;

    if (typeof(hour) == 'object') { hour = false; }
    if (typeof(minute) == 'object') { minute = false; }
    if (typeof(second) == 'object') { second = false; }
    if (typeof(millisec) == 'object') { millisec = false; }
    if (typeof(timezone) == 'object') { timezone = false; }

    if (hour !== false) { hour = parseInt(hour,10); }
    if (minute !== false) { minute = parseInt(minute,10); }
    if (second !== false) { second = parseInt(second,10); }
    if (millisec !== false) { millisec = parseInt(millisec,10); }

    var ampm = o[hour < 12 ? 'amNames' : 'pmNames'][0];

    // If the update was done in the input field, the input field should not be updated.
    // If the update was done using the sliders, update the input field.
    var hasChanged = (hour != this.hour || minute != this.minute ||
        second != this.second || millisec != this.millisec ||
        (this.ampm.length > 0 &&
            (hour < 12) != ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1)) ||
        ((this.timezone == null && timezone != this.defaultTimezone) || (this.timezone != null && timezone != this.timezone)));

    if (hasChanged) {

      if (hour !== false) { this.hour = hour; }
      if (minute !== false) { this.minute = minute; }
      if (second !== false) { this.second = second; }
      if (millisec !== false) { this.millisec = millisec; }
      if (timezone !== false) { this.timezone = timezone; }

      if (!this.inst) { this.inst = $.datepicker._getInst(this.$input[0]); }

      this._limitMinMaxDateTime(this.inst, true);
    }
    if (o.ampm) { this.ampm = ampm; }

    //this._formatTime();
    this.formattedTime = $.datepicker.formatTime(this._defaults.timeFormat, this, this._defaults);
    if (this.$timeObj) { this.$timeObj.text(this.formattedTime + o.timeSuffix); }
    this.timeDefined = true;
    if (hasChanged) { this._updateDateTime(); }
  },

  //########################################################################
  // call custom onSelect.
  // bind to sliders slidestop, and grid click.
  //########################################################################
  _onSelectHandler: function() {
    var onSelect = this._defaults.onSelect;
    var inputEl = this.$input ? this.$input[0] : null;
    if (onSelect && inputEl) {
      onSelect.apply(inputEl, [this.formattedDateTime, this]);
    }
  },

  //########################################################################
  // left for any backwards compatibility
  //########################################################################
  _formatTime: function(time, format) {
    time = time || { hour: this.hour, minute: this.minute, second: this.second, millisec: this.millisec, ampm: this.ampm, timezone: this.timezone };
    var tmptime = (format || this._defaults.timeFormat).toString();

    tmptime = $.datepicker.formatTime(tmptime, time, this._defaults);

    if (arguments.length) { return tmptime; }
    else { this.formattedTime = tmptime; }
  },

  //########################################################################
  // update our input with the new date time..
  //########################################################################
  _updateDateTime: function(dp_inst) {
    dp_inst = this.inst || dp_inst;
    var dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
      dateFmt = $.datepicker._get(dp_inst, 'dateFormat'),
      formatCfg = $.datepicker._getFormatConfig(dp_inst),
      timeAvailable = dt !== null && this.timeDefined;
    this.formattedDate = $.datepicker.formatDate(dateFmt, (dt === null ? new Date() : dt), formatCfg);
    var formattedDateTime = this.formattedDate;
    
    // remove following lines to force every changes in date picker to change the input value
    // Bug descriptions: when an input field has a default value, and click on the field to pop up the date picker. 
    // If the user manually empty the value in the input field, the date picker will never change selected value.
    //if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0)) {
    //  return;
    //}

    if (this._defaults.timeOnly === true) {
      formattedDateTime = this.formattedTime;
    } else if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable)) {
      formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
    }

    this.formattedDateTime = formattedDateTime;

    if(!this._defaults.showTimepicker) {
      this.$input.val(this.formattedDate);
    } else if (this.$altInput && this._defaults.altFieldTimeOnly === true) {
      this.$altInput.val(this.formattedTime);
      this.$input.val(this.formattedDate);
    } else if(this.$altInput) {
      this.$input.val(formattedDateTime);
      var altFormattedDateTime = '',
        altSeparator = this._defaults.altSeparator ? this._defaults.altSeparator : this._defaults.separator,
        altTimeSuffix = this._defaults.altTimeSuffix ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;
      if (this._defaults.altFormat)
        altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, (dt === null ? new Date() : dt), formatCfg);
      else
        altFormattedDateTime = this.formattedDate;
      if (altFormattedDateTime)
        altFormattedDateTime += altSeparator;
      if (this._defaults.altTimeFormat)
        altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix;
      else
        altFormattedDateTime += this.formattedTime + altTimeSuffix;
      this.$altInput.val(altFormattedDateTime);
    } else {
      this.$input.val(formattedDateTime);
    }

    this.$input.trigger("change");
  },

  _onFocus: function() {
    if( !this.$input.val() && this._defaults.defaultValue ) {
      this.$input.val(this._defaults.defaultValue);
      var inst = $.datepicker._getInst(this.$input.get(0)),
      tp_inst = $.datepicker._get(inst, 'timepicker');
      if (tp_inst) {
        if (tp_inst._defaults.timeOnly && (inst.input.val() != inst.lastVal)) {
          try {
            $.datepicker._updateDatepicker(inst);
          }
          catch (err) {
            $.datepicker.log(err);
          }
        }
      }
    }
  }

});

$.fn.extend({
  //########################################################################
  // shorthand just to use timepicker..
  //########################################################################
  timepicker: function(o) {
    o = o || {};
    var tmp_args = arguments;

    if (typeof o == 'object') { tmp_args[0] = $.extend(o, { timeOnly: true }); }

    return $(this).each(function() {
      $.fn.datetimepicker.apply($(this), tmp_args);
    });
  },

  //########################################################################
  // extend timepicker to datepicker
  //########################################################################
  datetimepicker: function(o) {
    o = o || {};
    var tmp_args = arguments;

    if (typeof(o) == 'string'){
      if(o == 'getDate') {
        return $.fn.datepicker.apply($(this[0]), tmp_args);
            }
      else {
        return this.each(function() {
          var $t = $(this);
          $t.datepicker.apply($t, tmp_args);
        });
            }
    }
    else {
      return this.each(function() {
        var $t = $(this);
        $t.datepicker($.timepicker._newInst($t, o)._defaults);
      });
        }
  }
});

$.datepicker.parseDateTime = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
  var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
  if (parseRes.timeObj)
  {
    var t = parseRes.timeObj;
    parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
  }

  return parseRes.date;
};

$.datepicker.parseTime = function(timeFormat, timeString, options) {
  
  //########################################################################
  // pattern for standard and localized AM/PM markers
  //########################################################################
  var getPatternAmpm = function(amNames, pmNames) {
    var markers = [];
    if (amNames) {
      $.merge(markers, amNames);
        }
    if (pmNames) {
      $.merge(markers, pmNames);
        }
    markers = $.map(markers, function(val) { return val.replace(/[.*+?|()\[\]{}\\]/g, '\\$&'); });
    return '(' + markers.join('|') + ')?';
  };
   
  //########################################################################
  // figure out position of time elements.. cause js cant do named captures
  //########################################################################
  var getFormatPositions = function( timeFormat ) {
    var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|t{1,2}|z)/g),
      orders = { h: -1, m: -1, s: -1, l: -1, t: -1, z: -1 };

    if (finds) {
      for (var i = 0; i < finds.length; i++) {
        if (orders[finds[i].toString().charAt(0)] == -1) {
          orders[finds[i].toString().charAt(0)] = i + 1;
                }
            }
        }
    return orders;
  };
    
  var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {});
    
  var regstr = '^' + timeFormat.toString()
      .replace(/h{1,2}/ig, '(\\d?\\d)')
      .replace(/m{1,2}/ig, '(\\d?\\d)')
      .replace(/s{1,2}/ig, '(\\d?\\d)')
      .replace(/l{1}/ig, '(\\d?\\d?\\d)')
      .replace(/t{1,2}/ig, getPatternAmpm(o.amNames, o.pmNames))
      .replace(/z{1}/ig, '(z|[-+]\\d\\d:?\\d\\d|\\S+)?')
      .replace(/\s/g, '\\s?') + o.timeSuffix + '$',
    order = getFormatPositions(timeFormat),
    ampm = '',
    treg;

  treg = timeString.match(new RegExp(regstr, 'i'));

  var resTime = {hour: 0, minute: 0, second: 0, millisec: 0};
    
  if (treg) {
    if (order.t !== -1) {
      if (treg[order.t] === undefined || treg[order.t].length === 0) {
        ampm = '';
        resTime.ampm = '';
      } else {
        ampm = $.inArray(treg[order.t].toUpperCase(), o.amNames) !== -1 ? 'AM' : 'PM';
        resTime.ampm = o[ampm == 'AM' ? 'amNames' : 'pmNames'][0];
      }
    }

    if (order.h !== -1) {
      if (ampm == 'AM' && treg[order.h] == '12') {
        resTime.hour = 0; // 12am = 0 hour
      } else {
                if (ampm == 'PM' && treg[order.h] != '12') {
                    resTime.hour = parseInt(treg[order.h],10) + 12; // 12pm = 12 hour, any other pm = hour + 12
                }
                else { resTime.hour = Number(treg[order.h]); }
            }
    }

    if (order.m !== -1) { resTime.minute = Number(treg[order.m]); }
    if (order.s !== -1) { resTime.second = Number(treg[order.s]); }
    if (order.l !== -1) { resTime.millisec = Number(treg[order.l]); }
    if (order.z !== -1 && treg[order.z] !== undefined) {
      var tz = treg[order.z].toUpperCase();
      switch (tz.length) {
        case 1:  // Z
          tz = o.timezoneIso8601 ? 'Z' : '+0000';
          break;
        case 5:  // +hhmm
          if (o.timezoneIso8601) {
            tz = tz.substring(1) == '0000' ?
              'Z' :
              tz.substring(0, 3) + ':' + tz.substring(3);
                    }
          break;
        case 6:  // +hh:mm
          if (!o.timezoneIso8601) {
            tz = tz == 'Z' || tz.substring(1) == '00:00' ?
              '+0000' :
              tz.replace(/:/, '');
          } else {
                        if (tz.substring(1) == '00:00') {
                            tz = 'Z';
                        }
                    }
          break;
      }
      resTime.timezone = tz;
    }


    return resTime;
  }

  return false;
};

//########################################################################
// format the time all pretty...
// format = string format of the time
// time = a {}, not a Date() for timezones
// options = essentially the regional[].. amNames, pmNames, ampm
//########################################################################
$.datepicker.formatTime = function(format, time, options) {
  options = options || {};
  options = $.extend({}, $.timepicker._defaults, options);
  time = $.extend({hour:0, minute:0, second:0, millisec:0, timezone:'+0000'}, time);

  var tmptime = format;
  var ampmName = options.amNames[0];

  var hour = parseInt(time.hour, 10);
  if (options.ampm) {
    if (hour > 11){
      ampmName = options.pmNames[0];
      if(hour > 12) {
        hour = hour % 12;
            }
    }
    if (hour === 0) {
      hour = 12;
        }
  }
  tmptime = tmptime.replace(/(?:hh?|mm?|ss?|[tT]{1,2}|[lz]|('.*?'|".*?"))/g, function(match) {
    switch (match.toLowerCase()) {
      case 'hh': return ('0' + hour).slice(-2);
      case 'h':  return hour;
      case 'mm': return ('0' + time.minute).slice(-2);
      case 'm':  return time.minute;
      case 'ss': return ('0' + time.second).slice(-2);
      case 's':  return time.second;
      case 'l':  return ('00' + time.millisec).slice(-3);
      case 'z':  return time.timezone;
      case 't': case 'tt':
        if (options.ampm) {
          if (match.length == 1) {
            ampmName = ampmName.charAt(0);
                    }
          return match.charAt(0) === 'T' ? ampmName.toUpperCase() : ampmName.toLowerCase();
        }
        return '';
      default:
        return match.replace(/\'/g, "") || "'";
    }
  });

  tmptime = $.trim(tmptime);
  return tmptime;
};

//########################################################################
// the bad hack :/ override datepicker so it doesnt close on select
// inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
//########################################################################
$.datepicker._base_selectDate = $.datepicker._selectDate;
$.datepicker._selectDate = function (id, dateStr) {
  var inst = this._getInst($(id)[0]),
    tp_inst = this._get(inst, 'timepicker');

  if (tp_inst) {
    tp_inst._limitMinMaxDateTime(inst, true);
    inst.inline = inst.stay_open = true;
    //This way the onSelect handler called from calendarpicker get the full dateTime
    this._base_selectDate(id, dateStr);
    inst.inline = inst.stay_open = false;
    this._notifyChange(inst);
    this._updateDatepicker(inst);
  }
  else { this._base_selectDate(id, dateStr); }
};

//#############################################################################################
// second bad hack :/ override datepicker so it triggers an event when changing the input field
// and does not redraw the datepicker on every selectDate event
//#############################################################################################
$.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
$.datepicker._updateDatepicker = function(inst) {

  // don't popup the datepicker if there is another instance already opened
  var input = inst.input[0];
  if($.datepicker._curInst &&
     $.datepicker._curInst != inst &&
     $.datepicker._datepickerShowing &&
     $.datepicker._lastInput != input) {
    return;
  }

  if (typeof(inst.stay_open) !== 'boolean' || inst.stay_open === false) {

    this._base_updateDatepicker(inst);

    // Reload the time control when changing something in the input text field.
    var tp_inst = this._get(inst, 'timepicker');
    if(tp_inst) {
      tp_inst._addTimePicker(inst);

      if (tp_inst._defaults.useLocalTimezone) { //checks daylight saving with the new date.
        var date = new Date(inst.selectedYear, inst.selectedMonth, inst.selectedDay, 12);
        selectLocalTimeZone(tp_inst, date);
        tp_inst._onTimeChange();
      }
    }
  }
};

//#######################################################################################
// third bad hack :/ override datepicker so it allows spaces and colon in the input field
//#######################################################################################
$.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
$.datepicker._doKeyPress = function(event) {
  var inst = $.datepicker._getInst(event.target),
    tp_inst = $.datepicker._get(inst, 'timepicker');

  if (tp_inst) {
    if ($.datepicker._get(inst, 'constrainInput')) {
      var ampm = tp_inst._defaults.ampm,
        dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
        datetimeChars = tp_inst._defaults.timeFormat.toString()
                .replace(/[hms]/g, '')
                .replace(/TT/g, ampm ? 'APM' : '')
                .replace(/Tt/g, ampm ? 'AaPpMm' : '')
                .replace(/tT/g, ampm ? 'AaPpMm' : '')
                .replace(/T/g, ampm ? 'AP' : '')
                .replace(/tt/g, ampm ? 'apm' : '')
                .replace(/t/g, ampm ? 'ap' : '') +
                " " +
                tp_inst._defaults.separator +
                tp_inst._defaults.timeSuffix +
                (tp_inst._defaults.showTimezone ? tp_inst._defaults.timezoneList.join('') : '') +
                (tp_inst._defaults.amNames.join('')) +
                (tp_inst._defaults.pmNames.join('')) +
                dateChars,
        chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
      return event.ctrlKey || (chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1);
    }
  }

  return $.datepicker._base_doKeyPress(event);
};

//#######################################################################################
// Override key up event to sync manual input changes.
//#######################################################################################
$.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
$.datepicker._doKeyUp = function (event) {
  var inst = $.datepicker._getInst(event.target),
    tp_inst = $.datepicker._get(inst, 'timepicker');

  if (tp_inst) {
    if (tp_inst._defaults.timeOnly && (inst.input.val() != inst.lastVal)) {
      try {
        $.datepicker._updateDatepicker(inst);
      }
      catch (err) {
        $.datepicker.log(err);
      }
    }
  }

  return $.datepicker._base_doKeyUp(event);
};

//#######################################################################################
// override "Today" button to also grab the time.
//#######################################################################################
$.datepicker._base_gotoToday = $.datepicker._gotoToday;
$.datepicker._gotoToday = function(id) {
  var inst = this._getInst($(id)[0]),
    $dp = inst.dpDiv;
  this._base_gotoToday(id);
  var tp_inst = this._get(inst, 'timepicker');
  selectLocalTimeZone(tp_inst);
  var now = new Date();
  this._setTime(inst, now);
  $( '.ui-datepicker-today', $dp).click();
};

//#######################################################################################
// Disable & enable the Time in the datetimepicker
//#######################################################################################
$.datepicker._disableTimepickerDatepicker = function(target) {
  var inst = this._getInst(target);
    if (!inst) { return; }
    
  var tp_inst = this._get(inst, 'timepicker');
  $(target).datepicker('getDate'); // Init selected[Year|Month|Day]
  if (tp_inst) {
    tp_inst._defaults.showTimepicker = false;
    tp_inst._updateDateTime(inst);
  }
};

$.datepicker._enableTimepickerDatepicker = function(target) {
  var inst = this._getInst(target);
    if (!inst) { return; }
    
  var tp_inst = this._get(inst, 'timepicker');
  $(target).datepicker('getDate'); // Init selected[Year|Month|Day]
  if (tp_inst) {
    tp_inst._defaults.showTimepicker = true;
    tp_inst._addTimePicker(inst); // Could be disabled on page load
    tp_inst._updateDateTime(inst);
  }
};

//#######################################################################################
// Create our own set time function
//#######################################################################################
$.datepicker._setTime = function(inst, date) {
  var tp_inst = this._get(inst, 'timepicker');
  if (tp_inst) {
    var defaults = tp_inst._defaults,
      // calling _setTime with no date sets time to defaults
      hour = date ? date.getHours() : defaults.hour,
      minute = date ? date.getMinutes() : defaults.minute,
      second = date ? date.getSeconds() : defaults.second,
      millisec = date ? date.getMilliseconds() : defaults.millisec;
    //check if within min/max times..
    // correct check if within min/max times.   
    // Rewritten by Scott A. Woodward
    var hourEq = hour === defaults.hourMin,
      minuteEq = minute === defaults.minuteMin,
      secondEq = second === defaults.secondMin;
    var reset = false;
    if(hour < defaults.hourMin || hour > defaults.hourMax)  
      reset = true;
    else if( (minute < defaults.minuteMin || minute > defaults.minuteMax) && hourEq)
      reset = true;
    else if( (second < defaults.secondMin || second > defaults.secondMax ) && hourEq && minuteEq)
      reset = true;
    else if( (millisec < defaults.millisecMin || millisec > defaults.millisecMax) && hourEq && minuteEq && secondEq)
      reset = true;
    if(reset) {
      hour = defaults.hourMin;
      minute = defaults.minuteMin;
      second = defaults.secondMin;
      millisec = defaults.millisecMin;
    }
    tp_inst.hour = hour;
    tp_inst.minute = minute;
    tp_inst.second = second;
    tp_inst.millisec = millisec;
    if (tp_inst.hour_slider) tp_inst.hour_slider.slider('value', hour);
    if (tp_inst.minute_slider) tp_inst.minute_slider.slider('value', minute);
    if (tp_inst.second_slider) tp_inst.second_slider.slider('value', second);
    if (tp_inst.millisec_slider) tp_inst.millisec_slider.slider('value', millisec);

    tp_inst._onTimeChange();
    tp_inst._updateDateTime(inst);
  }
};

//#######################################################################################
// Create new public method to set only time, callable as $().datepicker('setTime', date)
//#######################################################################################
$.datepicker._setTimeDatepicker = function(target, date, withDate) {
  var inst = this._getInst(target);
    if (!inst) { return; }
    
  var tp_inst = this._get(inst, 'timepicker');
    
  if (tp_inst) {
    this._setDateFromField(inst);
    var tp_date;
    if (date) {
      if (typeof date == "string") {
        tp_inst._parseTime(date, withDate);
        tp_date = new Date();
        tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
      }
      else { tp_date = new Date(date.getTime()); }
      if (tp_date.toString() == 'Invalid Date') { tp_date = undefined; }
      this._setTime(inst, tp_date);
    }
  }

};

//#######################################################################################
// override setDate() to allow setting time too within Date object
//#######################################################################################
$.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
$.datepicker._setDateDatepicker = function(target, date) {
  var inst = this._getInst(target);
    if (!inst) { return; }
    
  var tp_date = (date instanceof Date) ? new Date(date.getTime()) : date;

  this._updateDatepicker(inst);
  this._base_setDateDatepicker.apply(this, arguments);
  this._setTimeDatepicker(target, tp_date, true);
};

//#######################################################################################
// override getDate() to allow getting time too within Date object
//#######################################################################################
$.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
$.datepicker._getDateDatepicker = function(target, noDefault) {
  var inst = this._getInst(target);
    if (!inst) { return; }
    
    var tp_inst = this._get(inst, 'timepicker');

  if (tp_inst) {
    this._setDateFromField(inst, noDefault);
    var date = this._getDate(inst);
    if (date && tp_inst._parseTime($(target).val(), tp_inst.timeOnly)) { date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec); }
    return date;
  }
  return this._base_getDateDatepicker(target, noDefault);
};

//#######################################################################################
// override parseDate() because UI 1.8.14 throws an error about "Extra characters"
// An option in datapicker to ignore extra format characters would be nicer.
//#######################################################################################
$.datepicker._base_parseDate = $.datepicker.parseDate;
$.datepicker.parseDate = function(format, value, settings) {
    var splitRes = splitDateTime(format, value, settings);
  return $.datepicker._base_parseDate(format, splitRes[0], settings);
};

//#######################################################################################
// override formatDate to set date with time to the input
//#######################################################################################
$.datepicker._base_formatDate = $.datepicker._formatDate;
$.datepicker._formatDate = function(inst, day, month, year){
  var tp_inst = this._get(inst, 'timepicker');
  if(tp_inst) {
    tp_inst._updateDateTime(inst);
    return tp_inst.$input.val();
  }
  return this._base_formatDate(inst);
};

//#######################################################################################
// override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
//#######################################################################################
$.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
$.datepicker._optionDatepicker = function(target, name, value) {
  var inst = this._getInst(target);
    if (!inst) { return null; }
    
  var tp_inst = this._get(inst, 'timepicker');
  if (tp_inst) {
    var min = null, max = null, onselect = null;
    if (typeof name == 'string') { // if min/max was set with the string
      if (name === 'minDate' || name === 'minDateTime' ) {
        min = value;
            }
      else {
                if (name === 'maxDate' || name === 'maxDateTime') {
                    max = value;
                }
                else {
                    if (name === 'onSelect') {
                        onselect = value;
                    }
                }
            }
    } else {
            if (typeof name == 'object') { //if min/max was set with the JSON
                if (name.minDate) {
                    min = name.minDate;
                } else {
                    if (name.minDateTime) {
                        min = name.minDateTime;
                    } else {
                        if (name.maxDate) {
                            max = name.maxDate;
                        } else {
                            if (name.maxDateTime) {
                                max = name.maxDateTime;
                            }
                        }
                    }
                }
            }
        }
    if(min) { //if min was set
      if (min === 0) {
        min = new Date();
            } else {
        min = new Date(min);
            }

      tp_inst._defaults.minDate = min;
      tp_inst._defaults.minDateTime = min;
    } else if (max) { //if max was set
      if(max===0) {
        max=new Date();
            } else {
        max= new Date(max);
            }
      tp_inst._defaults.maxDate = max;
      tp_inst._defaults.maxDateTime = max;
    } else if (onselect) {
      tp_inst._defaults.onSelect = onselect;
        }
  }
  if (value === undefined) {
    return this._base_optionDatepicker(target, name);
    }
  return this._base_optionDatepicker(target, name, value);
};

//#######################################################################################
// jQuery extend now ignores nulls!
//#######################################################################################
function extendRemove(target, props) {
  $.extend(target, props);
  for (var name in props) {
    if (props[name] === null || props[name] === undefined) {
      target[name] = props[name];
        }
    }
  return target;
}

//#######################################################################################
// Splits datetime string into date ans time substrings.
// Throws exception when date can't be parsed
// If only date is present, time substring eill be '' 
//#######################################################################################
var splitDateTime = function(dateFormat, dateTimeString, dateSettings)
{
  try {
    var date = $.datepicker._base_parseDate(dateFormat, dateTimeString, dateSettings);
  } catch (err) {
    if (err.indexOf(":") >= 0) {
      // Hack!  The error message ends with a colon, a space, and
      // the "extra" characters.  We rely on that instead of
      // attempting to perfectly reproduce the parsing algorithm.
            var dateStringLength = dateTimeString.length-(err.length-err.indexOf(':')-2);
            var timeString = dateTimeString.substring(dateStringLength);

            return [dateTimeString.substring(0, dateStringLength), dateTimeString.substring(dateStringLength)];
            
    } else {
      throw err;
    }
  }
  return [dateTimeString, ''];
};

//#######################################################################################
// Internal function to parse datetime interval
// Returns: {date: Date, timeObj: Object}, where
//   date - parsed date without time (type Date)
//   timeObj = {hour: , minute: , second: , millisec: } - parsed time. Optional
//#######################################################################################
var parseDateTimeInternal = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings)
{
    var date;
    var splitRes = splitDateTime(dateFormat, dateTimeString, dateSettings);
  date = $.datepicker._base_parseDate(dateFormat, splitRes[0], dateSettings);
    if (splitRes[1] !== '')
    {
        var timeString = splitRes[1];
        var separator = timeSettings && timeSettings.separator ? timeSettings.separator : $.timepicker._defaults.separator;            
        if ( timeString.indexOf(separator) !== 0) {
            throw 'Missing time separator';
        }
        timeString = timeString.substring(separator.length);
        var parsedTime = $.datepicker.parseTime(timeFormat, timeString, timeSettings);
        if (parsedTime === null) {
            throw 'Wrong time format';
        }
        return {date: date, timeObj: parsedTime};
    } else {
        return {date: date};
    }
};

//#######################################################################################
// Internal function to set timezone_select to the local timezone
//#######################################################################################
var selectLocalTimeZone = function(tp_inst, date)
{
  if (tp_inst && tp_inst.timezone_select) {
    tp_inst._defaults.useLocalTimezone = true;
    var now = typeof date !== 'undefined' ? date : new Date();
    var tzoffset = $.timepicker.timeZoneOffsetString(now);
    if (tp_inst._defaults.timezoneIso8601) {
      tzoffset = tzoffset.substring(0, 3) + ':' + tzoffset.substring(3);
        }
    tp_inst.timezone_select.val(tzoffset);
  }
};

$.timepicker = new Timepicker(); // singleton instance

/**
 * Get the timezone offset as string from a date object (eg '+0530' for UTC+5.5)
 * @param  date
 * @return string
 */
$.timepicker.timeZoneOffsetString = function(date) {
  var off = date.getTimezoneOffset() * -1,
    minutes = off % 60,
    hours = (off-minutes) / 60;
  return (off >= 0 ? '+' : '-') + ('0'+(hours*101).toString()).substr(-2) + ('0'+(minutes*101).toString()).substr(-2);
};

//#######################################################################################
// Changes by simonvwade to better handle time range limits
//#######################################################################################
/**
 * Calls `timepicker()` on the `startTime` and `endTime` elements, and configures them to
 * enforce date range limits.
 * n.b. The input value must be correctly formatted (reformatting is not supported)
 * @param  Element startTime
 * @param  Element endTime
 * @param  obj options Options for the timepicker() call
 * @return jQuery
 */
$.timepicker.timeRange = function( startTime, endTime, options ) {
  return $.timepicker.handleRange('timepicker', startTime, endTime, options);
}

/**
 * Calls `datetimepicker` on the `startTime` and `endTime` elements, and configures them to
 * enforce date range limits.
 * @param  Element startTime
 * @param  Element endTime
 * @param  obj options Options for the `timepicker()` call. Also supports `reformat`,
 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
 * @param  string method Can be used to specify the type of picker to be added
 * @return jQuery
 */
$.timepicker.dateTimeRange = function( startTime, endTime, options ) {
  $.timepicker.dateRange(startTime, endTime, options, 'datetimepicker');
}

/**
 * Calls `method` on the `startTime` and `endTime` elements, and configures them to
 * enforce date range limits.
 * @param  Element startTime
 * @param  Element endTime
 * @param  obj options Options for the `timepicker()` call. Also supports `reformat`,
 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
 * @param  string method Can be used to specify the type of picker to be added
 * @return jQuery
 */
$.timepicker.dateRange = function( startTime, endTime, options, method ) {
  method = method || 'datepicker';
  $.timepicker.handleRange(method, startTime, endTime, options);
}

/**
 * Calls `method` on the `startTime` and `endTime` elements, and configures them to
 * enforce date range limits.
 * @param  string method Can be used to specify the type of picker to be added
 * @param  Element startTime
 * @param  Element endTime
 * @param  obj options Options for the `timepicker()` call. Also supports `reformat`,
 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
 * @return jQuery
 */
$.timepicker.handleRange = function( method, startTime, endTime, options ) {
  $.fn[method].call(startTime, $.extend({
      onClose: function(dateText, inst) {
        checkDates(this, endTime, dateText);
      },
      onSelect: function (selectedDateTime) {
        selected(this, endTime, 'minDate');
      }
    }, options, options.start)
  );
  $.fn[method].call(endTime, $.extend({
      onClose: function(dateText, inst) {
        checkDates(this, startTime, dateText);
      },
      onSelect: function (selectedDateTime) {
        selected(this, startTime, 'maxDate');
      }
    }, options, options.end)
  );
  // timepicker doesn't provide access to its 'timeFormat' option, 
  // nor could I get datepicker.formatTime() to behave with times, so I
  // have disabled reformatting for timepicker
  if( method != 'timepicker' && options.reformat ) {
    $([startTime, endTime]).each(function() {
      var format = $(this)[method].call($(this), 'option', 'dateFormat'),
        date = new Date($(this).val());
      if( $(this).val() && date ) {
        $(this).val($.datepicker.formatDate(format, date));
      }
    });
  }
  checkDates(startTime, endTime, startTime.val());
  function checkDates(changed, other, dateText) {
    if( other.val() && (new Date(startTime.val()) > new Date(endTime.val())) ) {
      other.val(dateText);
    }
  }
  selected(startTime, endTime, 'minDate');
  selected(endTime, startTime, 'maxDate');
  function selected(changed, other, option) {
    if( !$(changed).val() ) {
      return;
    }
    var date = $(changed)[method].call($(changed), 'getDate');
    // timepicker doesn't implement 'getDate' and returns a jQuery
    if( date.getTime ) {
      $(other)[method].call($(other), 'option', option, date);
    }
  }
  return $([startTime.get(0), endTime.get(0)]);
};

$.timepicker.version = "1.0.2";

})(jQuery);

/**
 * Wgt Tip, basierend auf dem jquery WgtTip Plugin Version version 1.0.0a
 * 
 * Die Klassen und Funktionsnamen wurden entsprechend der WGT Namenskonvention
 * angepasst um eine bessere Semantic und eine bessere Benutzbarkeit 
 * der Bibliothek zu erreichen.
 * 
 * Siehe doc/motivation_anpassungen.html
 */
// wgtTip, facebook style tooltips for jquery
// version 1.0.0a
// (c) 2008-2010 jason frame [jason@onehackoranother.com]
// releated under the MIT license
(function($) {
    
    function fixTitle($ele) {
        if ($ele.attr('title') || typeof($ele.attr('original-title')) != 'string') {
            $ele.attr('original-title', $ele.attr('title') || '').removeAttr('title');
        }
        if ($ele.attr('tooltip') || typeof($ele.attr('original-title')) != 'string') {
          $ele.attr('original-title', $ele.attr('tooltip') || '').removeAttr('tooltip');
        }
    }
    
    function WgtTip(element, options) {
        this.$element = $(element);
        this.options = options;
        this.enabled = true;
        fixTitle(this.$element);
    }
    
    WgtTip.prototype = {
        show: function() {
            var title = this.getTitle();
            if (title && this.enabled) {
                var $tip = this.tip();
                
                $tip.find('.wgt-tip-inner')[this.options.html ? 'html' : 'text'](title);
                $tip[0].className = 'wgt-tip'; // reset classname in case of dynamic gravity
                $tip.remove().css({top: 0, left: 0, visibility: 'hidden', display: 'block'}).appendTo(document.body);
                
                var pos = $.extend({}, this.$element.offset(), {
                    width: this.$element[0].offsetWidth,
                    height: this.$element[0].offsetHeight
                });
                
                var actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight;
                var gravity = (typeof this.options.gravity == 'function')
                                ? this.options.gravity.call(this.$element[0])
                                : this.options.gravity;
                
                var tp;
                switch (gravity.charAt(0)) {
                    case 'n':
                        tp = {top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                        break;
                    case 's':
                        tp = {top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                        break;
                    case 'e':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth - this.options.offset};
                        break;
                    case 'w':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width + this.options.offset};
                        break;
                }
                
                if (gravity.length == 2) {
                    if (gravity.charAt(1) == 'w') {
                        tp.left = pos.left + pos.width / 2 - 15;
                    } else {
                        tp.left = pos.left + pos.width / 2 - actualWidth + 15;
                    }
                }
                
                $tip.css(tp).addClass('wgt-tip-' + gravity);
                
                if (this.options.fade) {
                    $tip.stop().css({opacity: 0, display: 'block', visibility: 'visible'}).animate({opacity: this.options.opacity});
                } else {
                    $tip.css({visibility: 'visible', opacity: this.options.opacity});
                }
            }
        },
        
        hide: function() {
            if (this.options.fade) {
                this.tip().stop().fadeOut(function() { $(this).remove(); });
            } else {
                this.tip().remove();
            }
        },
        
        getTitle: function() {
            var title, $e = this.$element, o = this.options;
            fixTitle($e);
            var title, o = this.options;
            if (typeof o.title == 'string') {
                title = $e.attr(o.title == 'title' ? 'original-title' : o.title);
            } else if (typeof o.title == 'function') {
                title = o.title.call($e[0]);
            }
            title = ('' + title).replace(/(^\s*|\s*$)/, "");
            return title || o.fallback;
        },
        
        tip: function() {
            if (!this.$tip) {
                this.$tip = $('<div class="wgt-tip"></div>').html('<div class="wgt-tip-arrow"></div><div class="wgt-tip-inner"/></div>');
            }
            return this.$tip;
        },
        
        validate: function() {
            if (!this.$element[0].parentNode) {
                this.hide();
                this.$element = null;
                this.options = null;
            }
        },
        
        enable: function() { this.enabled = true; },
        disable: function() { this.enabled = false; },
        toggleEnabled: function() { this.enabled = !this.enabled; }
    };
    
    $.fn.wgtTip = function(options) {
        
        if (options === true) {
            return this.data('wgtTip');
        } else if (typeof options == 'string') {
            return this.data('wgtTip')[options]();
        }
        
        options = $.extend({}, $.fn.wgtTip.defaults, options);
        
        function get(ele) {
            var wgtTip = $.data(ele, 'wgtTip');
            if (!wgtTip) {
                wgtTip = new WgtTip(ele, $.fn.wgtTip.elementOptions(ele, options));
                $.data(ele, 'wgtTip', wgtTip);
            }
            return wgtTip;
        }
        
        function enter() {
            var wgtTip = get(this);
            wgtTip.hoverState = 'in';
            if (options.delayIn == 0) {
                wgtTip.show();
            } else {
                setTimeout(function() { if (wgtTip.hoverState == 'in') wgtTip.show(); }, options.delayIn);
            }
        };
        
        function leave() {
            var wgtTip = get(this);
            wgtTip.hoverState = 'out';
            if (options.delayOut == 0) {
                wgtTip.hide();
            } else {
                setTimeout(function() { if (wgtTip.hoverState == 'out') wgtTip.hide(); }, options.delayOut);
            }
        };
        
        if (!options.live) this.each(function() { get(this); });
        
        if (options.trigger != 'manual') {
            var binder   = options.live ? 'live' : 'bind',
                eventIn  = options.trigger == 'hover' ? 'mouseenter' : 'focus',
                eventOut = options.trigger == 'hover' ? 'mouseleave' : 'blur';
            this[binder](eventIn, enter)[binder](eventOut, leave);
        }
        
        return this;
        
    };
    
    $.fn.wgtTip.defaults = {
        delayIn: 0,
        delayOut: 0,
        fade: false,
        fallback: '',
        gravity: 'n',
        html: false,
        live: false,
        offset: 0,
        opacity: 0.8,
        title: 'title',
        trigger: 'hover'
    };
    
    // Overwrite this method to provide options on a per-element basis.
    // For example, you could store the gravity in a 'wgt-tip-gravity' attribute:
    // return $.extend({}, options, {gravity: $(ele).attr('wgt-tip-gravity') || 'n' });
    // (remember - do not modify 'options' in place!)
    $.fn.wgtTip.elementOptions = function(ele, options) {
        return $.metadata ? $.extend({}, options, $(ele).metadata()) : options;
    };
    
    $.fn.wgtTip.autoNS = function() {
        return $(this).offset().top > ($(document).scrollTop() + $(window).height() / 2) ? 's' : 'n';
    };
    
    $.fn.wgtTip.autoWE = function() {
        return $(this).offset().left > ($(document).scrollLeft() + $(window).width() / 2) ? 'e' : 'w';
    };
    
})(jQuery);


/* 
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */


(function( $S, $WGT ) {

  $S.widget( "wgt.treetable", {
 

    // These options will be used as defaults

    options: { 
      clear: null,
      border: 'wgt-border',
      prefixNode : 'n_',
      prefixChild : 'c_'
    },
 

    // Set up the widget
    _create: function() {

      if( !this.element.is( '.wgt_table' ) )
        this.element.addClass( 'wgt_table' );
      
      if( this.options.border )
        this.element.addClass( this.options.border );

    },

    // Set up the widget
    createTree: function() {

      var rows = this.element.find('tr');
      
      rows.each(function(){
        
         var classes = $S(this).prop('class');
      });
        
    },
 

    // Use the _setOption method to respond to changes to options

    _setOption: function( key, value ) {

      switch( key ) {

        case "clear":
          // handle changes to clear option

          break;

      }
 
      // In jQuery UI 1.8, you have to manually invoke the _setOption method from the base widget

      $.Widget.prototype._setOption.apply( this, arguments );
      // In jQuery UI 1.9 and above, you use the _super method instead
      this._super( "_setOption", key, value );

    },
 
    /* 
     * Use the destroy method to clean up any modifications your 
     * widget has made to the DOM
     */
    destroy: function() {

      $.Widget.prototype.destroy.call( this );
    }

  });

}( jQuery, $WGT ) );


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 * @passed http://www.jshint.com
 */
(function( $S, $G ) {
  
  "use strict";
  $S.widget( "wgt.grid", {
    
    /**
     * Array mit den Resize Elementen
     */
    dragBars: [],
    
    /**
     * Array mit den Head Cols
     */ 
    headCols: [],

    /**
     * Array mit den Head Cols
     */
    changedData: [],
    
    /**
     * Referenz auf die erste row im grid
     */
    firstRow: null,

    /**
     * Standard Options
     */
    options: {
      
      // technische Eigenschaften
      grid_class: 'wgt-grid', // Klasse für die Deklaration als Grid Element
      hpad: 0,                // Größe des Paddings im Heads ( sollte dynamisch errechnet werden )
      border: 'wgt-border',   // Klasse für den Element Rahmen
      body_height: 'large',   // Klasse für die Höhe des bodies
      body_resize_able: false,// flag ob der Databody resizeable ist
      cols_resize_able: true, // flag ob die Cols Resizeable sind
      select_able: false,     // flag ob die Einträge selektiert werden können

      // Editierbare Cells im Grid
      save_form: null,        // ID des Save Formulars bei editierbaren Tabellen
      edit_able: false,       // Flag ob
      allow_insert: false,    // Sollen neue Datensätze angelegt werden können
      
      // Sort Daten und Optionen
      icon_sort_asc:  'control/sort_asc.png',    // Icon für das absteigenden sortieren
      icon_sort_desc: 'control/sort_desc.png',   // Icon für das aufsteigenden sortieren
      icon_sort_none: 'control/sort_none.png',   // noch nicht sortiert
      
      // Layout
      color_scheme: null,     // Klasse für das Farbschema
      
      // Eigenschaften für die Suchleiste
      search_able: false,     // flag ob die Einträge selektiert werden können
      search_form: null,      // ID des Suchformulars / Paging / Datenquelle
      
      // Treeeigenschaften des Grids
      expandable: false       // Flag ob der Baum colapsable ist 
    },
 

    /**
     * Setup / Constructor methode des Widgets
     */
    _create: function() {
        
      var self = this;
      
      this.element.appear(function(){
        self.buildGrid();
      });

    },//end _create
    
    /**
     * Die Standardmethode in welcher eine normale Tabelle zum Gridelement
     * umgebaut wird
     */
    buildGrid: function(){
      
      var self = this,
        ge = this.element,
        opt = this.options,
        gridBody = null,
        oldHCols = ge.find('thead th'), // der original head
        headTab   = "<div class=\"wgt-grid-head\" ><div><table><thead><tr>", // start des neuen heads
        searchBox = '', // Box mit den Suchelementen, wird nur bei Bedarf gefüllt
        resizeBox = '<div class="wgt-drag" >', // die Box mit den resize elementen
        sizes = []; // liste mit den größen
        
      // setzen der Grid Basisklasse wenn noch nicht vorhanden
      if( !ge.hasClass( opt.grid_class ) ){
        ge.addClass( opt.grid_class );
      }
      
      // Einträge Selektiebar machen
      if( opt.select_able ){  
        this.makeSelectable( ge );
      }
        
      if( opt.search_able ){
        searchBox += '<tbody><tr>';
      }

      // die tabelle wird mit dem grid element umrahmt
      ge.wrap('<div class="wgt-grid-body '+opt.height+'" id="'+ge.attr('id')+'-body" />');

      gridBody = $S( '#'+ge.attr('id')+'-body' );

      // erstellen einer head zeile + resize bar pro alter col
      oldHCols.each( function(){
        var cNode = $S(this);
        var tmpWidth = this.clientWidth;

        headTab += self.renderHeadCell( this, cNode, tmpWidth , opt  );

          
        // anhängen der Search Col
        if( opt.search_able ){
          searchBox += self.renderSearchCell( cNode, tmpWidth, opt  );
        }
        
        resizeBox += '<div></div>';
        sizes.push( tmpWidth );
        
      });
      
      // schliesen des heads
      headTab += "</tr></thead>";
      headTab += "</table></div></div>";
      
      if( opt.search_able ){
        searchBox += '</tr></tbody>';
      }
      
      // schliesen der resize box
      resizeBox += '<div class="helper" ></div></div>';
      
      // Sortierelemente im Head anhängen
      var jHeadTab = $S(headTab);
      
      // anhängen der Searchbar wenn gewünscht
      if( opt.search_able ){
        jHeadTab.find('table').append(searchBox);
      }
      
      this.injectSortControls( jHeadTab );
      
      
      // den neuen kopf sowie die resize box vor die tabelle kopieren
      ge.parent().wrap( '<div class="body-scroll">' );
      ge.parent().before(jHeadTab);
      ge.parent().before(resizeBox);
      
      // store the head
      var headBar = ge.parent().parent().find('.wgt-grid-head');
      var headOff = headBar.position();
      
      var tbodyHeight = ge.parent().height() + headBar.height();
      
      // add the scroll events
      var tmpBox    = ge.parent();
      var scrolling = false;
      tmpBox.get(0).onscroll = function(){
        scrolling = true;
        headBar.scrollLeft(this.scrollLeft);
      };
      
      tmpBox.mouseup(function(){
        
        // only execute after scrolling
        if( scrolling ){
          
          self.recalcXPosDragHelper();
          scrolling = false;
        }
      });
      
      // all drag helper divs
      this.dragBars = ge.parent().parent().find('div.wgt-drag>div');
      
      // the content boxes of the head
      this.headCols = headBar.find('th>div');
        
      // the first Row
      this.firstRow = ge.find('thead th');
      
      // Resize für das Grid implementieren
      var helper    = ge.parent().parent().find('div.wgt-drag>div.helper');
      
      helper.css({top:headOff.top})
        .height(tbodyHeight+'px')
        .hide();
      
      gridBody.scroll( function(){

        var gof = gridBody.get(0);
        
        headBar.css( 'marginLeft', '-'+gof.scrollLeft+'px' );
        ge.parent().parent().find('div.wgt-drag').css( 'marginLeft', '-'+gof.scrollLeft+'px' );

        
        console.log('scroll '+gof.scrollLeft+'  '+gof.scrollTop);
      });
      
      this.firstRow.each( function( idx ){
        
        var actualCol    = $S(this);
        var actualHead   = $S( self.headCols.get(idx) );
        
        var cWidth = actualHead.outerWidth();
        
        actualCol.width(cWidth);
        var nextPos = actualHead.outerWidth()+actualHead.offset().left-2;
  
        
        // store the position on drag start
        var startPos = null;
        var mover    = null;
        
        $S( self.dragBars.get(idx) )
          .css( {top:headOff.top} )
          .offset( {left:nextPos} )
          .height( tbodyHeight+'px' )
          .draggable({ 
            axis: "x",
            start: function( event, ui ){
              mover = $S(this);
              
              if( idx === 0 ){
                startPos = 0;
              }
              else{
                startPos = $S( self.dragBars.get(idx-1) ).position().left;
              }
              
            },
            drag: function( event, ui ){
              
              /*
              var newPos = mover.position().left;
              
              // min size of a column is 50px
              if( (newPos-startPos) <= 57 )
              {
                var tmpPos = 60 + actualHead.offset().left-2;
                mover.addClass('dissabled');
                helper.show();
                helper.offset({left:tmpPos});
              }
              else
              {
                mover.removeClass('dissabled');
                helper.hide();
              }
              */
              
            },
            stop: function(){
              
              //var tw     = actualCol.width();
              //var mover  = $S(this);
              var newPos  = mover.position().left;
              var oldWith = actualCol.outerWidth();
              
              var newWidth = (newPos-startPos);
              if( newWidth<=40 && !actualCol.hasClass('pos') ) {
                
                newWidth = 40;
                mover.offset( {left:actualHead.offset().left-40} );
              }
              
              if( actualCol.hasClass('pos') ) {
                
                newWidth = 30;
                mover.offset( {left:actualHead.offset().left-30} );
              }
              
              actualCol.width(newWidth);
              
              var tmpNewW = ge.outerWidth()+(newWidth-oldWith)+opt.hpad;
              
              ge.width( tmpNewW );
              self.syncColWidth();

              /*
              actualHead.width(newWidth);
              actualCol.width(actualHead.outerWidth());
              */
              
              self.recalcXPosDragHelper();
            }
          });
        
      });
      
      // nach dem Init nocheinmal sicher stellen das ResizeBars und Size
      // auch in sync sind
      self.syncColWidth();

      if( opt.edit_able ){
        self.startEditMode();
      }
      
    },//end buildGrid

    /**
     * Das Grid Element Editierbar machen
     */
    startEditMode: function(){

      var el = this.element;
      var editLayers = $S('.wgt-editlayer');

      el.click(function( e ){

        var cTarget =  $S(e.target);
        if( cTarget.is('td') ){

          var ofs = cTarget.offset();
          var oW  = cTarget.outerWidth();
          var oH  = cTarget.outerHeight();

          var type = $G.$WGT.getClassByPrefix( cTarget.prop('class'), 'type_' );

          var editLayer = $S('#wgt-edit-field-'+type);

          console.log( cTarget.parentX('table').css('margin-top')+' type '+type+' '+cTarget.prop('class') );

          editLayers.unbind('blur');
          editLayers.hide();

          editLayer.css({
            left:ofs.left,
            top:ofs.top,
            width:oW,
            height:oH
          });

          editLayer.show();
          editLayer.focus();

          if( 'date' === type ){
            editLayer.find('input').val(cTarget.html());
          }
          else{
            editLayer.html( cTarget.html() );
          }

          editLayer.blur(function(){
            if( 'date' === type ){
              cTarget.html( editLayer.find('input').val() );
            }
            else{
              cTarget.html( editLayer.html() );
            }
          });
          
          //editLayer.selection( 0, editLayer.text().length );

          if( 'date' === type ){
            editLayer.find('input').datepicker('show');
          }


        }

      });

    },
    
    /**
     * Berechnen der korrekten position für die Drag Bar Elemente
     * Werden für das Resizing der Cols benötigt
     */
    recalcXPosDragHelper: function(){
      
      var self = this;
      
      ///@todo hier brauchen wir dringend ne fehlerbehandlung
      if( this.headCols ){
        
        this.headCols.each(function (idx){
          
          var actualHead   = $S(self.headCols.get(idx));
          var mover        = $S(self.dragBars.get(idx));
          var tmpPos = actualHead.outerWidth()+actualHead.offset().left-2;
          mover.offset({left:tmpPos});
          /*
          mover.removeClass('dissabled');
          helper.hide();
          */
        });
      }
    },//end recalcXPosDragHelper
    
    /**
     * Injizieren der Sortelements in den Tabellenhead
     */
    injectSortControls: function( jHeadTab ){
      
      var opt = this.options;
        
      jHeadTab.find('img').each( function(){
        
         var imgNode = $S(this);
         
         imgNode.bind("click.grid", function() {

          var nIcon = $S(this);
          var pIcon = nIcon.parent();

          if( pIcon.hasClass('sort-asc') ){
            pIcon.removeClass('sort-asc').addClass('sort-desc');
            nIcon.attr( 'src', $G.$C.WEB_ICONS+"xsmall/"+opt.icon_sort_desc );
            nIcon.next().val('desc').change();
          }
          else if( pIcon.hasClass('sort-desc') ){
            pIcon.removeClass('sort-desc');
            nIcon.attr( 'src', $G.$C.WEB_ICONS+"xsmall/"+opt.icon_sort_none );
            nIcon.next().val('').change();
          }
          else{
            pIcon.addClass('sort-asc');
            nIcon.attr( 'src', $G.$C.WEB_ICONS+"xsmall/"+opt.icon_sort_asc );
            nIcon.next().val('asc').change();
          }

        });
      });
      
      jHeadTab.find('input.wcm_req_search,select.wcm_req_search').each(function(){
        $G.$R.callAction( 'req_search', $S(this) );
      });

    },//end injectSortControls
    
    /**
     * Sc
     * @param cNode jQuery jQuery Object des th nodes
     * @param tmpWidth int Weite der aktuellen col
     * @param opt Object Options Object
     */
    renderSearchCell: function( cNode, tmpWidth, opt  ){
      
      var searchBox = '';
      var searchName = cNode.attr('wgt_search');
          
      if( searchName ){

        var tmp   = searchName.split(':');
        var sType = '';
        var sName = '';

        if( 2 === tmp.length ){
          sType = tmp[0];
          sName = tmp[1];
          
        }
        else{
          sType = 'text';
          sName = searchName;
          
        }

        searchBox += '<td style="width:'+(tmpWidth-opt.hpad)+'px;text-align:center;" >';
        searchBox += '<input type="'+sType+'" name="'+sName+'" class="wcm wcm_req_search search wgt-no-save fparam-'+opt.search_form+'" style="width:100%" />';
        searchBox += '</td>';
      }
      else{
        
        searchBox += '<td style="width:'+(tmpWidth-opt.hpad)+'px;text-align:center;" ><span>&nbsp;</td>';
        
      }
      
      return searchBox;

    },//end renderSearchCell
    
     /**
     * Render einer Head Label Cell bei Bedarf mit Order Feld
     * 
     * @param node DOMNode
     * @param cNode jQuery of DOMNode
     * @param tmpWidth int
     * @param opt Object Options Object
     */
    renderHeadCell: function( node, cNode, tmpWidth, opt  ){
    
      var nodeName  = cNode.attr('wgt_sort_name'),
        headTab   = '',
        tmpNewWdth = null;
      
      if( nodeName ){

        var sortIcon  = opt.icon_sort_none;
        var sortClass = '';
        var sortVal   = '';

        var sortDir  = cNode.attr('wgt_sort');
        if( sortDir ){

          sortIcon  = opt['icon_sort_'+sortDir] === undefined? opt.icon_sort_none: opt['icon_sort_'+sortDir] ;
          sortClass = ' sort-'+sortDir;
          sortVal   = sortDir;
        }

        tmpNewWdth = tmpWidth-opt.hpad;
        headTab += "<th style=\"width:"+tmpNewWdth+"px;\" orig_width=\""+tmpNewWdth+"\" ><div style=\"width:"+tmpNewWdth+"px;\" >";
        headTab += "<p class=\"label\" >"+node.innerHTML+"</p>";
        headTab += "<p class=\"order"+sortClass+"\" >";
        headTab += "<img src=\""+$G.$C.WEB_ICONS+"xsmall/"+sortIcon+"\"  alt=\"Sort\"  class=\"icon xsmall\" />";
        headTab += '<input type="hidden" name="'+nodeName+'" value="'+sortVal+'" class="wcm wcm_req_search wgt-no-save fparam-'+opt.search_form+'" />';
        headTab += "</p>";
        headTab += "</div></th>";
        
      } 
      else{
        
        tmpNewWdth = tmpWidth-opt.hpad;
        headTab += "<th style=\"width:"+tmpNewWdth+"px;\" orig_width=\""+tmpNewWdth+"\" ><div style=\"width:"+tmpNewWdth+"px;\" ><p class=\"label\" >"+node.innerHTML+"</p></div></th>";
      }

      return headTab;

    },//end renderHeadCell
    
    /**
     * Die Listeneinträge selektierbar machen
     * Diese Funktion ermöglicht es primär die rows mit wgt-selected zu tagen
     * Wie diese Information verwendet wird ist in der spezifischen Logik
     * der Multi Action zu definieren.
     */
    makeSelectable: function( lElem ){
      
      lElem.find('tbody>tr')
        .mouseover( function(){

          $S(this).addClass('wgt-hover'); 
        })
        .mouseout(function(){

          $S(this).removeClass('wgt-hover'); 
        })
        .click(function(){

          $S(this).toggleClass( 'wgt-selected' );
        });

    },//end makeSelectable

    /**
     * Synchronisation von Head und Body Breite
     */
    syncColWidth: function(){

      var self = this;
      
      if( this.firstRow ){
        
        this.firstRow.each(function(idx){
          
          var actualCol  = $S(this);
          var actualHead = $S(self.headCols.get(idx));
          
          var cWidth = actualCol.outerWidth();
          var newWidth = cWidth-(self.options.hpad+1);
          actualHead.width( newWidth ).parent().width( newWidth );
          //actualHead.width(cWidth-15);
  
        });
      }

      this.recalcXPosDragHelper();

    },
    
    /**
     * Grid als Treetable darstellen
     */
    treeMode: function( ){
      
      //if( undefined === this.options.expandable )
        //this.options.expandable = false; // quick fix
      
      this.element.treeTable(this.options);
    },
    
    /**
     * Neu hinzugekommene Einträge in den Baum integrieren
     */
    refreshTree: function( ){
      
      //if( undefined === this.options.expandable )
        //this.options.expandable = false; // quick fix
      
      this.element.treeTable(this.options);
    },
    
    /**
     * Colobject für eine bestimmte Col erfragen
     */
    getCol: function( colId ){
      
      return new WgtUiCol( this , colId );
      
    },

    /**
     * Grid im Browser sortieren ohne Refresh vom Server
     * 
     * @param colId int, the numeric index of the col
     * @param params Object, named params array
     */
    sort: function( colId, params ){

      if( params === undefined ){
        params = {};
      }

      if( params.sort === undefined ){
        params.sort =  this.getOrderByFromCol(colId, true);
      }
      else{
        params.sort = 'sort_'+params.sort;
      }

      var sortKeys  = [];
      var rows      = this.element.find( 'tbody > tr' );

      rows.each(function() {
         var tmp = $S(this).find('td').get(colId);
         tmp = $S(tmp).text().toUpperCase();
         sortKeys.push( [tmp , this] );
      });

      sortKeys.sort();
      if( params.sort === 'sort_desc' ) {
        sortKeys.reverse();
      }

      for( var pos = 0; pos < sortKeys.length; pos++ ){
        this.element.append(sortKeys[pos][1]);
      }
      
      this.reColorize();

    },//end this.sort

    /**
     * @param colId int, the numeric index of the col
     * @param input Object, named params array
     */
    filter: function( colId , input  ){

      var rows  = this.element.find( 'tbody > tr' );
      var reg   = new RegExp("("+escapearg(htmlspecialchars(input.toUpperCase()))+")",'g');

      rows.each(function(){
        
        var row = $S(this);
        var col = row.find('td').get(colId);
        if( reg.test( $S(col).text().toUpperCase() ) ){
          row.show();
        }
        else{
          row.hide();
        }
      });

      this.reColorize();

    },//end this.filter

    
    /**
     * Inkrementieren der Anzahl gelisteter Einträge
     */
    incEntries: function(){

      var fNum = this.element.parent().parent().parent().find('.wgt-num-entry');

      if( !fNum.length ){
        return;
      }
      
      var numVal = Number(fNum.text());
      ++numVal;
      fNum.text(numVal);
      
    },//end incEntries
    
    /**
     * Dekrementieren der Anzahl gelisteter Einträge
     */
    decEntries: function(){

      var fNum = this.element.parent().parent().parent().find('.wgt-num-entry');

      if( !fNum.length ){
        return;
      }
      
      var numVal = Number(fNum.text());
      --numVal;
      fNum.text(numVal);

    },//end decEntries
    
    /**
     * Setzen der Anzahl gelisteter Einträge
     */
    setNumEntries: function(num){

      var fNum = this.element.parent().parent().parent().find( '.wgt-num-entry' );

      if( !fNum.length ){
        console.log('Did not find wgt-num-entry');
        return;
      }

      fNum.text(num);

    },//end setNumEntries

    /**
     * Toggle Body
     */
    toggle: function( ){

      this.element.find('tbody').toggle();
      
    },//end this.toggle

    /**
     */
    cleanFilter: function( ){

      var rows  = this.element.find( 'tbody > tr' );
      rows.each(function(){
        $S(this).show();
      });

      this.reColorize();
    },//end this.cleanFilter

    /**
     * @param colId
     * @param changeIcon
     */
    getOrderByFromCol: function( colId, changeIcon ){

      if( changeIcon === undefined ){
        changeIcon = false;
      }

      var sort  = null;
      var tmp   = this.element.find('thead').find('th');

      if( tmp.length !== 0 ){

        var colHead = $S(tmp.get(colId));
        var classes = colHead.prop('class');

        if( classes.indexOf('sort_asc') !== -1 ) {
          sort = 'sort_desc';
          if( changeIcon ) {
            colHead.removeClass('sort_asc');
            colHead.addClass('sort_desc');
            colHead.find('img').attr('src', $G.$C.iconSortAsc );
          }
        }
        else if( classes.indexOf('sort_desc') !== -1 ) {
          sort = 'sort_asc';
          if( changeIcon ) {
            colHead.removeClass('sort_desc');
            colHead.addClass('sort_asc');
            colHead.find('img').attr('src', $G.$C.iconSortDesc );
          }
        }
        else {
          sort = 'sort_asc';
          if( changeIcon ) {
            colHead.addClass('sort_asc');
            colHead.find('img').attr('src',  $G.$C.iconSortDesc );
          }
        }

        return sort;

      }
      else{
        
        return 'sort_asc';
      }

    },//end this.getOrderByFromCol

    /**
     *
     */
    reColorize: function(){

      var rows = this.element.find( 'tbody > tr' ).not('.wgt-block-appear');
      var fact = 3;
      var pos = 2;
      
      var oldNode = $G.$WGT.getClassByPrefix( $S(rows.get(0)).prop('class'), 'node-', false  );
      
      rows.each(function(){

        var row = $S(this);
        row.removeClass('row1').removeClass('row2');
        
        var nodeKey = $G.$WGT.getClassByPrefix( row.prop('class'), 'node-', false  );
        
        if( nodeKey !== oldNode ){

          row.find('td.pos').text(pos);
          oldNode = nodeKey;
          ++fact;
          ++pos;
        }
        
        row.addClass('row'+((fact%2)+1));

      });

      
    },//end this.reColorize
    
    // _setOptions is called with a hash of all options that are changing
    // always refresh when changing options
    _setOptions: function() {
      // in 1.9 would use _superApply
      $S.Widget.prototype._setOptions.apply( this, arguments );
      this._refresh();
    },

    // Use the _setOption method to respond to changes to options
    /**
     *
     */
    _setOption: function( key, value ) {

      $S.Widget.prototype._setOption.apply( this, arguments );
      // In jQuery UI 1.8, you have to manually invoke the _setOption method from the base widget
      //$.Widget.prototype._setOption.apply( this, arguments );
      
      // In jQuery UI 1.9 and above, you use the _super method instead
      //this._super( "_setOption", key, value );

    },
 
    // called when created, and later when changing options
    _refresh: function() {

      // trigger a callback/event
      this._trigger( "change" );
    },

    /**
     * Use the destroy method to clean up any modifications your 
     * widget has made to the DOM
     */
    destroy: function() {

      $S.Widget.prototype.destroy.call( this );
    },//end destroy
    

    /**
     * @param formId
     * @param element
     * @deprecated wird über wcm + forms geregelt
     */
    pageSize: function( formId, element  ){

      $S('form#'+formId).data('qsize',$S(element).val());
      $S('form#'+formId).data('start',0);

      $G.$R.form(formId);

    },//end this.pageSize
    
    /**
     * @param formId
     * @param element
     * @deprecated wird über wcm + forms geregelt
     */
    search: function( formId, element ){

      $S('form#'+formId).data('qsize',$S(element).val());
      $S('form#'+formId).data('start',0);

      $G.$R.form(formId);

    }//end this.search

  });
  
  /**
   * @param pTab
   * @param pColId
   */
  function WgtUiCol( pTab , pColId ){

    var tabObj    = pTab,
      colIndex = null;

    if( typeof pColId === 'number' ){
      colIndex  = pColId;
    }
    else{
      colIndex  = pColId.index();
    }

    /**
     * @return WgtUiTable
     */
    this.getTable = function(){
      return tabObj;
    };

    /**
     * @param direction
     */
    this.sort = function( direction ){
      return tabObj.sort( colIndex, {sort:direction} );
    };

    /**
     * @param userInput
     */
    this.filter = function( userInput ){
      return tabObj.filter( colIndex, userInput  );
    };

    /**
     *
     */
    this.cleanFilter = function(){
      return tabObj.cleanFilter( colIndex  );
    };

  }//end function WgtUiCol */

}( jQuery, window ) );


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
(function( $S ) {

  $S.widget( "wgt.content_map", {
    
    /**
     * das map element
     */
    container: null,

    /**
     * flag ob der Content verschoben werden können soll
     */
    moveBg: true,
    
    /**
     * flag ob der Content verschoben werden können soll
     */
    moveBgCheck: false,
    
    /**
     * 
     */
    actX: -4625,
    
    /**
     * 
     */
    actY: -4625,

    /**
     * 
     */
    startX: 0,
    
    /**
     * 
     */
    startY: 0,

    /**
     * 
     */
    centerX: -4625,
    
    /**
     * 
     */
    centerY: -4625,
    
    /**
     * Content Size X
     */
    cs_x: 720,
    
    /**
     * Content Size Y 
     */
    cs_y: 750,
    
    /**
     * Content Border
     */
    cb : 20,
    
    /**
     * Content Border
     */
    scroll_v : false,

    /**
     * Standard Options
     */
    options: { 
      // technische Eigenschaften
      container_x: 10000,
      container_y: 10000,
      content_x:750,
      content_y:750
    },
 

    /**
     * Setup / Constructor methode des Widgets
     */
    _create: function() {
        
      var opt = this.options;
      
      this.actX = this.centerX = 0-((opt.container_x - opt.content_x)/2);
      this.actY = this.centerY = 0-((opt.container_y - opt.content_y)/2);

      this.initEvents();
      
      return this;

    },//end _create
    
    /**
     * Die Standardmethode in welcher eine normale Tabelle zum Gridelement
     * umgebaut wird
     */
    initEvents: function(){

      var self = this,
          cont = this.element.find('.wgt-graph_body');

      var moveEvent = function( e ){

       if( !self.moveBg )
        return;

        //console.log("map mousemove move");

        cont.css( 'marginLeft', self.actX - ( self.startX - e.pageX ) );
        cont.css( 'marginTop', self.actY - ( self.startY - e.pageY ) );

      };

      cont.bind( 'mousedown.bscroll', function( e ){
          
        //console.log("content map mousedown");

        if( !self.moveBg )
          return;
        
        self.moveBgCheck = true;
        
        //console.log("map mousedown move");
        
        self.scroll_v = true;
        
        self.startX = e.pageX;
        self.startY = e.pageY;

        cont.bind( 'mousemove.bscroll', moveEvent );

      }).bind( 'mouseup.bscroll',  function( e ){
        
       //console.log("content map mouseup");

       if( !self.moveBg || !self.moveBgCheck )
        return;
      
      
       
       self.scroll_v = false;
    
       self.actX = self.actX - ( self.startX - e.pageX );
       self.actY = self.actY - ( self.startY - e.pageY );
        
       self.moveBgCheck = false;
       //console.log("map mouseup move");

       cont.unbind( 'mousemove.bscroll' );
     });
      
     cont.bind('mousewheel', function(event, delta) {
       
       var dir = delta > 0 ? 'Up' : 'Down',
           vel = Math.abs(delta);
       
       //cont.css( 'marginLeft', self.actX - ( self.startX - e.pageX ) );
       if( !self.scroll_v ){
         
         self.actY = (delta > 0) 
           ? self.actY + (vel * 30)
           : self.actY - (vel * 30);
         
         cont.css( 'marginTop', self.actY );
       }
       else{
         
         self.actX = (delta > 0) 
         ? self.actX + (vel * 30)
         : self.actX - (vel * 30);
       
         cont.css( 'marginLeft', self.actX );
       }

       return false;
     });
      
    },//end initEvents
  

    /**
     * Den Editor zum Center bewegen
     */
    moveToCenter: function(){
      
      this.actX = this.centerX;
      this.actY = this.centerY;
       
      this.container.css( 'marginLeft', this.centerX );
      this.container.css( 'marginTop', this.centerY );

    },//end moveToCenter

    injectInstance: function( parentNode ){
      parentNode.container = this;
    }
    
  });

}( jQuery ) );


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
(function( $S ) {

  $S.widget( "wgt.process_editor", {
    
    /**
     * Das Graph Element
     */
    container: null,
    
    /**
     * Node Elements
     */ 
    nodes: {},
    
    /**
     * Alle edges
     */ 
    edges: {},
    
    /**
     * Liste mit den reder objekten für die Connectoren / Arrows
     */
    arrows: {},

    /**
     * Standard Options
     */
    options: { 
    },
    
    /**
     * Die ID des aktuell gehighligtheten nodes
     */
    highlightedNode: null,
 

    /**
     * Setup / Constructor methode des Widgets
     */
    _create: function() {
        
      $S(this.element).content_map();
      $S(this.element).content_map('injectInstance',this);
      
      console.log( 'Container ID '+this.container.element.attr('id') );
      
      this.initEditor();

    },//end _create
    
    /**
     * Die Standardmethode in welcher eine normale Tabelle zum Gridelement
     * umgebaut wird
     */
    initEditor: function(){
      
      var el = this.element,
        cont = this.container,
        contId = this.container.element.attr('id'),
        nodes = {},
        edges = {},
        self = this;  
        
      //console.log( "Init Editor" );
      
      // moveable als dragable nodes definieren
      jsPlumb.draggable(jsPlumb.getSelector( "div.node.moveable" ));
      
      // erstellen der render nodes
      this.arrows['forward'] = jsPlumb.getInstance({
        Endpoint:[ "Blank", {fillStyle:"gray"}],
        PaintStyle:{strokeStyle:"#D2FFD2", lineWidth:0.8}
      });
      
      this.arrows['forward_high'] = jsPlumb.getInstance({
        Endpoint:[ "Blank", {fillStyle:"gray"}],
        PaintStyle:{strokeStyle:"#008000", lineWidth:0.8}
      });

      this.arrows['back'] = jsPlumb.getInstance({
        Endpoint:[ "Blank", {fillStyle:"gray"}],
        PaintStyle:{strokeStyle:"#FFD6D6", lineWidth:0.8}
      });
      

      this.arrows['back_high'] = jsPlumb.getInstance({
        Endpoint:[ "Blank", {fillStyle:"gray"}],
        PaintStyle:{strokeStyle:"#C00000", lineWidth:0.8}
      });
      
      var pos = 0;
      var baseLines = 3; 
      var indexSize = 5
      var vertBSpace = 80; 
      
      // baseline index
      var bsIndex = {"l1":(cont.cs_x/2)};
      
      for( var idx = 2; idx <= baseLines; ++idx ){
        
        var bsIndTmpKey = idx*2;
        
        var bsIdx1 = (indexSize + 2) - (bsIndTmpKey -1),
            bsIdx2 = (indexSize + 2) - (bsIndTmpKey -2);          
        
        bsIndex['l'+bsIdx1] = Math.round( 0 + (cont.cs_x/(idx+1)) );
        bsIndex['l'+bsIdx2] = Math.round( cont.cs_x - (cont.cs_x/(idx+1)) );
        
        console.log( "baseline: "+bsIdx1+" "+bsIndex['l'+bsIdx1]+" "+bsIdx2+" "+bsIndex['l'+bsIdx2] );
        
      }
      
      // verarbeiten der Nodes
      var processNodes = el.find('.node');
      
      processNodes.each(function(){

        var node = $S(this);

        node.mousedown(function(){
          
          cont.moveBg = false;
        }).mouseup(function(){
          
          cont.moveBg = true;
        });

        if( node.hasClass('pos_auto') ){
          
          var blIndex    = pos%indexSize;
          var nodeWidth  = node.width();

          var posNodeX = ( ( bsIndex['l'+(blIndex+1)] - (nodeWidth/2) ) - cont.centerX );
          var posNodeY = ( ( pos*vertBSpace) + cont.cb ) - cont.centerY;
          
          //console.log( "Auto node pos "+posNodeX+"x"+posNodeY+" idx: "+blIndex  );
            
          var offset = node.offset();
          node.offset({
            top: (offset.top + posNodeY), 
            left: (offset.left + posNodeX) 
          });
          
          //var offset = node.offset();
          //console.log( "Auto node pos "+posNodeX+"x"+posNodeY+" idx: "+blIndex+" Top: "+offset.top+" Left: "+offset.left   );
          
          ++pos;
          
        }
        else{
          
          var offset = node.offset();
          node.offset({top: (offset.top - cont.actX), left: (offset.left - cont.actY)});
        }

        nodes[node.attr('id')] = {"j":node,"g":jsPlumb.addEndpoint( node.attr('id') )};

      });
      
      // rendern der Edges
      $S.each( nodes, function( key, node ){

        var cfgData = node['j'].find('var');
        var settings = cfgData.is('var')
          ? $WGT.robustParseJSON(cfgData.text())
          : {};

        // hinzufügen des node klick elements
        node['j']
        .mousedown(function(event){
          
          console.log("node mousedown");
          cont.moveBg = false;
          event.stopPropagation();
        })
        .mouseup(function(event){
          
          console.log("node mouseup");
          cont.moveBg = true;
          event.stopPropagation();
        })
        .click(function( event ){
            
          self.highLightEdges(key);
            
          processNodes.removeClass('checked');
          node['j'].addClass('checked');
            
          var uForm = $S('#'+contId+'-uform');
          uForm.find('div.node_entry').hide();
          uForm.find('div#'+contId+'-info-'+settings.key).show();
          
          uForm.find('div:first').accordion( "activate",1);

          event.stopPropagation();

          //console.log( settings.label+" "+settings.phase_label );
        });

        edges[key] = {};
          
        $S.each(settings['edges'],function( index, value ){

          var conSet = { 
            source:key, 
            target:contId+'-n-'+value.target,
            overlays:[ 
              "Arrow", 
              [ "Label", {label:value.label, location:0.25, cssClass:"wgt_path_label"} ]
            ]
          };

          var con = null;
          conSet.dir = value.dir;
          conSet.eClick = function( conn ) {

            if( conn.isDetachable() ){
              console.log("clicked on detachable "+contId+'-n-'+value.target);
            }
            else{
              console.log("clicked on non detachable "+contId+'-n-'+value.target);
            }
            jsPlumb.detach( conn );
          };

          if( 'forward' == value.dir ){

            conSet.anchor = 'RightMiddle';
            con = self.arrows['forward'].connect( conSet );
            con.bind( "click", conSet.eClick );
            
          }
          else{

            conSet.anchor = 'LeftMiddle';
            con =  self.arrows['back'].connect( conSet );
            con.bind( "click", conSet.eClick );
          }
          
          node['g'].addConnection( con );
          edges[key][value.target] = {"conSet":conSet,"edge":con} ;

        });
        
        
      
     }); /**/
     
     // nodes speichern
     this.nodes = nodes;
     this.edges = edges;

    },//end buildGrid
    
    /**
     * Methode zum entfernen der Verbindungen zu einem knoten
     * @param nodeId key des nodes dessen connections entfernt werden sollen
     */
    detachNodeEdges: function( nodeId ){
      

      console.log( "detach node "+nodeId );

      $S.each( this.edges[nodeId], function( key, con ){
        console.log( "detach connection "+key+" "+con.sourceId + " to " + con.targetId );
        
        jsPlumb.detach( { source:con.sourceId, target:con.targetId } );
        
        con = self.arrows['forward'].connect( con.conSet );
        
        this.edges[nodeId][key] = null;
        
        //jsPlumb.detach(con); 
      }); 
      
      // edges leeren
      //this.edges[nodeId] = {};
      
    },//end detachNodeEdges

    /**
     * Methode zum entfernen der Verbindungen zu einem knoten
     * @param nodeId key des nodes dessen connections entfernt werden sollen
     */
    highLightEdges: function( nodeId ){
      
      var self = this;
      
      if( self.highlightedNode ){
        
        if( self.highlightedNode == nodeId )
          return;
        
        $S.each( this.edges[self.highlightedNode], function( key, con ){

          jsPlumb.detach( { source:con.edge.sourceId, target:con.edge.targetId } );
          
          con.conSet['overlays'][1][1]['cssClass'] = "wgt_path_label";

          con.edge = self.arrows[con.conSet.dir].connect( con.conSet );
          con.edge.bind( 'click', con.conSet.eClick );

          self.edges[self.highlightedNode][key] = con;
          self.nodes[self.highlightedNode]['g'].addConnection( con.edge );

          //jsPlumb.detach(con); 
        });
        
      };
    
      self.highlightedNode = nodeId;

      $S.each( this.edges[nodeId], function( key, con ){
        console.log( "detach connection "+key+" "+con.edge.sourceId + " to " + con.edge.targetId );
        
        jsPlumb.detach( { source:con.edge.sourceId, target:con.edge.targetId } );
    
        con.conSet['overlays'][1][1]['cssClass'] = "wgt_path_label_high";
    
        con.edge = self.arrows[con.conSet.dir+'_high'].connect( con.conSet );
        con.edge.bind( 'click', con.conSet.eClick );

        self.edges[nodeId][key] = con;
        self.nodes[nodeId]['g'].addConnection( con.edge );
        
        //jsPlumb.detach(con); 
      }); 
      
      // edges leeren
      //this.edges[nodeId] = {};
      
    }//end detachNodeEdges

  });

}( jQuery ) );


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.de>
 * 
 * todo:
 * 
 * context menü 
 *  - löschen aller tags
 *  - neu vom server laden
 * 
 * autocomplete beim hinzufügen von tags
 * 
 */
(function( $S ) {

  $S.widget( "wgt.tagCloud", {


    /**
     * Standard Options
     */
    options: { 
      // technische Eigenschaften
      c_class: 'wgt-tag_cloud', // css klasse des Tag containers
      t_class: 'tag',           // css klasse auf dem tag
      
      refid:   null,            // css klasse auf dem tag
      
      url_auto_complete: null,  // url für tag autocompletion
      url_tag_create: null,     // url zum erstellen und verknüpfen eines neuen tags
      url_tag_disconnect: null, // url zum löschen einer Tag verknüpfung
      
      call_tag_delete: function(){}, // callback welcher on tag delete aufgerufen wird
      call_tag_click: null
    },
 

    /**
     * Setup / Constructor methode des Widgets
     */
    _create: function() {

      this.initEvents();
      
      return this;

    },//end _create
    
    /**
     * Die Standardmethode in welcher eine normale Tabelle zum Gridelement
     * umgebaut wird
     */
    initEvents: function(){

      var self = this,
          opts = this.options,
          el   = this.element,
          cont   = this.element.find('.content'),
          tags = this.element.find( '.'+opts.t_class );
        
      
      if( !el.hasClass( opts.c_class ) )
        el.addClass( opts.c_class );

      this.bindTagEvent( tags, opts );
      this.initAddTagInput( el, opts, cont );
      
    },
    
    initAddTagInput: function( el, opts, cont ){
      
      var self = this;
        
      if( opts.url_tag_create && opts.refid ){
        el.find('.c_cntrl_add').click(function(){
          var inp = el.find('.c_input_add');
          
          var response = $R.put( opts.url_tag_create, {
              'name'  : inp.val(),
              'refid' : opts.refid
            }
          ).data;
            
          cont.append('<span class="tag new" wgt_tid="'+response.tag_id+'" wgt_eid="'+response.ref_id+'" >'+response.label+'</span>');
          
          var newTags = cont.find('.new')
          self.bindTagEvent( newTags, opts );
          inp.val('');
        });
      }else{
        // wenn keine tags hinzugefügt werden können sicher stellen, dass
        // das inputfeld dafür auch fehlt
        el.find('.search').remove();
      }
      
      
    },
    
    bindTagEvent: function( tagNodes, opts ){
      
      var self = this;
      
      if( opts.url_tag_disconnect ){
        tagNodes.bind( 'mouseover.tag', function( e ){
          var tNode = $S(this);
          $S('#wgt-tag-control').remove();
          tNode.append( ' <button id="wgt-tag-control" class="wgt-button"  >&nbsp;</button>' );
          $S('#wgt-tag-control').click( function(){
            self.disconnect( tNode );
            tNode.remove();
          });

        }).bind( 'mouseout.tag', function( e ){

        });
      }
      
      tagNodes.removeClass('new');
      
    },
    
    disconnect: function( tNode ){
      
      return $R.del( this.options.url_tag_disconnect+'&objid='+tNode.attr('wgt_eid')+'&tagid='+tNode.attr('wgt_tid') );
    }

  });

}( jQuery ) );


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
(function( $S ) {

  $S.widget( "wgt.contentContainer", {

    /**
     * Die ID des Container Elements
     */
    containerId: null,
    
    /**
     * das container element
     */
    containers: null,

    /**
     * Das Kontrollelement für die Tabs
     */
    controlEl: null,

    /**
     * Standard Options
     */
    options: { 
      // technische Eigenschaften
    },
 
    /**
     * Setup / Constructor methode des Widgets
     */
    _create: function() {
        
      this.initEvents();
      return this;

    },//end _create
    
    /**
     * Setup des Datencontainers
     */
    initEvents: function(){

      var el = this.element;

      this.conatinerId = el.attr('id');

      // without id it's bad
      if( !this.conatinerId )
        console.error( "Missing the ID for the container" );

      this.containers  = el.find('>div.container');

      if( this.containers.find( '.active' ).length ){
        this.containers.not('.active').hide();
      }
      else{
        this.containers.not(':first').hide();
      }

    },

    /**
     * Aktiv setzen eines Containers
     */
    setActive: function( key ){

      var el = this.element,
        self = this;
      
      console.log( 'ContentContainer::setActive: #'+self.conatinerId+'-'+key );

      this.containers.hide();
      el.find( '#'+self.conatinerId+'-'+key ).addClass('active').show();
    },

    /**
     * Remove an a Content Container
     * The Controll Element is not affected
     */
    remove: function( key ){

      var el = this.element,
        self = this;

      // check if exists

      this.containers.find( '#'+self.conatinerId+'-'+key ).remove();
    },

    /**
     * Append a new Content Container
     * The Controll Element is not affected
     */
    add: function( key, content ){

      var el = this.element,
        self = this;

      if( !content ){
        el.append( '<div id="#'+self.conatinerId+'-'+key+'" class="container" >'+content+'</div>' );
      }
      else{
        el.append( key );
      }

    }
    
  });

}( jQuery ) );


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * Dropmenu Widget
 * @author dominik alexander bonsch <db@webfrap.net>
 * 
 * @todo mit der Contextbox verheiraten
 * 
 */
(function( $S, $G ) {
  
  "use strict";
  $S.widget( "wgt.dropdown", {
 
    // These options will be used as defaults
    options: { 
      clear         : null,
      align         : 'left',    // soll das overlay nach links oder rechts positionieren?
      valign        : 'bottom',  // soll das overlay über oder unter dem element erscheinen
      triggerEvent  : 'click',
      overlayStyle  : {width:200},
      closeOnLeave  : true,
      onOpen        : function(){},
      onClose       : function(){}
    },
 

    // Set up the widget
    _create: function() {

      this.init();

    },

    // Set up the widget
    init: function(  ){

      var self = this,
        ge = this.element,
        opts = this.options;

      var dropBoxId = ge.attr( 'wgt_drop_box' );
      var dropBox   = $S( '#'+dropBoxId );
      
      // browser contextmenü deaktivieren
      dropBox.bind('contextmenu', function() { return false; });
      
      // verhindern, dass der text selectiert werden kann
      dropBox.disableSelection();
      
      if ($S("#"+dropBoxId+'-init').length === 0){
        $S("body").append( dropBox );
      }
      else{
        $S("#"+dropBoxId+'-init').replaceWith( dropBox );
      }

      dropBox.attr( 'id', dropBoxId+'-init'  );

      // schliesen des Overlays wenn es verlassen wird
      if( true === opts.closeOnLeave || 'true' === opts.closeOnLeave  ){

        var dEnter = null;
        var dClose = null;

        setTimeout( function(){
          
            if( !dropBox.hasClass('mouse_in') && !dropBox.hasClass('mouse_in') ){
              self.close();
            }

          },
          600
        );

        dropBox.bind( 'mouseenter.dropmenu', function(){
          
          dropBox.addClass('mouse_in');
          dropBox.removeClass('mouse_in');
        }).bind( 'mouseleave.dropmenu', function(){

          dropBox.removeClass('mouse_in');
        });

        dropBox.bind( 'mouseenter.dropmenu', function(){

          dEnter = new Date().getTime();
          dropBox.addClass('mouse_in');
          //$target.removeClass('mouse_in');

          dropBox.bind( 'mouseleave.dropmenu', function(){

            dClose = new Date().getTime();
            dropBox.unbind('mouseleave.dropmenu');
            dropBox.removeClass('mouse_in');

            setTimeout( function(){
                if( (dClose - 400) > dEnter ){
                  self.close();
                }
              },
              450
            );

          });
        });
      
      }//end if( true === opts.closeOnLeave || 'true' === opts.closeOnLeave  )

      // event setzen
      /*
      if( opts.closeAll ){
        jQuery(document).bind( 'mouseup.wgt_mini_menu', docMouseDown );
      }
      */
      
      this.initFolding( ge, dropBox );
      this.setKeyCommands( ge, dropBox );
      
      if( opts.triggerEvent ){
        ge.bind( opts.triggerEvent+'.dropmenu' ,function(){
          self.open();
        });
      }

    },
    
    initFolding: function( el, dropBox ){

      dropBox.find( 'li' ).bind( 'mouseover.dropmenu', function(){
        $S(this).addClass( 'hover' );
      }).bind( 'mouseout.dropmenu', function(){
        $S(this).removeClass( 'hover' );
      });
      
    },
    
    setKeyCommands: function(  ge,  dropBox ){
      
      var self = this;

      // Elemente des dropmenüs per tastatur selectierbar machen
      $S(document).bind( 'keypress.dropmenu',  function(e) {
        switch( e.keyCode ) {
        
          case 38: // up
            
            console.log('key up');
            
            if( dropBox.find('li.hover').length === 0 ) {
              
              dropBox.find('li:last').addClass('hover');
            } 
            else {
              
              var act = dropBox.find('li.hover');
              
              var bef = dropBox.find('li.hover').not('.disabled').before();
              
              if( bef.is('li') ){
                dropBox.find('li.hover').not('.disabled').next().addClass('hover').css('backgroundColor',"black");
              }
              
              act.remove('hover');
              
              if( dropBox.find('li.hover').length === 0 ){
                dropBox.find('li:last').addClass('hover').css('backgroundColor',"blue");
              }
            }
          break;
          
          case 40: // down
            
            console.log('key down');
            
            if( dropBox.find('li.hover').length === 0 ) {
              
              dropBox.find('li:first').addClass('hover').css('backgroundColor',"green");
            } 
            else {
              
              dropBox.find('li.hover').removeClass('hover').not('.disabled').eq(0).addClass('hover').css('backgroundColor',"olive");
              
              if( dropBox.find('li.hover').length === 0 ){
                dropBox.find('li:first').addClass('hover').css('backgroundColor',"yellow");
              }
            }
          break;
          
          /*
          case 13: // enter
            console.log('key enter');
            dropBox.find('li.hover a').trigger('click');
          break;
          */
            
          case 27: // esc
            console.log('key esc');
            self.close();
          break;
            
        }// end switch
      });
      
    },
    
    /**
     * Key Commands wieder deaktivieren
     */
    removeKeyCommands: function(){
      $S(document).unbind( 'keypress.dropmenu' );
    },
    
    // Set up the widget
    open: function(  ){

      var self = this,
        ge   = this.element, //das element auf welches geklickt wurde
        opts = this.options;

      var dropBoxId = ge.attr( 'wgt_drop_box' );
      var dropBox   = $S( '#'+dropBoxId+'-init' );

      // Get options of the element
      this.closeAll();
      
      // potentiell offenen menü schliesen
      $G.$D.requestCloseMenu();
      // schliesen des Menüs nach dem Request
      $G.$D.requestCloseMenu = function(){
        self.close();
      };
      
      // callback
      try{
        if( opts.onOpen ){
          opts.onOpen( ge );
        }
      }
      catch( err ){
        console.error( 'Dropmenu onOpen failed '+err );
      }
      
      

      //$target.addClass('flag-menu-overlay');
      // Die ausrichtung und position des Overlays berechnen
      // sicher stellen, dass es nicht über die Ränder hinaus floatet
      var style     = ge.offset();
      var tStyleW   = ge.outerWidth();
      var oStyleH   = dropBox.outerHeight();
      var oStyleW   = dropBox.outerWidth();
      var winW      = $S(document).width();
      var winH      = $S(document).height()-40;

      if( !style ){

        console.error( 'Dropbox is missing the style' );

        if( console.trace ){
          console.trace(  );
        }

        return;
      }

      if( 'right' === opts.align ){

        style.left =  style.left + tStyleW - oStyleW;

        if( ( style.left + opts.overlayStyle.width ) > winW ){
          style.left = winW - opts.overlayStyle.width;
        }

      }
      else if( 'middle' === opts.align ){

        style.left = style.left + ( ( tStyleW - oStyleW ) / 2 ) ;

        if( ( style.left + opts.overlayStyle.width ) > winW ){
          style.left = winW - opts.overlayStyle.width;
        }

      }
      else{

        if( ( style.left + opts.overlayStyle.width ) > winW ){
          style.left = winW - opts.overlayStyle.width;
        }
      }

      if( style.left < 0 ){
        style.left = 0;
      }


      console.log( "#"+dropBoxId+"-init DROP BOX left "+style.left+' top '+style.top );

      style['z-index'] = '10000';

      // adjust top coordinate
      
      if(  'bottom'  === opts.valign  ){
        
        if( ( style.top + oStyleH ) > winH ){
          style.top = winH - oStyleH;
        }
        
        style.top = style.top + ge.outerHeight();
      }
      else{
        
        style.top = style.top - oStyleH ;
        
        if( style.top < 0 ){
          style.top = 0;
        }
        
      }
        
      
      style.position = 'absolute';
      dropBox.css(style);
      dropBox.addClass('opened');
      this.setKeyCommands( ge, dropBox );
      dropBox.show( );

    },
    
    /**
     * globales schliesen aller drowpdown boxes
     */
    closeAll: function(){

      $S('.wgt-dropdownbox.opened').removeClass('opened').hide();

      this.removeKeyCommands( );

    },

    /**
     * schliesen des aktuellen dropdowns
     */
    close: function(){
        
      // callback
      if( this.options.onClose ){
        this.options.onClose( this.element );
      }
      
      $G.$D.requestCloseMenu = function(){};
      
      var dropBox   = $S( '#'+this.element.attr( 'wgt_drop_box' )+'-init' );
      dropBox.removeClass('opened').hide();
      
      this.removeKeyCommands( );

    },
    
    /**
     * schliesen des aktuellen dropdowns
     */
    remove: function(){

      $S(document).unbind('keypress.dropmenu');
      $S( '#'+this.element.attr( 'wgt_drop_box' )+'-init' ).remove();

    },

    /* 
     * Use the destroy method to clean up any modifications your 
     * widget has made to the DOM
     */
    destroy: function() {
      
      // remove the overlay
      this.remove();
      $S.Widget.prototype.destroy.call( this );
    }

  });

}( jQuery, window ) );


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * Tab Head Implementierung
 * @author dominik alexander bonsch <db@webfrap.net>
 */
(function( $S, $WGT ) {
  
  "use strict";

  $S.widget( "wgt.tabHead", {
 
    
    // These options will be used as defaults
    options: { 
      align         : 'right',
      triggerEvent  : 'click'
    },

    /**
     * Die Contentbox
     */
    contentBox: null,
 

    // Set up the widget
    _create: function() {

      this.init();

    },

    // Set up the widget
    init: function(  ){
        
      var el = this.element,
        self = this;

      var ctbId = el.attr('wgt_body');
      var ctB = $S('#'+ctbId);
      this.contentBox = ctB;
      
      if( !el.find( 'a.tab' ).length  ){
        
        var tabhead = el.find('.tab_head');
        
        ctB.find( '.container' ).each(function(){
          var contCon = $S(this);
          tabhead.append( '<a class="tab wgt-corner-top" wgt_key="'+contCon.attr('wgt_key')+'" >'+contCon.attr('title')+'</a>' );
        });
        
      }

      // das tabbing event
      el.find( 'a.tab' ).bind( 'click.tab_head', function(){

        var tabNode = $S(this);
        self.activateTab( tabNode.attr('wgt_key') );

      });
      
      el.find( 'a.tab' ).each( function(){
        $S(this).addClass('tab_'+$S(this).attr('wgt_key'));
      });
        
      el.find('.tab_overflow button').dropdown( {align:'right'} );
      
      var activeTab = el.find( 'a.tab.active:first' );
      if( activeTab.length ){
        this.activateTab( activeTab.attr('wgt_key') );
      }
      else{
        this.activateTab( el.find( 'a.tab:first' ).attr('wgt_key') );
      }


    },//end init: function
    

    // Set up the widget
    open: function(  ){

     

    },//end open: function

    // Set up the widget
    handleOverflow: function(  ){

      var el = this.element,
        self = this,
        hiddenTabs = {},
        allTabWidth = 0;

      var headSize = el.innerWidth()-5;
      var tabHeadSize = el.innerWidth()-30;
      
      var activeTab = el.find( 'a.tab.active' );
      activeTab.show();
      allTabWidth += activeTab.outerWidth( )+3;

      el.find( 'a.tab' ).not('.active').each( function(){
        
        var actTab = $S(this);
        allTabWidth += actTab.outerWidth( )+3;
        
        console.log( "tab "+actTab.attr('wgt_key')+" width "+allTabWidth+' > '+tabHeadSize +' '+(actTab.outerWidth( )+3) );
        
        if( tabHeadSize < allTabWidth ){
          hiddenTabs[actTab.attr('wgt_key')] = actTab;
          actTab.hide();
        }
        else{
          actTab.show();
        }
        
      });

      if( headSize < allTabWidth ){

        var oOFl = el.find('.tab_overflow');
        
        var oOFlMenu = $S( '#'+oOFl.find('button').attr('wgt_drop_box')+'-init ul' ) ;
        var oTh = el.find('.tab_head').not('.hidden');// keine versteckten tab heads verwenden
        var oOFlw = oOFl.outerWidth();

        oTh.width( headSize - oOFlw  );

        oOFlMenu.find('li').remove();

        for( var tabKey in hiddenTabs ) {
          
          var newTabEntry = $S('<li><a class="'+tabKey+'" wgt_tab="'+tabKey+'" >'+hiddenTabs[tabKey].html()+'</a></li>');

          oOFlMenu.append( newTabEntry );
          oOFlMenu.find('a.'+tabKey).bind( 'click', function(){
            //self.activateTab( ''+tabKey );
            self.activateTab( $S(this).attr('wgt_tab') );
            $S('.wgt-dropdownbox.opened').removeClass('opened').hide();
          });
          
        }
   
        
        oOFl.show();
      }

      console.log( 'headSize '+headSize+' allTabWidth '+allTabWidth ) ;

    },//end handleOverflow: function
      
    /**
     * Den Index eines Tabs über die ID auslesen
     * @param tabId string
     * @return int
     */
    getTabIndex: function( tabId ){
      
      return this.element.find( 'a.tab' ).index( this.element.find( 'a.tab_'+tabId ) );
    },//end getTabIndex: function
    
    /**
     * Die TabId über den Index auslesen
     */
    getIdByIndex: function( idx ){
      
      return $S(this.element.find( 'a.tab' ).get(idx)).attr('wgt_key');
    },//end getIdByIndex: function
    
    /**
     * Einen Tab Löschen
     */
    addTab: function( tabData ){
        
      var el = this.element,
        self = this;
      
      var tabHead = $S('.tab_head'); 
      var tabHeadCode = '<a wgt_key="'+tabData.key+'" class="tab tab_'+tabData.key+' wgt-corner-top" >'+tabData.label+'</a>';
      var tabContentCode = '<div class="container" wgt_key="'+tabData.key+'" id="'+this.contentBox.attr('id')+'-'+tabData.key+'">'+tabData.content+'</div>';
      
      tabHead.append( tabHeadCode );
      
      // das tabbing event
      el.find( 'a.tab.tab_'+tabData.key ).bind( 'click.tab_head', function(){

        var tabNode = $S(this);
        self.activateTab( tabNode.attr('wgt_key') );

      });
      
      this.contentBox.append( tabContentCode );
      this.activateTab( tabData.key );
      
    },//end addTab: function
    
    /**
     * Einen Tab Löschen
     */
    removeTab: function( tabId ){
        
      var el = this.element,
        nextActiveId = null;
      
      var tabIndex = this.getTabIndex( tabId ); 

      el.find( 'a.tab_'+tabId ).remove();
      $S('#'+this.contentBox.attr('id')+'-'+ tabId ).remove();
      
      if( 0 == tabIndex ){
        nextActiveId = this.getIdByIndex(tabIndex);
      }
      else{
        nextActiveId = this.getIdByIndex((tabIndex-1));
      }
      
      this.activateTab( nextActiveId );

    },//end removeTab: function
    
    /**
     * Einen versteckten Tab sichtbar machen
     */
    activateTab: function( tabId ){
      
      var el = this.element;
      
      var newActTab = el.find( 'a.tab_'+tabId );
      
      // events von disabled tags ignorieren
      if( newActTab.hasClass('disabled') ){
        return false;
      }
      
      el.find( 'a.tab.active' ).removeClass('active');
      
      this.contentBox.find('>div.container').hide();
      $S('.'+this.contentBox.attr('id')).hide();
      
      $S('#'+this.contentBox.attr('id')+'-'+ tabId+',.'+this.contentBox.attr('id')+'.box-'+tabId ).show();
      newActTab.addClass('active').show();
      
      var loadUrl = newActTab.attr('wgt_load');
      if( loadUrl ){
        newActTab.removeAttr('wgt_load');
        $R.get( loadUrl, {async:true} );
      }
        
      
      this.handleOverflow();
      
    },//end activateTab: function
    
    /**
     * Einen Tab verschieben
     */
    moveTab: function( tabId, newIndex ){

    },//end moveTab: function
    
    /**
     * Einen Tab im head verstecken
     */
    hideTab: function( tabId ){
      
      this.element.find( 'a.tab_'+tabId ).addClass('hidden').removeClass('active').hide();
      this.handleOverflow();
      
    },//end hideTab: function
    
    /**
     * Einen Tab im head verstecken
     */
    showTab: function( tabId ){
      
      this.element.find( 'a.tab_'+tabId ).removeClass('hidden').show();
      this.handleOverflow();
      
    },//end showTab: function
    
    /**
     * Einen Tab aktivieren & klickbar machen
     */
    enableTab: function( tabId ){
      
      this.element.find( 'a.tab_'+tabId ).removeClass('disabled');
    },//end enableTab: function
    
    /**
     * Einen Tab deaktivieren
     * klick triggert keine action
     */
    disableTab: function( tabId ){
      
      this.element.find( 'a.tab_'+tabId ).addClass('disabled');
    },//end disableTab: function

    /* 
     * Use the destroy method to clean up any modifications your 
     * widget has made to the DOM
     */
    destroy: function() {

      $S.Widget.prototype.destroy.call( this );
    }

  });

}( jQuery, $WGT ) );


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * Dropmenu Widget
 * @author dominik alexander bonsch <db@webfrap.net>
 * 
 * @todo mit der Contextbox verheiraten
 * 
 */
(function( $S, $WGT ) {

  $S.widget( "wgt.windowSelection", {
 
    // These options will be used as defaults
    options: { 
      element:null,
      add:null,
      selection:null,
      open:null
    },
 

    // Set up the widget
    _create: function() {

      this.init();

    },

    // Set up the widget
    init: function(  ){
      
      var
        self = this,
        ge = this.element,
        opts = this.options;

      // dropdown aktivieren
      ge.dropdown({
        onOpen:function(){
          self.open();
        },
        align:"right"
      });

      var inpElem = $S( '#'+opts.element );
      var dropBoxId = ge.attr( 'wgt_drop_box' );
      var dropBox   = $S( '#'+dropBoxId+'-init' );
      
      dropBox.find('li').hide();
      
      if( '' == inpElem.val() ){
        dropBox.find( 'li.add' ).show();
      }
      else{
        dropBox.find( 'li.change,li.open,li.unset' ).show();
      }
      
      dropBox.find( 'li.add>a' ).bind( 'click.win_sel', function(){
        $R.get( opts.selection  );
      });
      
      dropBox.find( 'li.change>a' ).bind( 'click.win_sel', function(){
        $R.get( opts.selection  );
      });
      
      dropBox.find( 'li.open>a' ).bind( 'click.win_sel', function(){
        $R.get( opts.open +''+inpElem.val()  );
      });
      
      dropBox.find( 'li.unset>a' ).bind( 'click.win_sel', function(){
        inpElem.val('');
        $S( '#'+opts.element+'-tostring' ).val('');
      });
      
    },
    
    // Set up the widget
    open: function(  ){

      var
        self = this,
        ge = this.element,
        opts = this.options;

      var inpElem = $S( '#'+opts.element );
      var dropBoxId = ge.attr( 'wgt_drop_box' );
      var dropBox   = $S( '#'+dropBoxId+'-init' );
      dropBox.find('li').hide();
      
      if( '' == inpElem.val() ){
        dropBox.find( 'li.add' ).show();
      }
      else{
        dropBox.find( 'li.change,li.open,li.unset' ).show();
      }

    },


    /* 
     * Use the destroy method to clean up any modifications your 
     * widget has made to the DOM
     */
    destroy: function() {

      $S.Widget.prototype.destroy.call( this );
    }

  });

}( jQuery, $WGT ) );


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * Take from the jquery ui examples
 */
(function( $S ){
  
  "use strict";

  $S.widget( "ui.combobox",{
    
    _create : function(){

      var input, 
        self = this, 
        select = this.element.hide(), 
        selected = select.children(":selected"), 
        value = selected.val() ? selected.text() : "", 
        wrapper = this.wrapper = $S("<span>").addClass("wgt-combobox").insertAfter(select);

      input = $S("<input class=\"medium\" >").appendTo(wrapper)
        .val(value).addClass( "wgt-combobox-input")
        .autocomplete({
          delay : 0,
          minLength : 0,
          source : function( request, response ){

            var matcher = new RegExp($S.ui.autocomplete.escapeRegex(request.term), "i");
            
            response( select.children("option").map(
              function(){
  
                var text = $S(this).text();
                if( this.value  && (!request.term || matcher.test(text)) )
                  return {
                    label : text.replace(new RegExp(
                        "(?![^&;]+;)(?!<[^<>]*)("
                            + $S.ui.autocomplete
                                .escapeRegex(request.term)
                            + ")(?![^<>]*>)(?![^&;]+;)", "gi"),
                        "<strong>$1</strong>"),
                    value : text,
                    option : this
                  };
              })
            );
          },
          select : function( event, ui ){

            ui.item.option.selected = true;
            self._trigger("selected", event, {
              item : ui.item.option
            });
            
          },
          change : function( event, ui ){

            if(!ui.item) {
              
              var matcher = new RegExp("^"
                  + $S.ui.autocomplete.escapeRegex($S(this).val())
                  + "$", "i"), valid = false;
              
              select.children("option").each(function(){

                if($S(this).text().match(matcher)) {
                  this.selected = valid = true;
                  return false;
                }
                
              });
              
            if(!valid) {
              // remove invalid value, as it didn't match anything
              $S(this).val("");
              select.val("");
              input.data("autocomplete").term = "";
              return false;
            }
            
          }
        }
          
      }).addClass("ui-widget ui-widget-content ui-corner-left");

      input.data("autocomplete")._renderItem = function( ul, item ){

        return $S("<li></li>").data("item.autocomplete", item).append(
            "<a>" + item.label + "</a>").appendTo(ul);
      };

      $S("<button class=\"wgt-button append wgt-combobox-toggle\" ><span class=\"ui-icon ui-icon-triangle-1-s\" ></span></button>").attr("tabIndex", -1).attr("title", "Show All Items")
      .appendTo(wrapper)
      .click(function(){
  
        // close if already visible
        if(input.autocomplete("widget").is(":visible")) {
          input.autocomplete("close");
          return;
        }

        // work around a bug (likely same cause as #5265)
        $S(this).blur();

        // pass empty string as value to search for, displaying all
        // results
        input.autocomplete("search", "");
        input.focus();
      });
      
    },
  
    destroy : function(){
  
      this.wrapper.remove();
      this.element.show();
      $S.Widget.prototype.destroy.call(this);
    }
            
  });
  
})(jQuery);

/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * Take from the jquery ui examples
 */
(function( $S, $G ){
  
  "use strict";
  $S.widget( "wgt.dblListSelector",{
    
    // These options will be used as defaults
    options: { 
      refid : null,
      url_connect : null,
      url_disconnect  : null
    },
 
    
    _create : function(){
      
      var el = this.element,
        opts = this.options;
      
      /*
      if( !opts.url_connect  )
        el.find( "ul.in" ).removeClass('dbl_list');
      
      if( !opts.url_disconnect  )
        el.find( "ul.out" ).removeClass('dbl_list');
      */

      el.find( "ul.out, ul.in" ).sortable({
        
        /**
         * markieren worauf gedroppt werden kann
         */
         connectWith: ".dbl_list",
         
        /**
         * the remove event
         */
         items: "li:not(.ui-state-disabled)",

         /**
         * the remove event
         */
         receive: function( event, ui) {
           
           var inpData;

           if( $S(ui.sender).find('li').length === 0  ){
             
             $S(ui.sender).append('<li class="ui-state-disabled" >no entries...</li>');
           }
           
           if( $S(this).find('.ui-state-disabled').length !== 0   ){
             
             $S(this).find('.ui-state-disabled').remove();
           }

           if( $S(this).is('.in') ){
             
             inpData = ui.item.find('input').serialize();
             $G.$R.post( opts.url_connect+'&refid='+opts.refid , inpData );
             ui.item.find('input').removeClass('wgt-ignore');

             el.find( "ul.in li,ul.out li" ).removeClass('ui-state-highlight');
             
           }
           else {
             
             inpData = '&'+ui.item.find('input').serialize();
             $G.$R.del( opts.url_disconnect+'&refid='+opts.refid+inpData  );
             
             ui.item.find('input').addClass('wgt-ignore');

             el.find( "ul.out li,ul.in li" ).removeClass('ui-state-highlight');
           }
           

         }
             
       }).disableSelection();
       
       // die list elemente selectierbar machen
       el.find( "ul li" ).each(function(){

         $S(this).mousedown(function(){
           $S(this).toggleClass('ui-state-highlight');
         });
       });
       
       
       // in nur wenn connect vorhanden ist
       if( opts.url_connect ){
         
         /**
          * Action all in
          */
         el.find( "button.all_in" ).click(function(){
           
           var allEntries = el.find( "ul.out li:not(.ui-state-disabled)" );
           var inpData = allEntries.find('input').serialize();
           
           el.find( "ul.in" ).append( allEntries );
           el.find( "ul.in input" ).removeClass('wgt-ignore');
           el.find( "ul.in li.ui-state-disabled" ).remove();
           el.find( "ul.in li" ).removeClass('ui-state-highlight');
           
           $G.$R.post( opts.url_connect+'&refid='+opts.refid , inpData );
           
           if( el.find( "ul.out li" ).length === 0 ){
             el.find( "ul.out" ).append('<li class="ui-state-disabled" >no entries...</li>');
           }
           
         }).addClass('ui-icon ui-icon-arrowthickstop-1-e');
  
         /**
          * Only selected in
          */
         el.find( "button.seleted_in" ).click(function(){
           
           var entries = el.find( "ul.out li.ui-state-highlight:not(.ui-state-disabled)" );
           
           if( !entries.length ){
             return;
           }
           
           var inpData = entries.find('input').serialize();
           
           $G.$R.post( opts.url_connect+'&refid='+opts.refid , inpData );
           
           el.find( "ul.in" ).append( entries );
           el.find( "ul.in input" ).removeClass('wgt-ignore').removeClass('ui-state-highlight');
           el.find( "ul.in li.ui-state-disabled" ).remove();
           el.find( "ul.in li" ).removeClass('ui-state-highlight');
           
           
           if( el.find( "ul.out li" ).length === 0 ){
             el.find( "ul.out" ).append('<li class="ui-state-disabled" >no entries...</li>');
           }
         });
       }

       // in nur wenn disconnect vorhanden ist
       if( opts.url_disconnect ){
         
         /**
          * Action all out
          */
         el.find( "button.all_out" ).click(function(){
           
           var allEntries = el.find( "ul.in li:not(.ui-state-disabled)" );
           var inpData = '&'+allEntries.find('input').serialize();
           
           el.find( "ul.out" ).append( allEntries );
           el.find( "ul.out input:not(.wgt-ignore)" ).addClass('wgt-ignore').removeClass('ui-state-highlight');
           el.find( "ul.out li.ui-state-disabled" ).remove();
           el.find( "ul.out li" ).removeClass('ui-state-highlight');
           
           $G.$R.del( opts.url_disconnect+'&refid='+opts.refid+inpData );
           
           if( el.find( "ul.in li" ).length === 0 ){
             el.find( "ul.in" ).append('<li class="ui-state-disabled" >no entries...</li>');
           }
           
         });
         
         /**
          * Only selected out
          */
         el.find( "button.seleted_out" ).click(function(){
           
           var entries = el.find( "ul.in li.ui-state-highlight:not(.ui-state-disabled)" );
           if( !entries.length ){
             return;
           }
           
           var inpData = '&'+entries.find('input').serialize();
           
           el.find( "ul.out" ).append( entries );
           el.find( "ul.out input:not(.wgt-ignore)" ).addClass('wgt-ignore').removeClass('ui-state-highlight');
           el.find( "ul.out li.ui-state-disabled" ).remove();
           el.find( "ul.out li" ).removeClass('ui-state-highlight');
           
           $G.$R.del( opts.url_disconnect+'&refid='+opts.refid+inpData );
           
           if( el.find( "ul.in li" ).length === 0 ){
             el.find( "ul.in" ).append('<li class="ui-state-disabled" >no entries...</li>');
           }
           
         });
         
       }
      
    },
  
    destroy : function(){
  
      $S.Widget.prototype.destroy.call(this);
    }
            
  });
  
})(jQuery,window);

/* Licence see: /LICENCES/wgt/licence.txt */


(function( window, $S, $WGT ){
  
  "use strict";

  /**
   * @author dominik alexander bonsch <db@webfrap.net>
   */
  var Request = function( ){

    /**
     * the version of the request handler
     */
    this.version = 2.0;

    /**
     * ref to prototype
     */
    this.fn = Request.prototype;
    
    /**
     * das letzte HTTPRequest object
     */
    this.lastRequest = null;

    /**
     * way to self
     */
    var self = this;
    
    /**
     * the request handler
     * @var RequestHandler
     */
    var handler = null;

  /*//////////////////////////////////////////////////////////////////////////////
  // ajax request event pools
  //////////////////////////////////////////////////////////////////////////////*/

    /**
     * Eventliste für Funktionen vor dem Ajax Request
     */
    this.beforeAjaxRequest = [];

    /**
     * Eventliste für Funktionen nach dem Ajax Request
     */
    this.afterAjaxRequest  = [];

      /**
     * Eventliste für Funktionen nach dem Ajax Request
     */
    this.poolOtPostAray    = [];

    /**
     * Eventliste für das erste erstellen einer Seite
     */
    this.initRequest       = [];
    
    /**
     * pool with acttions
     */
    this.actionPool       = {};
    
/*//////////////////////////////////////////////////////////////////////////////
 // getter & setter methodes
//////////////////////////////////////////////////////////////////////////////*/

    /**
     * @param rqHandler RequestHandler  
     */
    this.setHandler = function( rqHandler ){
      
      handler = rqHandler;
    };
    
    /**
     * @return RequestHandler
     */
    this.getHandler = function(){
      
      return handler;
    };
    
    /**
     * Fragen ob der letzte Request ok war
     * @return boolean
     */
    this.ok = function(){
      
      return self.lastRequest.status === 200 ? true:false;
    };
    
/*//////////////////////////////////////////////////////////////////////////////
// methodes
//////////////////////////////////////////////////////////////////////////////*/

    /**
     * Einen GET Request über das Ajax Interface absetzen
     * 
     * @param requestUrl string 
     * @param params {}
     */
    this.get = function( requestUrl, params  ){

      // when the url is empty break here
      if( $WGT.empty( requestUrl ) ){
        return null;
      }

      if( undefined === params ){
        params = {};
      }

      /*
      if( params.check ){
        if( !$S('#'+params.check.input).is(':checked') ){
          
          $D.errorWindow(
            params.check.title,
            params.check.message,
            'Confirm',
            function (){ $S('#'+formId).submit(); }
          );
          return false;
        }
      }
      */

      params.url  = requestUrl;
      params.type = 'get';

      if( undefined !== params.confirm  ){
        
        var response = null;
        
        $D.confirmWindow(
          'Confirm',
          params.confirm,
          'Confirm',
          function (){ response = self.wgtRequest(params); }
        );
        
        return response;
        
      }
      else{
        
        return self.wgtRequest( params );
        
      }
 
    };//end this.get 

    /**
     * Einen POST Request über das Ajax Interface absetzen 
     * 
     * @param requestUrl
     * @param requestData
     * @param params
     */
    this.post = function( requestUrl, requestData, params  ){
      
      // when the url is empty break here
      if( $WGT.empty(requestUrl) ){
        console.error( "triggert post with an empty url" );
        return null;
      }
      
      if( undefined === params ){
        params = {};
      }
      
      params.url  = requestUrl;
      params.type = 'post';
      params.data = requestData;

      if( undefined !== params.confirm  ){
        
        var response = null;
        
        $D.confirmWindow(
          'Confirm',
          params.confirm,
          'Confirm',
          function (){ response = self.wgtRequest( params ); }
        );
        
        return response;
        
      }
      else{
        
        return self.wgtRequest( params );
        
      }

    };//end this.post */

    /**
     * Einen PUT Request über das Ajax Interface absetzen
     * 
     * @param requestUrl
     * @param requestData
     * @param params
     */
    this.put = function( requestUrl, requestData, params  ){

      // when the url is empty break here
      if( $WGT.empty(requestUrl) ){
        return null;
      }

      if( undefined === params ){
        params = {};
      }
      
      params.url  = requestUrl;
      params.type = 'put';
      params.data = requestData;

      if( undefined !== params.confirm  ){
        
        var response = null;
        
        $D.confirmWindow(
          'Confirm',
          params.confirm,
          'Confirm',
          function (){ response = self.wgtRequest( params ); }
        );
        
        return response;
        
      }
      else{
        
        return self.wgtRequest( params );
        
      }
      
    };//end this.put */

    /**
     * Einen DELETE Request über das Ajax Interface absetzen
     * @param  requestUrl
     * @param  params
     * @return Json
     */
    this.del = function( requestUrl, params  ){

      // when the url is empty break here
      if( $WGT.empty(requestUrl) ){
        console.error("Requested del with empty url");
        return null;
      }

      if( undefined === params ){
        params = {};
      }
      
      params.url  = requestUrl+'&request=ajax';
      params.type = 'delete';
      
      if( undefined !== params.confirm ){
        
        var response = null;
        
        $D.confirmWindow(
          params.confirm,
          params.confirm,
          'delete',
          function (){ response = self.wgtRequest(params); }
        );
        return response;
      }
      else{
        
        return self.wgtRequest(params);
      }

    };//end this.del */
    
    /**
     * Ein formular abschicken, kein Ajax request!
     * @param formId
     * @param params
     */
    this.submit = function( formId, params ){
      
      if( undefined === params ){
        params = {};
      }
      
      if( params.check ){
        if( !$S('#'+params.check.input).is(':checked') ){
          
          $D.errorWindow(
            params.check.title,
            params.check.message,
            'Confirm',
            function (){ $S('#'+formId).submit(); }
          );
          return false;
        }
      }
      
      if( undefined !== params.confirm  ){
        
        $D.confirmWindow(
          params.confirm.title,
          params.confirm.message,
          'Confirm',
          function (){ $S('#'+formId).submit(); }
        );
      }
      else{
        
        $S('#'+formId).submit();
      }
      
      return false;
    };
    
    /**
     * Abschicken eines Formulars als ajax request
     * @param formId
     * @param formUrl
     * @param params
     */
    this.form = function( formId, formUrl, params ){
      
      if( undefined === params ){
        params = {};
      }

      console.log( "Request by Form ID "+formId  );
      
      if( params.search ){
        
        this.cleanFormParams( formId );
      }
      
      if( params.check ){
        if( !$S('#'+params.check.input).is(':checked') ){
          
          $D.errorWindow(
            params.check.title,
            params.check.message,
            'Confirm',
            function (){ $S('#'+formId).submit(); }
          );
          return false;
        }
      }
      
      var response = null;
      
      if( undefined !== params.confirm  ){
        
        $D.confirmWindow(
          params.confirm.title,
          params.confirm.message,
          'Confirm',
          function (){ response = self.sendForm(formId, formUrl, params); }
        );
      }
      else{
        
        response = self.sendForm( formId, formUrl, params );
      }
      
      return response;
    };

    /**
     * @param formId
     * @param formUrl
     * @param params
     */
    this.sendForm = function( formId, formUrl, params ){

      var form      = null;
      var response  = null;
      var requestParams  = {};

      if( undefined === params ){
        params = {};
      }

      if( params.statusCallback ){
        requestParams.statusCallback = params.statusCallback;
      }
      
      if( params.success ){
        requestParams.success = params.success;
      }
      
      if( params.error ){
        requestParams.error = params.error;
      }
      
      if( typeof formId  === 'object'  ){

        form   = formId;
        formId = form.attr('id');
      }
      else{
        
        form   = $S("form#"+formId);
      }
      
      if( !form ){
        console.log( 'Missing form '+formId );
        return;
      }
      
      var formMethod = form.attr('method');
      
      if( !formMethod ){
        console.log( 'Missing method in form '+formId );
        return;
      }
      
      formMethod = formMethod.toLowerCase();


      // clean form data
      if( params.clean === true ){
        
        this.cleanFormParams(form);
      }

      if( true === params.append ){
        
        formUrl = form.attr("action")+formUrl+"&request=ajax";
      }  
      else if( !formUrl ){

        formUrl = form.attr("action")+"&request=ajax";
      }

      ///TODO implement a more generic way for including ckeditor
      ///TODO make that more error safe / stable whatever
      /*
      $S('.wgt_wysiwyg_flag').each( function( flag ){

        var flagObj   = $S(this);
        var editorKey = flagObj.attr('name');
        var keyData   = CKEDITOR.instances[''+editorKey].getData();
        $S('#'+editorKey).val(keyData);
      });
      */
      
      var formParams  = this.appendFormParams( form );
      
      /*
      if($S.ajaxFileUpload)
      {
        alert('Anzahl files '+formId+' '+$S(":file.asgd-"+formId).length);
      }*/
        

      // check if there file inputs in the form
      if( ( form.find(":file").length || $S(":file.asgd-"+formId).length  ) && $S.ajaxFileUpload ){

        response = $S.ajaxFileUpload({
          url       :formUrl+formParams.url+'&rqt=ajax',
          secureuri :false,
          formid    :formId,
          dataType  :'xml',
          success   :function( responseXML ){
            
            $R.lastResponse   = responseXML;
            var responseData  = handler.xml(responseXML);
            //params.success( responseData );
            $R.eventAfterAjaxRequest( );
            
            if( params.success ){
              params.success( $R.lastResponse, responseData );
            }
            
            if( params.callback ){
              params.callback();
            }
            
          },
          error :function (data, status, e){
            
            if( params.error ){
              params.error( data, status, e );
            }

            $D.errorWindow( e );
            
          },
          statusCallback: requestParams.statusCallback
        });

        return response;
      }
      else{
        
        var formFields  = form.find(":input").not(":submit").not(":reset").not(".wgt-ignore").not('.asgd-'+formId).not('.fparam-'+formId);
        var formData    = formFields.serialize();
        
        formFields.filter('input[type="checkbox"]').not(":checked").each(function(){
          formData += '&'+$S(this).attr('name')+'=0';
        });
        
        if( params.data !== undefined ){
          for( var key in params.data ){
            
            formData += '&'+key+'='+params.data[key];
          }
        }
        
        /*
        var externFields = $S('.'+formId+'_asgd');
        if( externFields.length > 0 )
          formData += '&'+externFields.serialize();
        */
        /*
        var externFields = $S('.asgd-'+formId).not('.flag-template');
        if( externFields.length > 0 )
          formData += '&'+externFields.serialize();
        */
        
        var externFields = $S('.asgd-'+formId).not('.flag-template');
        if( externFields.length > 0 ){
          
          formData += '&'+externFields.serialize();
          
          externFields.filter('input[type="checkbox"]').not(":checked").each(function(){
            formData += '&'+$S(this).attr('name')+'=0';
          });
          
        }
        
        if( 'post' === formMethod ){

          response = $R.post(
            formUrl+formParams.url,
            formData+formParams.post,
            requestParams
          );
          
          if(params.callback){
            params.callback();
          }
          
        }
        else if( 'put' === formMethod ){
          
          response = $R.put(
            formUrl+formParams.url,
            formData+formParams.post,
            requestParams
          );
            
          if( params.callback ){
            params.callback();
          }
          
        }
        else{
          
          response = $R.get( formUrl+formParams.url+'&'+formData+formParams.post, requestParams );
          
          if( params.callback ){
            params.callback();
          }
          
        }
        
        return response;
      
      }

    };//end this.form

    /**
     * @param formId
     */
    this.appendFormParams = function( formId ){
      
      
      var form,
        data = {url:'',post:''};
      
      ////%5Btitle%5D
      if(typeof formId === 'string'){
        
        form  = $S("form#"+formId);
      }
      else{
        
        form  = formId;
        formId = form.attr('id');
      }

      var start = form.data('start');
      if( start !== undefined && start !== null ){
        data.url += '&start='+start;
      }

      var size = form.data('qsize');
      if( size !== undefined && size !== null ){
        data.url += '&qsize='+size;
      }

      var begin = form.data('begin');
      if( begin !== undefined && begin !== null ){
        data.url += '&begin='+begin;
      }

      var next = form.data('next');
      if( next !== undefined && next !== null ){
        data.url += '&next='+next;
      }

      // felder auslesen, die als zusätzliche parameter an eine form gehängt werden
      var addParams = $S( ".fparam-"+formId );
      if( addParams.length ){
        
        data.url += '&'+addParams.serialize();
        
        addParams.filter('input[type="checkbox"]').not(":checked").each(function(){
          data.url += '&'+$S(this).attr('name')+'=0';
        });
        
      }

      return data;
      
    };//end this.appendFormParams

    /**
     * @param formId
     */
    this.cleanFormParams = function( formId ){
      
      var form;
      
      if( typeof formId === 'string' ){
        form=$S("form#"+formId);
      }
      else{
        form=formId;
      }

      form.data('order',null);
      form.data('start',null);
      //form.data('qsize',null);
      form.data('next',null);
      form.data('begin',null);
      
      return this;

    };//end this.cleanFormParams

    /**
     * redirects with post if an array with data is given
     * @param linktarget string
     * @param data array
     */
    this.redirect = function( linktarget, data ){
      
      if( undefined === data ){
        
        window.location.href = linktarget ;
      }
      else{
        
        var form = '<form id="wgt_redirect" class="meta" method="post" action="'+linktarget+'" >';
        
        $S.each(data,function(key,value){
          form += '<input type="text" name="'+key+'" value="'+value+'" />';
        });
        form += '</form>';
        
        $S('body').append(form);
        $S('#wgt_redirect').submit();
      }
     
    };

    /**
     * @param lang the language
     */
    this.redirectLang = function( lang ){
      ///@FIXME multiple languages attached if the url has already a lang attr
      ///@FIXME error when noch scriptname ist giffen, default index.php? or fetch var via conf

      window.location.href = window.location.href+'&lang='+lang ;
    };

    /**
     * @param selector
     * @param redirectUrl
     */
    this.redirectByValue = function( selector , redirectUrl ){
      
      var value = $S(selector).value();
      window.location.href= str_replace( '{id}', value, redirectUrl );
    };

    /**
     * @param selector
     * @param url
     */
    this.showEntity = function( selector , url ){

      if( $S('#'+selector).length === 0){
        return false;
      }

      var value = $S('#'+selector).val();

      if( undefined === value || trim(value) === '' ){
        return false;
      }

      $R.get(url+value);
      return true;

    };//end this.showEntity 

    /**
     * @param params array
     */
    this.wgtRequest = function( params ){

      // when the url is empty break here
      if( $WGT.undef(params) || $WGT.undef(params.url) ){
        return false;
      }
      
      //$WGT.loadModule('request');
      
      // setting of default values
      $WGT.dval(params,'type','post');
      $WGT.dval(params,'success',function(data){});
      $WGT.dval(params,'error',function(data){});
      
      // per default we want synchron request, as most of the requests
      // are in transactions where the response is required for the next
      // steps.
      // please remember this is a client for business applications and not
      // a webbased content viewer!
      $WGT.dval(params,'async',false);
      $WGT.dval(params,'ctype','xml');

      var callback = null,
        responseData;

      if( undefined === params.callback ){

        callback = function(){
          
          // wenn vorhanden original debug consolen content löschen
          $S('#wgt_debug_console-content').remove();
          
          $R.eventAfterAjaxRequest();
        };

      }
      else{

        callback = function(){
          
          // wenn vorhanden original debug consolen content löschen
          $S('#wgt_debug_console-content').remove();
          
          params.callback();
          $R.eventAfterAjaxRequest();
        };
      }
        
      // events trigger die vor einem ajax request ausgeführt werden
      $R.eventBeforeAjaxRequest();
      
      /**
       * WGT request object including 
       * the xrqt object
       * extracted data
       * rendering status
       */
      var requestData = {
        rqt: null,
        data: null,
        status: null
      };

      if( 'xml' === params.ctype ) {

        if( true === params.async ) { // async
          
          try{

            self.lastRequest = $S.ajax ({
              type:   params.type,
              url:    params.url+'&rqt=ajax',
              data:   params.data,
              async:  true,
              success: function( responseXML ) {

                $R.lastResponse = responseXML;
                responseData = handler.xml( responseXML, params.statusCallback  );
                requestData.data = responseData;
                
                params.success( responseXML, responseData );
                
                callback();
                
              },
              error:  params.error
            });
            
            requestData.rqt = self.lastRequest;
            requestData.status = 0;
            
            // schliesen des Menüs nach dem Request
            $D.requestCloseMenu();
          }
          catch( exc ){
            
            requestData.rqt = self.lastRequest;
            requestData.status = 1;
            
            $D.errorWindow( exc );
          }
          
          console.log( 'Request: '+requestData.rqt.status );

          return requestData;

        }
        else{ // sync
            
          // wann wird die exception geworfen?
          try{
            

            self.lastRequest = $S.ajax({
              type:   params.type,
              url:    params.url+'&rqt=ajax',
              data:   params.data,
              async:  false,
              error:  params.error
            });

            self.lastResponse = self.lastRequest.responseXML;

            responseData  = handler.xml( self.lastResponse, params.statusCallback );

            // schliesen des Menüs nach dem Request
            $D.requestCloseMenu();
            
            if( params.success ){
              console.log( 'trigger success' );
              params.success( responseData );
            }
            
            // callback nach dem request
            callback();

            requestData.status = 0;
          }
          catch( exc ){
            
            requestData.status = 1;
            $D.errorWindow( exc );
          }
          

          requestData.rqt = self.lastRequest;
          requestData.data = responseData;
          
          console.log( 'Request: '+requestData.rqt.status );
          
          return requestData;
          
        }

      }
      else{
          
        try{
          

          self.lastRequest = $S.ajax({
            type:   params.type,
            url:    params.url,
            data:   params.data,
            async:  false,
            dataType: 'json',
            error:  params.error
          });

          var retVal  = handler.json( self.lastRequest.responseText, params.statusCallback );
          
          // schliesen des Menüs nach dem Request
          $D.requestCloseMenu();
        
          if( params.success ){
            params.success( self.lastRequest, retVal );
          }
          
          callback();
          
          requestData.status = 0;
        }
        catch( exc ){
          
          // error handling
          console.error( 'Request failed '+exc.message );
          $D.errorWindow( exc );
          requestData.status = 1;
        }
        
        requestData.rqt = self.lastRequest;
        requestData.data = retVal;
        
        console.log( 'Request: '+requestData.rqt.status );
        
        return requestData;
        
      }

    };//end this.wgtRequest */

/*//////////////////////////////////////////////////////////////////////////////
// the methods for the ajax interface events
//////////////////////////////////////////////////////////////////////////////*/

    /**
    * @param callBack
    */
   this.addBeforeAjaxRequest = function( callBack ) {
     this.beforeAjaxRequest.push(callBack);
   };//end this.addBeforeAjaxRequest

   /**
    * @param callBack
    */
   this.addAfterAjaxRequest = function( callBack ){
     this.afterAjaxRequest.push(callBack);
   };//end this.addAfterAjaxRequest

   /**
    * @param callBack
    */
   this.oneTimePostAjax = function( callBack ){
     this.poolOtPostAray.push(callBack);
   };//end this.oneTimePostAjax


   /**
    * @param key
    * @param callBack
    */
   this.addAction = function( key, callBack ){
     this.actionPool[key] = callBack;
   };//end this.oneTimePostAjax
   

   /**
    * @param key
    * @return function
    */
   this.getAction = function( key ){
     return this.actionPool[key];
   };//end this.getAction
   
    /**
    * Eine WCM Action auf einem definierten Node ausführen
    * @param key string
    * @param jNode jQuery
    * @param params Object
    */
    this.callAction = function( key, jNode, params ){

      var call = this.actionPool[key];

      if( call ){
        call( jNode, params );
      }

    };//end this.callAction */

   /**
    *
    */
   this.eventBeforeAjaxRequest = function( ){

      $D.showProgressBar();

      for( var func in this.beforeAjaxRequest ){

        var callback = this.beforeAjaxRequest[func];
        try {
          callback();
        }
        catch( exc ) {
          $D.errorWindow( exc );
        }
      }

    };//end this.eventBeforeAjaxRequest

   /**
    *
    */
    this.eventAfterAjaxRequest = function( ) {

      var callback  = null;
      var length    = this.afterAjaxRequest.length;

      for (var index = 0; index < length; ++index){

        callback = this.afterAjaxRequest[index];
        try{

          callback();
        }
        catch( exc ) {
           //alert(e.message);
           $D.errorWindow( exc );
           //this.desktop.errorWindow( exception.name, exception.message );
        }
      }


      // disable Links and use ajax instead (and remove class)
      var allActions = $S(".wcm");
      allActions.each(function(){
        var node      = $S(this);
        
        var classParts  = node.classes();
        var tmpLenght   = classParts.length;

        for (var index = 0; index < tmpLenght; ++index){

          var callback = classParts[index];

          if( 'wcm_' === callback.substring(0,4) ) {

            var call = $R.actionPool[callback.substring(4,callback.length)];
            
            try{
              if( typeof call !== 'undefined'){
                call (node );
              }
            }
            catch( exc ) {
               //alert(e.message);
               $D.errorWindow( exc );
               //this.desktop.errorWindow( exception.name, exception.message );
            }

          }
        }

      });
      allActions.removeClass("wcm");

      length = this.poolOtPostAray.length;
      for (var iter = 0; iter < length; ++iter) {

        callback = this.poolOtPostAray[iter];
        try {
         
          callback();
        } catch( exc ) {
         
          //alert(e.message);
          $D.errorWindow( exc );
          //this.desktop.errorWindow( exception.name, exception.message );
        }
      }

      this.poolOtPostAray = [];

      $D.hideProgressBar();

    };//end this.eventAfterAjaxRequest 

    /**
     *
     */
    this.eventInitRequest = function( ) {

      for (var index = 0; index < this.initRequest.length; ++index) {

        var callback = this.initRequest[index];
        try {
          
          callback();
        } catch( e ) {
          
          //alert(e.message);
          $D.errorWindow( e.name, e.message );
          //this.desktop.errorWindow( exception.name, exception.message );
        }
      }

    };//end this.eventInitRequest

  };//end function WgtRequest

  // Expose Request to the global object
  window.$R = new Request();

})( window, $S, $WGT );


/* Licence see: /LICENCES/wgt/licence.txt */


;(function($R,$S,undefined){

  /**
   * @author dominik alexander bonsch <db@webfrap.net>
   */
  var RequestHandler = function( ){

    /**
     * ref to prototype
     */
    this.fn = RequestHandler.prototype;
    
    /**
     * array with handlers for rich elements
     */
    var elementHandler = [];
    
    /**
     * @param key:string
     * @param callBack:function
     */
    this.addElementHandler = function( key, callBack ) {
      elementHandler[key]=callBack;
    };
    

   /**
     * @param jObj:JSON
     */
    this.json = function( jObj ){

      /* messages handeln
      if( responseMessages.get().length > 0)
        this.processMessages( responseMessages );
      */

      /* exexute embeded code
      if( responseCode.get().length > 0)
        eval(responseCode.text());
      */

      // return body data
      if( typeof jObj.body != 'undefined' )
        return jObj.body;
      else
        return null; // return null when no body was given

    };//end this.handleJsonResponse */

    /**
     * @param xmlData
     * @param statusCallbacks
     */
    this.xml = function( xmlData, statusCallbacks ){

      var rXML = $S(xmlData).children("wgt");

      //Error Handling
      if(rXML.get().length == 0){
        $D.errorWindow( 
          'Sorry, the System was not able to process the server response.' 
           +' This can happen when your Browser is in the Offline Mode, or when an internal Server Error occures.'
           +' Please report if this problem persists.'
        );
        return null;
      }
      
      if( $C.DEBUG.REQUEST )
        console.log( "Handle XML Head" );

      // interpret head
      var rHead = rXML.find("gui>head");
      if( rHead.get().length > 0 )
        this.interpretHead( rHead );

      if( $C.DEBUG.REQUEST )
        console.log( "Handle XML Body" );
      
      // interpret body
      var rBody = rXML.find("gui>body");
      if( rBody.get().length > 0)
        this.interpretBody( rBody );
 

      if( $C.DEBUG.REQUEST )
        console.log( "Handle XML Messages" );
      
      // handle messages
      var messages = rXML.find("gui>messages");
      if( messages.get().length > 0)
        this.processMessages( messages );

      if( $C.DEBUG.REQUEST )
        console.log( "Handle XML Code" );
      
      // Global code, is directly executed via eval
      var responseCode = rXML.children("code");
      if( responseCode.get().length > 0){
        try{
          if( $C.DEBUG.REQUEST )
            console.log( 'Got Code: '+responseCode.text() );
          (new Function( "$S" ,responseCode.text()))( $S );
        }catch( exc ){
          console.error( 'Failed to execute response code!' );
        }
      }

      // den status callback ausführen
      var status = rXML.children("status").text();

      console.log("Request Status "+status);

      if( statusCallbacks  ){ 
        if( undefined !== statusCallbacks[status] ){
          statusCallbacks[status]();
        }
      }
      
      if( $C.DEBUG.REQUEST )
        console.log( "Handle XML Data" );

      //Data Tag contains json data
      var responseData = rXML.children("data").text();

      // wenn responsedata reines html ist, einfach zurückgeben
      if( rXML.children("data").attr('type') == 'html'  ){
        return responseData;
      }
      
      try {
        if( '' != responseData ){
          var pData = $S.parseJSON(responseData);
          return pData;
        }
        else{
          return null;
        }  

      }
      catch( e ){
        ///TODO some better error handling
        return null;
      }
      

    };//end this.handleWGTResponse */

    /**
     * Handler für das Head Tag
     */
    this.interpretHead = function( rXML ){

      // setting new page title
      if( rXML.children("title").get().length > 0 ){

        var titleVar = rXML.children("title").text();

        if( titleVar ){
          document.title = titleVar;
        }
        else if( $C.windowTitle != undefined ) {
          document.title = $C.windowTitle;
        }
        else{
          document.title = 'Desktop'; 
        }
      }

      // add and delete CSS Files
      if(rXML.children("css").get().length > 0){

        rXML.children("css").each(function(){

          var action = $S(this).attr("action");
          var source = $S(this).attr("src");

          if (action == "add") { // add

            if ($S("head link[href=" + source + "]").get().length == 0){ // allready added?
              $S("head").append('<link rel="stylesheet" href="' + source + '" />');

            }
          }
          else{ // remove
            $S("head link[href=" + source + "]").remove();
          }

        });
      }//end if

      // add and delete JS Files
      if(rXML.children("js").get().length > 0) {

        rXML.children("js").each(function()  {
          
          var action = $S(this).attr("action");
          var source = $S(this).attr("src");

          if (action == "add") { // add
            if ($S("head script[src=" + source + "]").get().length == 0) { // allready added?
            
              $S("head").append('<script type="text/javascript" src="' + source + '"></script>');
            }
          }
          else {// remove
          
            $S("head script[src=" + source + "]").remove();
          }

        });
      }//end if

      // follow a redirect
      if(rXML.children("redirect").get().length > 0) {

        rXML.children("redirect").each(function() {
          $R.redirect($S(this).text());
        });
      }//end if

    };//end this.interpretHead = function( rXML )

    /**
     * @param rXML
     * process messages
     */
    this.processMessages = function( rXML ){

      // add and delete CSS Files
      if(rXML.children("error").get().length > 0){
        $D.message.error('Error' , rXML.children("error").text() );
      }
      
      // eine wall message
      if( rXML.children("wall_message").get().length > 0 ){
        $D.confirmWindow(
          'System Message', 
          rXML.children("wall_message").text() 
        );
      }

      // add a warning toast
      if(rXML.children("warning").get().length > 0){
        $D.message.warning('Warning' , rXML.children("warning").text() );
      }

      // add a message toast
      if(rXML.children("message").get().length > 0){
        $D.message.message('Message' , rXML.children("message").text() );
      }

    };//end this.processMessages */

    /**
     * @param XMLNode rXML
     */
    this.interpretBody = function( rXML ){

      // the handlers are in wgt/request/handler
      // to add a handler inlcude the handler file after this class
      for(var key in elementHandler){
        elementHandler[key](rXML.children(key));
      }

    };//end this.interpretBody = function( rXML )

  };//end function WgtRequest

  //set the request handler
  $R.setHandler( new RequestHandler );

})($R,$S);


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
(function($R,$S){

  $R.getHandler().addElementHandler( 'tab', function( childNodes ){
    
    childNodes.each(function() {

      // first check if the window should be closed

      var tabObj = $S(this);

      var closeTab = tabObj.attr("close");
      
      if( undefined != closeTab && closeTab == "true"){
        
        console.log('Close Tab: '+tabObj.attr("id"));
        $UI.tab.remove('wgt-maintab',tabObj.attr("id"));
      }

    });

    childNodes.each(function() {

      // first check if the window should be closed

      var tabObj = $S(this);
      
      $UI.tab.removeIfExists('wgt-maintab',tabObj.attr("id"));
      
      var title = tabObj.attr('title');
      if( title )
        $D.setTitle( title );

      var closeTab = tabObj.attr("close");
      if( !(undefined != closeTab && closeTab == "true") ){
        
        console.log('Open Tab: '+tabObj.attr("id"));

        var tabData        = {};
        tabData.text       = tabObj.attr('label');
        tabData.id         = tabObj.attr('id');
        tabData.closeable  = (tabObj.attr('closeable')==undefined)?false:true;
        tabData.content    = tabObj.find('body').text();
        tabData.script     = tabObj.find('script').text();
        $UI.tab.add( 'wgt-maintab', tabData );
        
      }

    });
  
  });

})($R,$S);
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */

(function($S,$R){

  var actions ={
     'append':function(selector,text){
       
       if($S(selector).length>0){
         $S(selector).append( text );
       }
     }, 
     'prepend':function(selector,text){

       if($S(selector).length>0){
         $S(selector).prepend( text );
       }
       
     }, 
     'replace':function(selector,text){
       
       if($S(selector).length>0){
         $S(selector).replaceWith( text );
       }
     }, 
     'value':function(selector,text){
       
       if($S(selector).length>0){
         $S(selector).val( text );
       }
     },
     'html':function(selector,text){

       if($S(selector).length>0){
         $S(selector).html( text );
       }
     }, 
     'addClass':function(selector,text){$S(selector).addClass( text );},  
     'before':function(selector,text){$S(selector).before( text );}, 
     'after':function(selector,text){$S(selector).after( text );},
     'eval':function(selector,text){eval( text );},
     'function':function(selector,text){(new Function("self",text))( $S(selector) );},
     'alert':function(selector,text){alert( text );},
     'remove':function(selector){$S(selector).remove();}
  };

  $R.getHandler().addElementHandler( 'htmlArea', function( htmlAreas ){

    if( htmlAreas.get().length > 0 ) {

      htmlAreas.each(function() {
 
        var htmlArea     = $S(this);
        var action       = htmlArea.attr('action');
        var areaId       = htmlArea.attr('selector');
         
        if( $C.DEBUG.REQUEST )
          console.log( "Handle request, got area: "+areaId+' action: '+action );

        var checkSelector = $S.trim( htmlArea.attr('check') );
        if( '' == checkSelector )
          checkSelector = false;
        
        var actionElse = $S.trim( htmlArea.attr('else') );
        if( ''==actionElse )
          actionElse = false;
        
        var checkNot  = $S.trim( htmlArea.attr('not') );
        checkNot = ('true'==checkNot)?true:false
        
        if( !action || typeof action != 'string' || actions[action] === undefined ){
          
          $D.errorWindow('Sorry an Error Occured','Requested nonexisting Action: '+action);
        }
        else{
          
          if( checkSelector ){
            
            if( checkNot ){
              
              console.log("check not "+checkSelector);
              if( $S(checkSelector).length==0 ){
                
                actions[action](areaId, htmlArea.text());
              }
              ///TODO need some warning here?
              else if( actionElse && actions[actionElse] !== undefined ){
                
                actions[actionElse](checkSelector, htmlArea.text());
              }
            }
            else{
              
              if($S(checkSelector).length>0){
                
                actions[action](areaId, htmlArea.text());
              }
              ///TODO need some warning here?
              else if( actionElse && actions[actionElse] !== undefined ){
                
                actions[actionElse](checkSelector, htmlArea.text());
              }
            }
          }
          else{
            
            actions[action](areaId, htmlArea.text());
          }
        }

      });
    }
    
    if( $C.DEBUG.REQUEST )
      console.log( "Handled all areas" );
  
  });

})($S,$R);
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
(function( $R, $S ){

  $R.getHandler().addElementHandler( 'modal', function( childNodes ){

    childNodes.each(function(){
      
      $S.modal.close();

      var modalNode = $S(this);
      var modalBody = modalNode.find('body');
      var modalScript = modalNode.find('script').text();
      
      var title = modalNode.attr('title');
      if( title )
        $D.setTitle( title );
      
      var settings = {
          overlayClose: true,
          opacity:10
      };
      
      var mW = modalNode.attr('width');
      var mH = modalNode.attr('height');
      
      settings.minWidth = mW?parseInt(mW):600;
      settings.minHeight = mH?parseInt(mH):360;
      
      console.log( "minw: "+settings.minWidth+" maxw: "+settings.minHeight );
        
      var modalObj = $S.modal( modalBody.text(), settings  );
      
      if( modalScript )
        (new Function("self",modalScript))( $S('#simplemodal-container') );

    });
  
  });

})( $R, $S );
/* Licence see: /LICENCES/wgt/licence.txt */

"use strict";

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'req_ajax', function( jNode ){
  

  var dNode = jNode.get(0);
  
  if( $C.DEBUG.WCM.ACTION ){
    console.log( 'wcm req_ajax path: ' +jNode.getNodePath('/')  );
  }
  

  if( $WGT.nodeType(dNode,'a') ){
    
    jNode.click( function(){
      $R.get(this.href+"&request=ajax");
      return false;
    });
   
  }
  else if( $WGT.nodeType(dNode,'form') ){

    var inputField = jNode.find("input[type='submit']");

    //if submitField is there then continue
    if (typeof inputField == "object"){
      $S(inputField).click(function(){

        $R.form( jNode.prop('id') );
        return false;
      });   
    }
  }

  // remove the class
  jNode.removeClass('wcm_req_ajax');

});

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 * 
 * @wgt_param wgt_form Id des Formulars welches abgeschickt werden soll
 */
$R.addAction( 'req_form', function( jNode ){
  

  if( $C.DEBUG.WCM.ACTION ){
    console.log( 'wcm req_form path: ' +jNode.getNodePath('/')  );
  }
  
  jNode.bind( 'click.req_form', function(){
    $R.form( jNode.attr('wgt_form') );
  });
  

  // remove the class
  jNode.removeClass( 'wcm_req_form' );

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'req_conf', function( jNode ){
  
  if( $C.DEBUG.WCM.ACTION )
    console.log( 'wcm req_conf path: ' +jNode.getNodePath('/')  );

  jNode.click(function(){
    
    if( this.title == undefined )
      this.title = 'Please confirm this action.';

    $D.confirmWindow(
      this.title ,
      this.title ,
      'confirm',
      function (){$R.post(this.href+"&request=ajax");}
    );
    return false;
    
  });
  jNode.removeClass("wcm_req_conf");

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'req_del', function( jNode ){

  if( $C.DEBUG.WCM.ACTION )
    console.log( 'wcm req_del path: ' +jNode.getNodePath('/')  );
  
  jNode.click(function(){
    
    var delHref = this.href;

    if( this.title == undefined )
      this.title = 'are you shure, you want to delete this entry?';

    $D.confirmWindow(
      this.title ,
      this.title ,
      'delete',
      function (){$R.del(delHref+"&request=ajax");}
    );
      
    return false;
  });
  jNode.removeClass("wcm_req_del");

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'req_mainwin', function( jNode ){
  
  if( $C.DEBUG.WCM.ACTION )
    console.log( 'wcm req_mainwin path: ' +jNode.getNodePath('/')  );

  jNode.click(function(){
    
    $R.get(this.href+"&request=mainwindow");
    return false;
  });
  jNode.removeClass("wcm_req_mainwin");

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'req_page_size', function( jNode ){
  
  if( $C.DEBUG.WCM.ACTION )
    console.log( 'wcm req_page_size path: ' +jNode.getNodePath('/')  );
  
  try{
    
    var classNames  = jNode.prop("class").split(" ");
    var formId      = null;
  
    for(var i in classNames){
  
      if(classNames[i].toString().indexOf("wgt-form") != -1){
  
        formId = classNames[i];
        break; // break after the first match
      }
    }
    jNode.change(function(){
      
      if ($S('form#'+formId).data('changed')){
        
        $S('form#'+formId).data('change_handler')( function (){ 
          $S('form#'+formId).data('qsize',jNode.val());
          $S('form#'+formId).data('start','0');
          $R.form(formId);
          return false;
           
        });
      }
      else{
        
        $S('form#'+formId).data('qsize',jNode.val());
        $S('form#'+formId).data('start','0');
        $R.form(formId);        
      }
      return false;
    });
  }
  catch( err ){
    
    $D.errorWindow(err.description);
    return false;
  }

  jNode.removeClass( 'wcm_req_page_size' );

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'req_page', function( jNode ){
  
  if( $C.DEBUG.WCM.ACTION )
    console.log( 'wcm req_page path: ' +jNode.getNodePath('/')  );
  
  try{
    
    var classNames = jNode.prop("class").split(" ");
    var formId = null;
  
    for(var i in classNames){
      
      if(classNames[i].toString().indexOf("wgt-form") != -1){
        
        formId = classNames[i];
        break; // break after the first match
      }
    }
  
    // if the link has parent td, it should be clickable
    var td = jNode.parent().parent()[0];
     if( $WGT.nodeType(td,'td')) 
        var link=td;
     else
        var link=jNode.get();
  
    if( formId == null ||  $S('#'+formId).length == 0 ){
  
      $S(link).click(function(){
        $R.get(jNode.prop('href')+'&request=ajax');
        return false;
      });
    }
    else {
  
      var tmp = jNode.prop('href').split('=');
      //fix for ie
      tmp[0] = tmp[0].substring((tmp[0].length-1), tmp[0].length);
  
      if( 'b' == tmp[0] ){
        
        $S(link).click(function(){
          
          if ($S('form#'+formId).data('changed')){
           
            $S('form#'+formId).data('change_handler')( function (){ 
              
              $S('form#'+formId).data('start','0');
              $S('form#'+formId).data('begin',tmp[1]);
              //$S('form#'+formId).data('next',0);
              $R.form( formId ); 
              return false;
              
            }); 
              
             
          }
          else{
           
            $S('form#'+formId).data('start','0');
            $S('form#'+formId).data('begin',tmp[1]);
            //$S('form#'+formId).data('next',0);
            $R.form( formId ); 
          
          }
          return false;
        });
      }
      else{
  
        if('p' == tmp[0]){
  
          $S(link).click(function(){
            
            if ($S('form#'+formId).data('changed')){
              
              $S('form#'+formId).data('change_handler')( function (){
                $S('form#'+formId).data('start',tmp[1]);
                //$S('form#'+formId).data('next',0);
                $R.form( formId );
                return false;
               
              });                        
            }
            else{
              
             $S('form#'+formId).data('start',tmp[1]);
             //$S('form#'+formId).data('next',0);
             $R.form( formId );
            }
            return false;
          });
        }
        else{
  
          $S(link).click(function(){
            
            if( $S('form#'+formId).data('changed') ){
              
              $S('form#'+formId).data('change_handler')( function (){
                $S('form#'+formId).data('next',tmp[1]);
                $S('form#'+formId).data('start','0');
                $R.form( formId );
                return false;
              }); 
            }
            else{
              
              $S('form#'+formId).data('next',tmp[1]);
              $S('form#'+formId).data('start','0');
              $R.form( formId );
            }
            return false;
          });
        }
      }
    }

  }
  catch( err ){
    
    $D.errorWindow(err.description);
    return false;
  }
  
  jNode.removeClass( 'wcm_req_page' );

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'req_mtab', function( jNode ){
  
  if( $C.DEBUG.WCM.ACTION )
    console.log( 'wcm req_mtab path: ' +jNode.getNodePath('/')  );

  jNode.removeClass("wcm_req_mtab");
  
  if(!(jNode.is('a')||jNode.is('button')))
    return;
  
  if( jNode.is('a') ){
    /*
    $S('<span class="wgt-cursor-pointer" onclick="$R.get(\''+jNode.prop('href')+'&request=maintab\');" >'+jNode.html()+'</span>').insertAfter( jNode );
    jNode.hide();
    */
    
    jNode.click( function(){
      
      $R.get(this.href+"&request=maintab");
      return false;
    });
    
  }
  else{
    
    jNode.click(function(){
      $R.get( jNode.attr("value")+"&request=maintab" );
      return false;
    });
  }  


});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'req_win', function( jNode ){
  
  if( $C.DEBUG.WCM.ACTION )
    console.log( 'wcm req_win path: ' +jNode.getNodePath('/')  );

  jNode.removeClass("wcm_req_win");
  
  if(!(jNode.is('a')||jNode.is('button')))
    return;
  
  
  if( jNode.is('a') ){

    jNode.click( function(){
      
      $R.get(this.href+"&request=window");
      return false;
    });
    
  }
  else{
    
    jNode.click(function(){
      $R.get(this.href+"&request=window");
      return false;
    });
  }  

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'req_search', function( jNode ){
  
  if( $C.DEBUG.WCM.ACTION )
    console.log( 'wcm req_search path: ' +jNode.getNodePath('/')  );

  jNode.removeClass('wcm_req_search');
  
  var nForm = jNode.parentX('form');
  
  if( !nForm ){
    // ist als datavalue an eine form gebunden
    var formId = jNode.getActionClass('asgd',true,'-');
    
    if(!formId){
      // ist als parameter an eine form gebunden
      formId = jNode.getActionClass('fparam',true,'-');
    }
      
    if(!formId){
      console.log("found no form for the given search element");
      return;
    }
    nForm = $S('#'+formId);
    
    //console.log("found form "+formId);
  }
  
  /*
  jNode.change(function(){
    nForm.data('start','0');
    nForm.data('begin',null);
    
    $R.form( nForm );
    return false;
  });
  */
  
  // custom event to trigger a search event
  if( jNode.is('input[type=checkbox],input[type=hidden]') ){
    
    jNode.bind( 'change', function(e) {
      nForm.data('start','0');
      nForm.data('begin',null);
      $R.form( nForm );
      return false;
    });
    
  }
  else{
    
    // on return
    jNode.keyup(function(e) {
      
      if(e.keyCode == 13) {
        nForm.data('start','0');
        nForm.data('begin',null);
        
        $R.form( nForm );
        return false;
      }
    });
  }

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'action_appear', function( jNode ){
  
  if( $C.DEBUG.WCM.ACTION ){
    console.log( 'wcm action_appear path: ' +jNode.getNodePath('/')  );
  }
  
  jNode.removeClass('wcm_action_appear');
  
  try{
    
    var classNames = jNode.prop("class").split(" ");
    var formId     = null;
    var tableId    = null;
  
    for(var i in classNames){
      
      if(classNames[i].toString().indexOf("wgt-form") != -1){
        
        formId = classNames[i];
        
        if( tableId ){
          break; // break when the table is also allready found
        }
      }
      
      if(classNames[i].toString().indexOf("wgt_table") != -1){
        
        tableId = classNames[i];
        
        if( formId ){
          break; // break when the form is also allready found
        }
      }
      
    }
  
    jNode.appear(function(){
      
      jNode.unbind('click.action_appear');
      $S('form#'+formId).data('start',jNode.find('var').text());
      jNode.parent().remove();
      $R.form( 
        formId, 
        '&append=1',{
          async:true,
          append:true
        }
      );
    });
    
    // sollte appear warum auch immer nicht triggern machen wir das ding
    // halt noch klickbar, allerdings müsste oncklick auch appear so oder so
    // getriggert werden
    jNode.bind( 'click.action_appear',function(){
      
      jNode.unbind('click.action_appear');
      $S('form#'+formId).data('start',jNode.find('var').text());
      jNode.parent().remove();
      $R.form( 
        formId, 
        '&append=1',{
          async:true,
          append:true
        }
      );
    });
  
  }
  catch( err ){
    
    $D.errorWindow( err );
    return false;
  }
  

});

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'req_appear', function( jNode ){
  
  if( $C.DEBUG.WCM.ACTION ){
    console.log( 'wcm req_appear path: ' +jNode.getNodePath('/') );
  }
  
  jNode.removeClass( 'wcm_req_appear' );
  
  try{

  
    jNode.appear(function(){
      
      $R.get( jNode.attr('wgt_src') );
      jNode.unbind( 'click.action_appear' );

    });
    
    // sollte appear warum auch immer nicht triggern machen wir das ding
    // halt noch klickbar, allerdings müsste oncklick auch appear so oder so
    // getriggert werden
    jNode.bind( 'click.action_appear', function(){
      
      jNode.unbind( 'click.action_appear' );
      $R.get( jNode.attr('wgt_src'),{async:true} );
    });
  
  }
  catch( err ){
    
    $D.errorWindow( err );
    return false;
  }
  

});
/* Licence see: /LICENCES/wgt/licence.txt */


/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'control_context_menu', function( jNode ){

  jNode.removeClass("wcm_control_context_menu");

  var varData 	 = jNode.next();
  var useActions = jNode.attr('wgt_actions');


  var settings = varData.is('var') 
  ? $WGT.robustParseJSON( varData.text() )
  : {menu:jNode.attr('wgt_context_menu')};
  
  // Add contextMenu class
  var contextNode = $S( '#'+settings.menu );
  
  if( !contextNode.length ){
    console.log( 'Got no Contextmenu for #'+settings.menu );
    return false;
  }
 
  if( !contextNode.parent().is('#wgt_context_container') )
    $S('#wgt_context_container').append( contextNode );

  var actions = jNode.find('var.actions');
  
  if( actions )
    settings.actions = actions.text();

  jNode.contextMenu(
    settings,
    function( action, el, pos) {
      
      var actions = $S('#'+settings.menu).data('wgt-context-action');
      
      if( undefined === actions ){
        console.log( 'Missing Context Menu Actions for '+prop.attr('id')+' #'+settings.menu );
        return false;
      }

      if( undefined !== actions[action] ){
        var eid = jNode.attr('wgt_eid');
        actions[action]( el, pos, eid );
      }
      else{
        console.log( 'Missing Context Menu Action '+action );
      }
      
      return false;

    },
    useActions
  );

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'control_buttonset', function( jNode ){

  jNode.removeClass("wcm_control_buttonset");
  
  var settings = {};
  
  try{
    settings = jNode.next().is('var.c-buttonset')
    ? $WGT.robustParseJSON(jNode.next().text())
    : {};
  }
  catch(err){
    $D.errorWindow( 'UI Error', err.description );
  }

  jNode.buttonset( settings );

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'control_button', function( jNode ){

  jNode.removeClass("wcm_control_button");
  
  var settings = {};
  
  try{
    settings = jNode.next().is('var.c-button')
    ? $WGT.robustParseJSON(jNode.next().text())
    : {};
  }
  catch( err ){
    $D.errorWindow( 'Failed to read button settings '+jNode.getNodePath('/') , err.description );
  }

  jNode.button( settings );

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'controll_confirm', function( jNode ){

  jNode.removeClass( "wcm_ui_dialog" );
  jNode.dialog();

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'control_check_button', function( jNode ){

  jNode.removeClass( "wcm_control_check_button" );
  
  var inpNode = jNode.find( 'input' );
  
  if( inpNode.is( ':checked' ) ){
    jNode.addClass( 'active' );
  }

  // togle check onclick
  jNode.click( function( event ){
	  
    console.log( 'click '+inpNode.attr('name') );
	  
    if( inpNode.is( ':checked') ){
      
      inpNode.attr( 'checked', false );
      jNode.removeClass( 'active' );
      inpNode.change();
      
    }
    else{
      
      inpNode.attr( 'checked', 'checked' );
      inpNode.val(1);
      jNode.addClass( 'active' );
      inpNode.change();
      
    }
    
    event.stopPropagation();
      
  });

});
/* Licence see: /LICENCES/wgt/licence.txt */

/*
 
  Markup Beispiel
 
  <li id="li1" >
  Text
  <button id="button_1" class="wcm_ui_control_minidrop control_minidrop" style="font-size: 10px;display:none;" >Menu</button>
  <var>
  [
    {
      "type":"url",
      "action":"dump.php",
      "icon":"controls/entity.png",
      "label":"Entry 1"
    },
    {
      "type":"url",
      "action":"dump.php",
      "icon":"controls/entity.png",
      "label":"Entry 2"
    }
  ]
  </var>
  </li>
 */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'control_minidrop', function( jNode ){

  jNode.removeClass("wcm_control_minidrop");
  jNode.hide().addClass('controll-minidrop');
  
  jNode.parent().mouseover(function(){ 
    if( $S('button.controll-minidrop').length != 0 ){
      jQuery.fn.miniMenu.close();
      $S('button.controll-minidrop').hide(); 
    }
    $S(this).find('button.control-minidrop').show(); 
  });

  jNode.button({
    icons: {
      primary: "ui-icon-gear",
      secondary: "ui-icon-triangle-1-s"
    },
    text: false
  });

  var varData = jNode.next();

  var menuItems = varData.is('var') 
  ? $WGT.robustParseJSON( varData.text() )
  : {};

  jNode.miniMenu({
    globalClose : true,
    plain : true,
    closeParent: true,
    overlayStyle:{width:'120px'},
    menuItems   : menuItems
  });

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * Implementierung eines Split Buttons
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'control_split_button', function( jNode ){


  // parse the config
  var userSettings = {triggerEvent: 'click',align:'right'};
  var nodeId       = jNode.prop('id');
  jNode.addClass('wgt-split-button');

  if( jNode.parent().is('td') ){
    jNode.parent().css('text-align','left');
  }

  try{
    
    console.log( 'found confs '+ jNode.find( 'var#'+nodeId+'-cfg-split' ).length );

    var cfgNode = $S( 'var#'+nodeId+'-cfg-split' );
	  
    var tmp = null;
    
    if( cfgNode.length ){
      tmp = $WGT.robustParseJSON( cfgNode.text() );
      userSettings = tmp;
      cfgNode.remove();
    }

  }
  catch( err ){

    console.error( 'Parse cfg control.split.button: '+ err );
  }
	
  jNode.find('button.append').dropdown( userSettings );
  
  jNode.removeClass('wcm_control_split_button');
  
});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'control_dropmenu', function( jNode ){

  if( $C.DEBUG.WCM.WIDGET )
    console.log( 'wcm control_dropmenu path: ' +jNode.getNodePath('/')  );

  jNode.removeClass("wcm_control_dropmenu");

  var settings = {};

  try{

    var cfgData = $S('var#'+jNode.attr('id')+'-cfg-dropmenu');
    
    if( cfgData.is('var') ){
      settings = $WGT.robustParseJSON(cfgData.text());
      cfgData.remove();
    }
    else{
      settings = {};
    }

  }
  catch(err){
    
    if( undefined !== $D )
      $D.errorWindow( 'UI Error', err.description );
  }

  jNode.dropdown( settings );

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'control_selection', function( jNode ){

  if( $C.DEBUG.WCM.WIDGET )
    console.log( 'wcm control_selection path: ' +jNode.getNodePath('/')  );

  jNode.removeClass("wcm_control_selection");

  var settings = {};

  try{

    var cfgData = $S( 'var#'+jNode.attr('id')+'-cfg-selection' );
    
    if( cfgData.is('var') ){
      settings = $WGT.robustParseJSON( cfgData.text() );
      cfgData.remove();
    }
    else{
      settings = {};
    }

  }
  catch(err){
    
    if( undefined !== $D )
      $D.errorWindow( 'UI Error', err.description );
  }

  jNode.windowSelection( settings );

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_autocomplete', function( jNode ){

  // remove the wcm action class
  jNode.removeClass( "wcm_ui_autocomplete" );
  
  // check if this autocomplete field has a predefined type
  var cache    = {};
  var props    = {};
  var tmp      = jNode.next();
  
  var tmpProps = tmp.is('var') 
    ? $WGT.robustParseJSON(tmp.text())
    : {};
  
  // default lenght
  props.minLength = tmpProps.minLength || 3;
  
  // default source
  props.source = function( request, response ){
    var term = request.term;
    
    if ( term in cache ){
      response( cache[ term ] );
      return;
    }

    $R.get( 
      tmpProps.url+request.term, { 
        async:true, 
        success:function( rqt, data ){
          cache[term] = data;
          response( data );
    }});

    
  };
  
  // wenn clear gesetzt ist wird das input feld on close geleert
  if( tmpProps.clear ) {
    // onclose das inputfeld leeren
    props.close = function( event, ui ){
      jNode.val('');
    };
  }

  if( tmpProps.type && 'entity' == tmpProps.type ) {
	  
    props.select = function( event, ui ){

      if( ui.item ) {
        
        // remove -tostring from the end
        var strId = jNode.attr('id');
        var dataInp = $S('#'+strId.substr(0,(strId.length-9)));
        dataInp.val(ui.item.id);
        
        // if we have a formid send the form on select
        if( tmpProps.formid ) {
          
          $R.form( tmpProps.formid );
          
        }
        else if( tmpProps.send_to ) {
          
          var dataBody = '';
          
          if( tmpProps.fields )
            dataBody += $S(tmpProps.fields).serialize();
          
          $R.post( tmpProps.send_to, dataBody );
        }
          
      }
    };
    
  }
  else if( tmpProps.type && 'ajax' == tmpProps.type ){
    
    props.select = function( event, ui ) {
      if( ui.item && ui.item.url ) {
        $R.get( ui.item.url );
      }
    };
    
    jNode.click( function(){ jNode.val(''); } );
    
    /*
    // onclose das inputfeld leeren
    props.close = function( event, ui ) 
    {
      jNode.val('');
    };
    */
  }
  else if( tmpProps.type && 'data' == tmpProps.type ) {
    
    if( !tmpProps.formid ) {
      $D.error('Sorry, the programmer forgot to give an address for the autocomplete service. This is a bug. Please report to the author of tool.');
      return;
    }
    
    props.select = function( event, ui ){
      // prüfen ob bei der angegebenen addresse per data
      // über den service key eine funktion hinterlegt ist
      var service = $S('#'+tmpProps.formid).data(tmpProps.serviceKey||'connect');
      
      if( !service ){
        $D.error('Did not find a service provider for the given autocomplete service address. This is normally a bug. Please report to the developer of this tool.');
        return;
      }
      
      service( ui.item.id );
    };
    
    // onclose das inputfeld leeren
    props.close = function( event, ui ){
      jNode.val('');
    };
  }
  else if( tmpProps.type && 'callback' == tmpProps.type ) {
    
    // in clallback wird das ui element einfach einem definierten callback übergeben
    // wenn keine callback übergeben wurde wird nach wgt_autocomplete in data gesucht
    if( !tmpProps.callback )
      tmpProps.callback = 'wgt_autocomplete';

    props.select = function( event, ui ) {
      jNode.data( tmpProps.callback )( event, ui );
    };
    
  }
  

  jNode.autocomplete(props);

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_accordion', function( jNode ){
  
    var settings = {};
    
    try{
      
      var cfgData = jNode.next();
      settings = cfgData.is('var')
        ? $WGT.robustParseJSON(cfgData.text())
        : {autoHeight: true,fillSpace: true,animated: false};
    }
    catch(err){
      
      $D.errorWindow( 'UI Error', err.description );
    }
  
    jNode.accordion(settings);
    jNode.removeClass('wcm_ui_accordion');

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_accordion_tab', function( jNode ){
  
    var settings = {};
    
    try{
      
      var cfgData = jNode.next();
      settings = cfgData.is('var')
        ? $WGT.robustParseJSON(cfgData.text())
        : {autoHeight: true,fillSpace: true,animated: false};
    }
    catch(err){
      
      $D.errorWindow( 'UI Error', err.description );
    }
    
    var accObj = $S( '#'+jNode.prop('id')+'-head' );
    var contObj = $S( '#'+jNode.prop('id')+'-content' ).contentContainer();

    accObj.accordion(settings);
    
    // switch workarea
    accObj.bind('accordionchangestart',function(event,ui){
      
      var headEntry = ui.newHeader.find('a');
      
      if( headEntry.hasClass('disabled') )
        return false;
      
      // potentiell offenen menü schliesen
      $D.requestCloseMenu();
      // schliesen des Menüs nach dem Request
      $D.requestCloseMenu = function(){};
      
      var tmpRef = headEntry.attr('tab');
      var tmpSrc = headEntry.attr('wgt_src');
      
      if( tmpSrc && !headEntry.is('.loaded') ){
        headEntry.addClass('loaded');
        $R.get( tmpSrc, {async:true} );
      }
      
      contObj.contentContainer( 'setActive' ,tmpRef );
    });
    
    jNode.removeClass('wcm_ui_accordion_tab');

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_button', function( jNode ){

  jNode.removeClass("wcm_ui_button");
  jNode.addClass('wgt-button');
  
  
  // wenn ein wgt_send attribute vorhanden ist
  // versucht der button automatisch das formular dessen id im wgt_send=""
  // vorhanden ist zu submitten
  var sendAction = jNode.attr('wgt_send');
  if( sendAction ){
    jNode.click(function(){
      $R.form(sendAction);
      return false;
    });
  }
  
  //jNode.button();
  //jNode.addClass('ui-state-default ui-corner-all');

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_buttonset', function( jNode ){

  jNode.removeClass("wcm_ui_buttonset");
  
  jNode.find('button').addClass('wgt-button');
  
  //jNode.buttonset();

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_calendar', function( jNode ){
  
  
  jNode.removeClass('wcm_ui_calendar');
  
  jNode.appear(function(){
  var dataBody = jNode.next();
  
  var tmpId = jNode.attr('id');
  tmpId = tmpId.substring( 4, tmpId.length );
  
  var formObj = $S('#wgt-form-'+tmpId); ;
  
  // var ist der datencontainer der benötigt wird um einen callendar
  // mit daten zu befüllen
  if( !dataBody.is('var') )
  {
    alert('found no body');
    return;
  }
  
  // extrahieren der json daten aus dem request
  dataBody = $S.parseJSON( dataBody.text() );

  // erstellen des calendar nodes
  var calendarObj = jNode.fullCalendar({
    
      header: {
          left: 'prevYear,prev,today,next,nextYear',
          center: 'title',
          right: 'month,agendaWeek,agendaDay'
      },
      editable: true,
      events: dataBody.data||[], // wenn data nicht existiert einen leeren array übergeben
      eventDrop: function(event,dayDelta,minuteDelta,allDay,revertFunc) 
      {
        
        // Event verschieben
        alert(
            event.title + " was moved " +
            event.start.toString("yyyy-mm-dd") + " new start "
        );

      },
      eventResize: function(event,dayDelta,minuteDelta,revertFunc) 
      {

        alert(
            event.title + " was resized " +
            event.start.toString("yyyy-mm-dd") + " new start "
        );

      }

  });
  
  // das calendar objekt wird an ein formular gebunden
  formObj.data( 'wgt-calendar' , calendarObj );
  });
  
  

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_color_code', function( jNode ){
  
  jNode.removeClass('wcm_ui_color_code');
  
  var code = jNode.getActionClass('prop_key');
  
  jNode.parent().css('background-color',$C.colorCodes[code][jNode.val()]);
  
  jNode.change(function(){
    jNode.parent().css('background-color',$C.colorCodes[code][jNode.val()]);
  });

});

/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_console', function( jNode ){

  jNode.removeClass("wcm_ui_console");

  jNode.draggable();
  jNode.resizable({
    helper: "ui-resizable-helper",
    ghost: true
  });

  
  //jNode.button();
  //jNode.addClass('ui-state-default ui-corner-all');

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_combobox', function( jNode ){

  jNode.removeClass( "wcm_ui_combobox" );
  jNode.combobox();
  
});



/* Licence see: /LICENCES/wgt/licence.txt */

(function( $S, $R ) {

  /**
   * @author dominik alexander bonsch <db@webfrap.net>
   */
  $R.addAction( 'ui_dbl_list_selector', function( jNode ){

    jNode.removeClass( "wcm_ui_dbl_list_selector" );

    var settings = {};

    try{

      var cfgData = $S( 'var#'+jNode.attr('id')+'-cfg-dbl_list' );
      
      if( cfgData.is('var') ){
        settings = $WGT.robustParseJSON( cfgData.text() );
        cfgData.remove();
      }
      else{
        settings = {};
      }

    }
    catch(err){
      
      if( undefined !== $D )
        $D.errorWindow( 'UI Error', err.description );
    }
    
    jNode.dblListSelector( settings );
    
  });

  
})( jQuery, $R );






/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */

$R.addAction( 'ui_date', function( jNode ){
  
  jNode.removeClass('wcm_ui_date');
  
  var node;
  
  jNode.addClass('valid_date');
  
  if( jNode.is("input") ){
    
    node = jNode.next();
  }
  else{

    node = jNode.find('var.opt_options');
  }
  
  // if you want to use wgt default settings and not system settings
  if( jNode.hasClass('wgt_default') ){

    jNode.datepicker();
  }
  else{

    jNode.datepicker({
      dateFormat: $C.formatDate,
      changeMonth: true,
      changeYear: true,
      showWeek: true,
      constrainInput: true,
      buttonImageOnly: true
    });
  }

  if( $S( '#'+jNode.attr('id')+'-ap-button' ).is('button') ){
    $S( '#'+jNode.attr('id')+'-ap-button' ).click( function(){
      jNode.datepicker('show');
    });
  }
  else if( jNode.is('div') ){
    jNode.click( function(){
      jNode.datepicker('show');
    });
  }
  
  if( node ){
    
    var options = node.attr( 'options' );
    options = $WGT.robustParseJSON( options );
  }
  
  if( Boolean(options) )
    jNode.datepicker( "option", options );

});


// settings.hasclasss();
//console.log("src", $C.iconCallendar);
//jNode.prepend("<img src='" + $C.iconCallendar + "' />");
//var tmp = jNode.datepicker('option', 'showWeek');
//jQuery.extend(tmp, options); 
/*
dateFormat: 'yy-mm-dd',
showOn: "both",
altField: _endDate
buttonImage: $C.iconCallendar,
buttonImageOnly: true,

*/
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */

$R.addAction( 'ui_date_timepicker', function( jNode ){
  
  jNode.removeClass('wcm_ui_date_timepicker');
  
  var node;
  
  jNode.addClass('valid_date_time');
  
  if( jNode.is("input") ){
    
    node = jNode.next();
  }
  else{

    node = jNode.find('var.opt_options');
  }
  
  // if you want to use wgt default settings and not system settings
  if( jNode.hasClass('wgt_default') ){

    jNode.datetimepicker();
  }
  else{

    jNode.datetimepicker({
      dateFormat: $C.formatDate,
      changeMonth: true,
      changeYear: true,
      showWeek: true,
      constrainInput: true,
      buttonImageOnly: true
    });
  }

  if( $S( '#'+jNode.attr('id')+'-ap-button' ).is('button') ){
    $S( '#'+jNode.attr('id')+'-ap-button' ).click( function(){
      jNode.datetimepicker('show');
    });
  }
  else if( jNode.is('div') ){
    jNode.click( function(){
      jNode.datetimepicker('show');
    });
  }
  
  if( node ){
    
    var options = node.attr( 'options' );
    options = $WGT.robustParseJSON( options );
  }
  
  if( Boolean(options) )
    jNode.datetimepicker( "option", options );

});

/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_dialog', function( jNode ){

  jNode.removeClass("wcm_ui_dialog");
  jNode.dialog();

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author Marko Andrijasevic
 */
$R.addAction( 'mwin_footer', function( jNode ){
  jNode.footer();
  
  jNode.removeClass('wcm_mwin_footer');
});

/* Licence see: /LICENCES/wgt/licence.txt */


/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_gallery', function( jNode ){
  
  // laden der wysiwyg konfiguration
  try{
    
    var cfgData = jNode.next();
    var settings = cfgData.is('var#'+jNode.attr('id')+'-cfg-wysiwyg')
      ? $WGT.robustParseJSON(cfgData.text())
      : {};
  }
  catch(err){
    
    $D.errorWindow( 'UI Error', err.description );
  }
  
  jNode.removeClass('wcm_ui_gallery');
  
  if( !jNode.is('wgt-gallery') ) 
    jNode.addClass( 'wgt-gallery' );
  
  // We only want these styles applied when javascript is enabled
  //$('div.navigation').css({'width' : '300px', 'float' : 'left'});
  //$('div.content').css('display', 'block');

  var galleryId = jNode.attr('id');
  
  // Initially set opacity on thumbs and add
  // additional styling for hover effect on thumbs
  var onMouseOutOpacity = 0.67;
  $S('#'+galleryId+'-thumbs ul.thumbs li').opacityrollover({
     mouseOutOpacity:   onMouseOutOpacity,
     mouseOverOpacity:  1.0,
     fadeSpeed:         'fast',
     exemptionSelector: '.selected'
  });

  // Enable toggling of the caption
  var captionOpacity = 0.7;
  $S('button#'+galleryId+'-caption_toggle').click(function(e) {
     var link = $S(this);
     
     var isOff = link.hasClass('off');
     var removeClass = isOff ? 'off' : 'on';
     var addClass = isOff ? 'on' : 'off';
     var linkText = isOff ? 'Hide Caption' : 'Show Caption';
     captionOpacity = isOff ? 0.7 : 0.0;

     link.removeClass(removeClass).addClass(addClass).text(linkText).attr('title', linkText);
     $S('#'+galleryId+'-caption span.image-caption').fadeTo(1000, captionOpacity);
     
     e.preventDefault();
  });
  
  // Initialize Advanced Galleriffic Gallery
  var gallery = $S('#'+galleryId+'-thumbs').galleriffic({
     delay:                     2500,
     numThumbs:                 9,
     preloadAhead:              10,
     enableTopPager:            true,
     enableBottomPager:         true,
     maxPagesToShow:            7,
     imageContainerSel:         '#'+galleryId+'-slideshow',
     controlsContainerSel:      '#'+galleryId+'-controls',
     captionContainerSel:       '#'+galleryId+'-caption',
     loadingContainerSel:       '#'+galleryId+'-loading',
     renderSSControls:          true,
     renderNavControls:         true,
     playLinkText:              'Play Slideshow',
     pauseLinkText:             'Pause Slideshow',
     prevLinkText:              '&lsaquo; Previous Photo',
     nextLinkText:              'Next Photo &rsaquo;',
     nextPageLinkText:          'Next &rsaquo;',
     prevPageLinkText:          '&lsaquo; Prev',
     enableHistory:             false,
     autoStart:                 false,
     syncTransitions:           true,
     defaultTransitionDuration: 900,
     onSlideChange:             function(prevIndex, nextIndex) {
       
      // 'this' refers to the gallery, which is an extension of $('#thumbs')
      this.find('ul.thumbs').children()
        .eq(prevIndex).fadeTo('fast', onMouseOutOpacity).end()
        .eq(nextIndex).fadeTo('fast', 1.0);
     },
     onTransitionOut:           function(slide, caption, isSync, callback) {
       
        slide.fadeTo(this.getDefaultTransitionDuration(isSync), 0.0, callback);
        caption.fadeTo(this.getDefaultTransitionDuration(isSync), 0.0);
     },
     onTransitionIn:            function(slide, caption, isSync) {
       
        var duration = this.getDefaultTransitionDuration(isSync);
        slide.fadeTo(duration, 1.0);
          
          // Position the caption at the bottom of the image and set its opacity
        var slideImage = slide.find('img');
        caption.width(slideImage.width())
         .css({
          'bottom' : Math.floor((slide.height() - slideImage.outerHeight()) / 2),
          'left' : Math.floor((slide.width() - slideImage.width()) / 2) + slideImage.outerWidth() - slideImage.width()
         })
         .fadeTo(duration, captionOpacity);
     },
     onPageTransitionOut:       function(callback) {
       
        this.fadeTo('fast', 0.0, callback);
     },
     onPageTransitionIn:        function() {
       
        this.fadeTo('fast', 1.0);
     },
     onImageAdded:              function(imageData, $li) {
       
        $li.opacityrollover({
         mouseOutOpacity:   onMouseOutOpacity,
         mouseOverOpacity:  1.0,
         fadeSpeed:         'fast',
         exemptionSelector: '.selected'
        });
     }
       
  });

});


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_grid', function( jNode ){


  jNode.removeClass("wcm_ui_grid");
  
  
  jNode.find('tbody>tr')
    .mouseover( function(){
      
     $S(this).addClass('wgt-hover'); 
    })
    .mouseout(function(){
      
      $S(this).removeClass('wgt-hover'); 
    })
    .click(function(){
      
      $S(this).toggleClass( 'wgt-selected' );
    });
  
  jNode.appear(function(){
    
    var tObj = $S('#'+jNode.attr('id'));
    
    var settings = {};
    
    try{
      
      var cfgData = $S('var#'+jNode.attr('id')+'-cfg-grid');
      settings = cfgData.is('var')
        ? $WGT.robustParseJSON(cfgData.text())
        : {};
    }
    catch(err){
      
      $D.errorWindow( 'UI Error', err.description );
    }

    tObj.grid(settings);
  });
  
});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_highlight', function( jNode ){

  jNode.removeClass("wcm_ui_highlight");

  jNode
    .mouseover( function(){
      
      var theClass = jNode.prop('class');
      var cKey = $WGT.getClassByPrefix( theClass, 'node-', false );
      
      if( cKey ){
        jNode.parent().find('.'+cKey).addClass('wgt-hover'); 
      }
      else{
        jNode.addClass('wgt-hover'); 
      }
    })
    .mouseout(function(){
      
      var theClass = jNode.prop('class');
      var cKey = $WGT.getClassByPrefix( theClass, 'node-', false  );
      
      if( cKey ){
        jNode.parent().find('.'+cKey).removeClass('wgt-hover'); 
      }
      else{
        jNode.removeClass('wgt-hover'); 
      }
      
    });

});


/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_highlight2', function( jNode ){

  jNode.removeClass("wcm_ui_highlight2");

  jNode
    .mouseover( function(){

      var theClass = jNode.prop('class');
      var cKey = $WGT.getClassByPrefix( theClass, 'node-', false );

      if( cKey ){
        jNode.parent().find('.'+cKey).addClass('wgt-hover2');
      }
      else{
        jNode.addClass('wgt-hover2');
      }
    })
    .mouseout(function(){

      var theClass = jNode.prop('class');
      var cKey = $WGT.getClassByPrefix( theClass, 'node-', false  );

      if( cKey ){
        jNode.parent().find('.'+cKey).removeClass('wgt-hover2');
      }
      else{
        jNode.removeClass('wgt-hover2');
      }

    });

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_info', function( jNode ){

  jNode.tooltip({
    extraClass: "pretty", 
    top: -15,
    opacity: 0.5
  }).removeClass("wcm_ui_info");

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_link_info', function( jNode ){

  jNode.tooltip({
    track: true,
    delay: 0
  }).removeClass("wcm_ui_link_info");

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'menu_table', function( jNode ){

  var head      = jNode.parentX('th');
  var menuWidth = head.width();

  if( 170 < menuWidth ){
    menuWidth = 170;
  }
  else if( 190 > menuWidth ){
    menuWidth = 190;
  }

  var tabCol = $UI.tableCol(head);
  var menuItems = [];
  /*
  menuItems.push({
    type      : 'activInput',
    minChars  : 3,
    filter    : function( userInput ){ tabCol.filter(userInput); },
    reset     : function(){ tabCol.reset(); }
  });
  */
  ///TODO add i from search form to make order persistent
  menuItems.push({
    type      : 'sortbox',
    url       : 'index.php',
    colId     : 'fubar',
    direction : null
  });

  // check if there are any json data in a data container
  if(head.find("span.wgt_data_container").is("span")){
    // add seperator
    menuItems.push({type:'sep'});
    var elements = $WGT.robustParseJSON(head.find("span.wgt_data_container").text());
    menuItems.push({
      type      : 'cheklist',
      mode      : 'serialize',
      name      : 'hans_wurst',
      elements  : elements
    });

  }

  jNode.miniMenu({
    button      : 'close',
    overlayStyle:{width:menuWidth+'px'},
    menuItems   : menuItems
  });

  jNode.removeClass('wcm_menu_table');
  
});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */

$R.addAction( 'ui_month', function( jNode ){

  jNode.monthpicker({
    buttonImage: $C.iconCallendar
  }).removeClass('wcm_ui_month');
  
  /*
  jNode.find('#ui-monthpicker-div .ui-datepicker-year option').each(function(){
    if($(this).val()==year)
      $(this).attr("selected","selected");
  });

  jNode.find('.month'+month+' a').addClass("ui-state-highlight");
  
  jNode.removeClass('wcm_ui_month');
  */

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_progress', function( jNode ){

  
  if( jNode.is(':input') ){
    jNode.progressbar({
      value: $S(this).val()
    });
  }
  else
  {
    var size = parseInt(jNode.text());
    jNode.text('');
    jNode.height( '16' );
  
    jNode.progressbar({
      value: size
    });
  
    jNode.attr('title','Progress: '+size+' %');
    
    jNode.wgtTip({
      gravity: 's'
    });
  }
  
  jNode.removeClass('wcm_ui_progress');

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_tab', function( jNode ){

  if( $C.DEBUG.WCM.UI )
    console.log( 'wcm ui_tab path: ' +jNode.getNodePath('/')  );
  
  jNode.appear(function(){

    var settings = {};

    try{

      var cfgData = $S('var#'+jNode.attr('id')+'-cfg-tab');
      settings = cfgData.is('var')
        ? $WGT.robustParseJSON(cfgData.text())
        : {};
    }
    catch(err){

      $D.errorWindow( 'UI Error', err.description );
    }

    jNode.addClass('wgt_tab_container').addClass('wgt_initialized');
    $UI.tab.init( jNode.prop('id'), settings );
  });
  
  jNode.removeClass('wcm_ui_tab');

});


$R.addAction( 'ui_tab_head', function( jNode ){

  if( $C.DEBUG.WCM.UI )
    console.log( 'wcm ui_tab_head path: ' +jNode.getNodePath('/')  );
  
  jNode.appear(function(){

    var settings = {};

    try{

      var cfgData = $S('var#'+jNode.attr('id')+'-cfg-tab');
      settings = cfgData.is('var')
        ? $WGT.robustParseJSON(cfgData.text())
        : {};
    }
    catch(err){

      $D.errorWindow( 'UI Error', err.description );
    }

    jNode.tabHead( settings );
    
  });
  
  jNode.removeClass('wcm_ui_tab_head');

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_table', function( jNode ){

  jNode.removeClass("wcm_ui_table");

  jNode.find('tbody>tr')
    .mouseover( function(){
     $S(this).addClass('wgt-hover'); 
    })
    .mouseout(function(){
      $S(this).removeClass('wgt-hover'); 
    });

  
});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author Marko Andrijasevic
 */
$R.addAction( 'ui_modal', function( jNode ){
  

  var user = {};
  var settings = { modal: true,
		draggable: false,
		resizable: false };
  
  try{
    user = jNode.next().is('var.c-modal')
    ? $WGT.robustParseJSON(jNode.next().text())
    : {};
  }
  catch(err){
    $D.errorWindow( 'UI Error', err.description );
  }
  
  //$S.extend( true, settings, user );

  jNode.dialog( settings );
  jNode.removeClass('ui_modal');
  
  
});

/* Licence see: /LICENCES/wgt/licence.txt */



/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_tree', function( jNode ){

  var settings = {};
  try{
    
    var cfgData = jNode.find('var#'+jNode.attr('id')+'-cfg-tree');
    settings = cfgData.is('var')
      ? $WGT.robustParseJSON(cfgData.text())
      : {};
    
    settings.imagePath = $C.imagePath+'wgt/';
  }
  catch(err){
    
    $D.errorWindow( 'UI Error', err.description );
  }

  jNode.dynatree( settings ).removeClass('wcm_ui_tree');


});


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_tooltip', function( jNode ){

  jNode.tooltip({
    track: true,
    delay: 0,
    showURL: false,
    showBody: " - ",
    extraClass: "boxed",
    fixPNG: true,
    opacity: 0.2,
    left: -120
  }).removeClass("wcm_ui_tooltip");

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */

$R.addAction( 'ui_timepicker', function( jNode ){
  
  jNode.removeClass('wcm_ui_timepicker');
  
  var node;
  
  jNode.addClass('valid_time');
  
  if( jNode.is("input") ){
    
    node = jNode.next();
  }
  else{

    node = jNode.find('var.opt_options');
  }
  
  // if you want to use wgt default settings and not system settings
  if( jNode.hasClass('wgt_default') ){

    jNode.timepicker();
  }
  else{

    jNode.timepicker({
      dateFormat: $C.formatDate,
      changeMonth: true,
      changeYear: true,
      showWeek: true,
      constrainInput: true,
      buttonImageOnly: true
    });
  }

  if( $S( '#'+jNode.attr('id')+'-ap-button' ).is('button') ){
    $S( '#'+jNode.attr('id')+'-ap-button' ).click( function(){
      jNode.timepicker('show');
    });
  }
  else if( jNode.is('div') ){
    jNode.click( function(){
      jNode.timepicker('show');
    });
  }
  
  if( node ){
    
    var options = node.attr( 'options' );
    options = $WGT.robustParseJSON( options );
  }
  
  if( Boolean(options) )
    jNode.timepicker( "option", options );

});

/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_tip', function( jNode ){

  if( jNode.is('button') || jNode.is('p') || jNode.is('a')  )
  {
    jNode.wgtTip({
      gravity: 's',
      delayIn: 700, 
      delayOut: 200
    }).removeClass("wcm_ui_tip");
  }
  else
  {
    jNode.wgtTip({
      gravity: 'w',
      delayIn: 700, 
      delayOut: 200
    }).removeClass("wcm_ui_tip");
  }
    
});

$R.addAction( 'ui_tip-top', function( jNode ){

  jNode.wgtTip({
    gravity: 's',
    delayIn: 700, 
    delayOut: 200
  }).removeClass("wcm_ui_tip-top");
    
});

$R.addAction( 'ui_tip-l', function( jNode ){

  jNode.wgtTip({
    delayIn: 700, 
    delayOut: 200
  }).removeClass("wcm_ui_tip-l");
    
});



// noch vorhandene tips nach ajax requests entfernen
$R.addAfterAjaxRequest( function(){

  $S('.wgt-tip').remove();
    
});

/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_dropform', function( jNode ){

  var source = jNode.find( 'var' );
  
  var props  = source.is( 'var' ) 
  ? $WGT.robustParseJSON( source.text() )
  : {};
  
  if( source.length > 0 ){
    
    jNode.click(function( event ){
      
      var nextNode = jNode.next();
      var nodeId   = jNode.attr('id');
      
      if( !nextNode.is( '.'+nodeId ) ){

        var theTemplate = $R.get( props.url+'&input='+nodeId ).data;
        jNode.after( '<div class="'+nodeId+' template" >'+theTemplate+'</div>' );
        
        //var theContentNode = $S( '.'+nodeId );
        var theContent = $S( '<div>'+theTemplate+'</div>' );
        
        var menuWidth = menuWidth = 450;
        var menuItems = [];
                
        theContent.find( ':input' ).removeClass( 'flag-template' );

        ///TODO add i from search form to make order persistent
        menuItems.push({
          type    : 'html',
          content : theContent.html()
        });

        jNode.miniMenu({
          button      : 'Close',
          plain       : false,
          globalClose : false,
          align : 'middle',
          overlayStyle: {width:menuWidth+'px'},
          menuItems   : menuItems
        });
        
        jNode.click();
      }
      
      event.stopPropagation();
          
    });
  }
  else
  {
      
    var theContentNode = $S( '.'+jNode.attr('id') );
    var theContent = $S('<div>'+theContentNode.html()+'</div>');
    
    var menuWidth = menuWidth = 450;
  
    var menuItems = [];
        
    theContent.find(':input').removeClass('flag-template');
  
    ///TODO add i from search form to make order persistent
    menuItems.push({
      type    : 'html',
      content : theContent.html()
    });
  
    jNode.miniMenu({
      button      : 'Close',
      plain 	  : false,
      globalClose : false,
      overlayStyle:{width:menuWidth+'px'},
      menuItems   : menuItems
    });
    
  }
  

  jNode.removeClass('wcm_ui_dropform');
  
});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_processform', function( jNode ){


  jNode.click(function( event ){
    
    var nextNode = jNode.next();
    var nodeId   = jNode.attr('id');
    
    if( !nextNode.is( '.'+nodeId ) ){

      $R.get( jNode.find('var').text()+'&input='+nodeId );
      
      var theContentNode = $S( '.'+nodeId );
      var theContent = $S( '<div>'+theContentNode.html()+'</div>' );
      
      var menuWidth = menuWidth = 450;

      var menuItems = [];
      
      
      theContent.find(':input').removeClass('flag-template');

      ///TODO add i from search form to make order persistent
      menuItems.push({
        type    : 'html',
        content : theContent.html()
      });

      jNode.miniMenu({
        button      : 'Close',
        globalClose : false,
        align : 'middle',
        overlayStyle:{width:menuWidth+'px'},
        menuItems   : menuItems
      });
      
      event.stopPropagation();
      
      jNode.click();
    }
    
    return false;
    
  });
  
  jNode.removeClass('wcm_ui_processform');
  
});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_selectbox_filter', function( jNode ){

  jNode.removeClass( "wcm_ui_selectbox_filter" );

  jNode.bind( 'click.wgt_selectbox_filter', function(){

    var self = $S(this),
      filter = self.find('option:selected').attr( 'filter_key' );

    var filtered = $S('.wgt-filter-select-'+self.attr('id')+'.flag_orig' );
    
    filtered.each( function(){
      var slb = $S(this);
      slb.attr( 'wgt_filter', filter );
      
      var tmpId = slb.attr( 'id' );
      var mainId = tmpId.substring( 0, (tmpId.length - 5)  );

      var newFElem = slb.clone();
      $S( '#'+mainId+'-cnt' ).remove();
      newFElem.attr( 'id', mainId );
      newFElem.attr( 'disabled', false );
      newFElem.removeClass( 'flag_orig' );
      newFElem.find( 'option' ).not( 'option.filter_'+filter+',option.no_filter' ).remove();
      newFElem.insertAfter( slb );
      newFElem.show();
      newFElem.rselectbox();
      newFElem.parent().attr( 'id', mainId+'-cnt'  );

    });
    
  });

  //$R.callAction( 'widget_selectbox', jNode );

});


/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_selectbox_filtered', function( jNode ){

  jNode.removeClass( "wcm_ui_selectbox_filtered" );
  //$R.callAction( 'widget_selectbox', jNode );

  var origId = jNode.attr('id');
  
  var filterBoxId = $WGT.getClassByPrefix( jNode.prop('class'),  'wgt-filter-select-', true );

  var newEle = jNode.clone();
  
  jNode.attr( 'id', origId+'-orig' );
  jNode.attr( 'disabled', true );
  jNode.addClass( 'flag_orig' );
  jNode.hide();
  newEle.insertAfter( jNode );


  newEle.bind( 'mouseenter.selectbox_filtered', function(){
    console.log('click #'+filterBoxId);
    newEle.unbind('mouseenter.selectbox_filtered');
    $S('#'+filterBoxId).click();
  });

  newEle.rselectbox();
  newEle.parent().attr( 'id', origId+'-cnt'  );

    /*
  var defFilter = jNode.attr( 'wgt_filter' );
  newEle.find( 'option' ).not( 'option.filter_'+defFilter+',option.no_filter' ).remove();
     */

});
/* Licence see: /LICENCES/wgt/licence.txt */

(function( $S, $R ) {

  /**
   * @author dominik alexander bonsch <db@webfrap.net>
   */
  $R.addAction( 'ui_dbl_list_selector', function( jNode ){

    jNode.removeClass( "wcm_ui_dbl_list_selector" );

    var settings = {};

    try{

      var cfgData = $S( 'var#'+jNode.attr('id')+'-cfg-dbl_list' );
      
      if( cfgData.is('var') ){
        settings = $WGT.robustParseJSON( cfgData.text() );
        cfgData.remove();
      }
      else{
        settings = {};
      }

    }
    catch(err){
      
      if( undefined !== $D )
        $D.errorWindow( 'UI Error', err.description );
    }
    
    jNode.dblListSelector( settings );
    
  });

  
})( jQuery, $R );






/* Licence see: /LICENCES/wgt/licence.txt */


/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_wysiwyg', function( jNode ){
  
  // laden der wysiwyg konfiguration
  try{
    
    var cfgData = jNode.next();
    var settings = cfgData.is('var#'+jNode.attr('id')+'-cfg-wysiwyg')
      ? $WGT.robustParseJSON(cfgData.text())
      : {};
  }
  catch(err){
    
    $D.errorWindow( 'UI Error', err.description );
  }
  
  jNode.removeClass('wcm_ui_wysiwyg');
  
  /**
   * define an editor mode, valid modes are:
   * - simple     einfacher editor
   * - rich_text  just text
   * - cms        cms author
   * - full
   */
  if( settings.mode === undefined ){

    var tmpMode = jNode.attr('wgt_mode');

    if( undefined !== tmpMode )
      settings.mode = tmpMode;
    else
      settings.mode = 'simple';

  }
  if( jNode.attr('wgt_mode') ){
    
    settings.mode = jNode.attr('wgt_mode');
  }
  
  if( settings.width === undefined )
    settings.width = 740;
  
  if( settings.height === undefined )
    settings.height = 300;
  
  /**
   * Key / Value based variables
   * @example
   * {
   *   username : "Some User",
   *   staffid : "991234"
   * }
   */
  if( settings.template_replace_values === undefined )
    settings.template_replace_values = {};
  
  
  if( 'simple' === settings.mode ){
    
    settings.theme   = 'simple';
    settings.plugins = '';
    
    settings.theme_advanced_buttons1 = null;
    settings.theme_advanced_buttons2 = null;
    settings.theme_advanced_buttons3 = null;
    settings.theme_advanced_buttons4 = null;

    
  } else if ( 'rich_text' == settings.mode ) {
    
    settings.theme   = 'advanced';
    
    settings.plugins = "pagebreak,advhr,"
      + "advimage,advlink,emotions,inlinepopups,"
      + "insertdatetime,preview,searchreplace,"
      + "contextmenu,paste,directionality,fullscreen,noneditable,"
      + "visualchars,nonbreaking,xhtmlxtras";
    
    settings.theme_advanced_buttons1 = "newdocument,|,bold,italic,underline,strikethrough,|"
      +",sub,sup,|,justifyleft,justifycenter,justifyright,justifyfull,formatselect,"
      +"fontselect,fontsizeselect,|,forecolor,backcolor";
    settings.theme_advanced_buttons2 = "cut,copy,paste,pastetext,pasteword,|,search,replace,|"
      +",bullist,numlist,|,outdent,indent,blockquote,|,link,unlink,anchor,"
      +"cleanup,|,insertdate,inserttime,|,charmap,emotions,ltr,rtl,|,hr,removeformat,visualaid";
    settings.theme_advanced_buttons3 = "undo,redo,|,fullscreen,|,code,|,cite,abbr,acronym,del,ins,|,visualchars,nonbreaking,pagebreak";
    settings.theme_advanced_buttons4 = null;
    
  } else if ( 'cms' == settings.mode || 'know_how' == settings.mode ) {
    
    settings.theme   = 'advanced';
    
    settings.plugins = "pagebreak,style,layer,table,advhr,"
      + "advimage,advlink,emotions,iespell,inlinepopups,"
      + "insertdatetime,preview,media,searchreplace,print,"
      + "contextmenu,paste,directionality,fullscreen,noneditable,"
      + "visualchars,nonbreaking,xhtmlxtras,template,wgt_mediatheke,wgt_knowhow";
    
    settings.theme_advanced_buttons1 = "bold,italic,underline,strikethrough,|,sub,sup,|"
      +",justifyleft,justifycenter,justifyright,justifyfull,|,forecolor,backcolor,|,styleselect,formatselect,"
      +"fontsizeselect";
    
    settings.theme_advanced_buttons2 = "cut,copy,paste,pastetext,pasteword,|,search,replace,|"
      +",bullist,numlist,|,outdent,indent,blockquote,|,ltr,rtl,|,link,unlink,anchor";
    
    settings.theme_advanced_buttons3 = "tablecontrols,|,hr,removeformat,visualaid,|"
      +",charmap,emotions,iespell,image,wgt_mediatheke,wgt_knowhow,|,insertdate,inserttime";
    
    settings.theme_advanced_buttons4 = "undo,redo,|,fullscreen,code,cleanup,|,cite,abbr,acronym,del,ins,"
      +"|,visualchars,nonbreaking,template,pagebreak";

    
  } else if ( 'cms_template' == settings.mode ) {
    
    settings.theme   = 'advanced';
    
    settings.plugins = "pagebreak,style,layer,table,advhr,"
      + "advimage,advlink,emotions,iespell,inlinepopups,"
      + "insertdatetime,preview,media,searchreplace,print,"
      + "contextmenu,paste,directionality,fullscreen,noneditable,"
      + "visualchars,nonbreaking,xhtmlxtras,template,wgt_mediatheke";
    
    settings.theme_advanced_buttons1 = "bold,italic,underline,strikethrough,|,sub,sup,|"
      +",justifyleft,justifycenter,justifyright,justifyfull,styleselect,formatselect,"
      +"fontselect,fontsizeselect";
    settings.theme_advanced_buttons2 = "bullist,numlist,|,outdent,indent,blockquote,|,ltr,rtl,|,link,unlink,anchor,"
      +"|,forecolor,backcolor";
    settings.theme_advanced_buttons3 = "tablecontrols,|,hr,removeformat,visualaid,|"
      +",charmap,media,image,wgt_mediatheke,|,insertdate,inserttime,|,advhr";
    settings.theme_advanced_buttons4 = "undo,redo,|,fullscreen,code,attribs,styleprops,cleanup,|,insertlayer,moveforward,movebackward,absolute,"
      +"|,cite,abbr,acronym,del,ins,|,visualchars,nonbreaking,template,pagebreak";

    
  } else if ( 'full' == settings.mode  ) {
    
    settings.theme   = 'advanced';
    
    settings.plugins = "pagebreak,style,layer,table,advhr,"
      + "advimage,advlink,emotions,iespell,inlinepopups,"
      + "insertdatetime,preview,media,searchreplace,print,"
      + "contextmenu,paste,directionality,fullscreen,noneditable,"
      + "visualchars,nonbreaking,xhtmlxtras,template";
    
    settings.theme_advanced_buttons1 = "newdocument,|,bold,italic,underline,strikethrough,|"
      +",justifyleft,justifycenter,justifyright,justifyfull,styleselect,formatselect,"
      +"fontselect,fontsizeselect";
    settings.theme_advanced_buttons2 = "cut,copy,paste,pastetext,pasteword,|,search,replace,|"
      +",bullist,numlist,|,outdent,indent,blockquote,|,undo,redo,|,link,unlink,anchor,image,"
      +"cleanup,code,|,insertdate,inserttime,preview,|,forecolor,backcolor";
    settings.theme_advanced_buttons3 = "tablecontrols,|,hr,removeformat,visualaid,|,sub,sup,|"
      +",charmap,emotions,iespell,media,advhr,|,print,|,ltr,rtl,|,fullscreen";
    settings.theme_advanced_buttons4 = "insertlayer,moveforward,movebackward,absolute,"
      +"|,styleprops,|,cite,abbr,acronym,del,ins,attribs,|,visualchars,nonbreaking,template,pagebreak";

    
  } else {
    
    settings.theme   = 'simple';
    settings.plugins = '';

    $D.errorWindow( 'UI Error', 'Got undefined Editor mode '+settings.mode+', fallback to simple mode.' );
  }

  jNode.tinymce({
    
    // Location of TinyMCE script
    script_url : $C.WEB_WGT+'/js_src/vendor/tiny_mce/tiny_mce.js',
  
    // General options
    theme   : settings.theme,
    plugins : settings.plugins,
    
    width : settings.width,
    height: settings.height,
  
    // Theme options
    theme_advanced_buttons1 : settings.theme_advanced_buttons1,
    theme_advanced_buttons2 : settings.theme_advanced_buttons2,
    theme_advanced_buttons3 : settings.theme_advanced_buttons3,
    theme_advanced_buttons4 : settings.theme_advanced_buttons4,
    theme_advanced_toolbar_location : "top",
    theme_advanced_toolbar_align : "left",
    theme_advanced_statusbar_location : "bottom",
    theme_advanced_resizing : true,

    hans: 'wurst',
  
    // Example content CSS (should be your site CSS)
    content_css : $C.WEB_GW+"theme.php?list=cms",
  
    // Drop lists for link/image/media/template dialogs
    template_external_list_url : "lists/template_list.js",
    external_link_list_url     : "lists/link_list.js",
    external_image_list_url    : "lists/image_list.js",
    media_external_list_url    : "lists/media_list.js",
  
    // Replace values for the template plugin
    template_replace_values : settings.template_replace_values
  });



});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 * 
 * @example
 * <input 
 *  class="wcm wcm_ui_window asgd-form_id" 
 *  id=""
 *  value="" 
 *  title="" />
 * <var>
 * {"title":"Some Title",
 * "list_url":"maintab.php?c=...",
 * "edit_url":"maintab.php?c=...",
 * "flag_add":"1",
 * "flag_delete":"1"}
 * </var>
 * 
 */
$R.addAction( 'ui_window', function( jNode ){
  
  var settings  = jNode.next();
  var nName = jNode.attr('name');
  var nId   = jNode.attr('id');
  
  var displayField = null;
  var trigger      = null;
  
  var defOptions = {
    title:null,               // Der Title für das Display 
    icon:'webfrap/menu.png',  // Das Icon für den Window Trigger
    list_url:'',              // Der Link zum Selection Element
    edit_url:'',              // Der Link zu Entity
    flag_add:1,               // Soll der Add Button angezeigt werden
    flag_delete:1,            // Soll der Löschen Button angezeigt werden
    autocomplete:null         // kein Autocomplete Service angehängt
  };
  
  var options = {};
  if( settings.is('var') ){
    options = $WGT.robustParseJSON( settings.text() );
    options = $S.extend({},defOptions,options);
  }
  
  
  
  jNode.hide();
  
  // Append Butoon Element anhängen
  jNode.after(
    '<button class="wgt-button append" >'
      +'<img class="icon xsmall" src="'+$C.WEB_ICONS+'xsmall/'+options.icon+'" />'
      +'</button>'
  );
  trigger = jNode.next();
  
  
  jNode.after(
    '<input '
      +' name="'+nName.replace( ']', '-tostring]' )+'"'
      +' id="'+nId+'-tostring"'
      +' class="medium wgt-ignore wgt-readonly"'
      + ( options.title ? ' title="'+options.title+'"':'' )
      +' value="'+jNode.attr('title')+'"'
      +' readonly="readonly"'
      +' />'
  );
 
  displayField = jNode.next();
  
  // tooltip hinzufügen, aber nur wenn auch ein title vorhanden ist
  if( options.title ){
    displayField.wgtTip({
      gravity: 'w',
      delayIn: 700, 
      delayOut: 200
    });
  }
  
/*
<input 
  type="hidden" 
  class="asgd-wgt-form-project_plan-edit-114721" 
  value="" 
  id="wgt-input-project_plan_id_customer-114721" 
  name="project_plan[id_customer]" />
  
<input 
  type="text" 
  name="project_plan[id_customer-tostring]" 
  id="wgt-input-project_plan_id_customer-114721-tostring" 
  class="wcm wcm_ui_tip medium asgd-wgt-form-project_plan-edit-114721 wgt-ignore wgt-readonly" 
  title="Insert value for Customer (Project)" 
  value="" 
  readonly="readonly"  />
  
<button class="wgt-button append" >
  <img class="icon xsmall" src="./icons/default/xsmall/webfrap/menu.png" />
</button>
*/
  
  // entfernen der Klasse
  jNode.removeClass('wcm_ui_window');

  trigger.menuSelector({
    stringField : displayField,
    hiddenField : jNode,
    add_link    : "'"+options.list_url+"&closeWindow=true'",
    edit_link   : "'"+nId+"', '"+options.edit_url+"&objid='",
    add         : options.flag_add,
    edit        : 1,
    remove      : options.flag_delete
  });



});

/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_star_rating', function( jNode ){

  var activ = null;
  
  var settings = {};
  var defSettings = {
    half:true,
    focus: function(value, link){
      jNode.find('.wgt_rating_text').html( link.title );
    },
    blur: function(value, link){
      jNode.find('.wgt_rating_text').html( activ  || '&nbsp;' );
    },
    callback: function(value, link){
      activ = link.title;
      jNode.find('.wgt_rating_text').html( link.title );
      jNode.find('.wgt_value').val( value ).change();
    }
  };
  
  try{
    
    var cfgData = jNode.find('var#'+jNode.attr('id')+'-cfg-rating');
    settings = cfgData.is('var')
      ? $WGT.robustParseJSON(cfgData.text())
      : {};
  }
  catch(err){
    
    $D.errorWindow( 'UI Error', err.description );
  }
  
  settings = $S.extend({}, defSettings, settings);
  
  if( 'false' == settings.half )
    settings.half = false;
  
  jNode.find('input.wgt_start_rating').rating(settings); 
  
  jNode.removeClass('wcm_ui_star_rating');

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author Milos Kosanovic 
 */
$R.addAction( 'ui_color_picker', function( jNode ){
  
  jNode.parent().css( 'backgroundColor', jNode.val() );
  
  var tmp = jNode.next();
  var tmpProps = tmp.is('var') 
    ? $WGT.robustParseJSON(tmp.text())
    :{};
  
  jNode.ColorPicker({
      color: '#0000ff',
      //flat: true,
      onShow: function (colpkr) 
      {
        (jQuery)(colpkr).fadeIn(600);
        return false;
      },
      onHide: function (colpkr) 
      {
        (jQuery)(colpkr).fadeOut(500);
        return false;
      },
      onSubmit: function (hsb, hex, rgb ) 
      {
        jNode.val('#'+hex);
        //$S(el).ColorPickerHide();
      },
      onChange: function (hsb, hex, rgb ) 
      {
        jNode.parent().css( 'backgroundColor', '#'+ hex );
        jNode.val( '#'+ hex );
      }
    })
    .bind( 'keyup', function(){
	$S(this).ColorPickerSetColor( jNode.val() );
    })
    .removeClass('wcm_ui_color_picker');
      
    // Kann auch über einen Button getriggert werden
    if( tmpProps.button )
    {
      $S('#'+tmpProps.button).click( function(){
        jNode.click();
      });
    }

});

/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_mega_menu', function( jNode ){
  
  var settings = {};

  try{
    settings = jNode.next().is('var.wgt-settings')
    ? $WGT.robustParseJSON(jNode.next().text())
    : { rowItems: '3',
        speed: 'fast',
        event: 'hover'
      };
  }
  catch(err){
    $D.errorWindow( 'UI Error', err.description );
  }

  jNode.wgtMegaMenu(settings).removeClass("wcm_ui_mega_menu");

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'ui_vert_mega_menu', function( jNode ){
  
  var settings = {};
  
  try{
    settings = jNode.next().is('var.wgt-settings')
    ? $WGT.robustParseJSON(jNode.next().text())
    : { rowItems: '3',
        speed: 'fast',
        effect: 'show',
        direction: 'right'
      };
  }
  catch(err){
    $D.errorWindow( 'UI Error', err.description );
  }

  jNode.vertMegaMenu(settings).removeClass("wcm_ui_vert_mega_menu");

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author Dominik Bonsch <dominik.bonsch@webfrap.net>
 */
$R.addAction( 'widget_treetable', function( jNode ){
  
  if( $C.DEBUG.WCM.WIDGET )
    console.log( 'wcm widget_tag_cloud path: ' +jNode.getNodePath('/')  );
  
  // check if the action class exists
  if( !jNode.is( '.wgt_table' ) )
    jNode.addClass( 'wgt_table' );

  // laden der wysiwyg konfiguration
  try{
    
    var cfgData = jNode.find( 'var#'+jNode.attr('id')+'-cfg-treetable' );
    var settings = cfgData.is( 'var' )
      ? $WGT.robustParseJSON(cfgData.text())
      : {};
  }
  catch(err){
    
    $D.errorWindow( 'UI Error', err.description );
  }
  
  settings.className = 'wgt-table';
  
  jNode.treetable( settings );
  jNode.removeClass( 'wcm_widget_treetable' );
  
  /*
  // Drag & Drop Example Code follows
  
  jNode.find( '.file, .folder' ).draggable({
    helper: "clone",
    opacity: .75,
    refreshPositions: true, // Performance?
    revert: "invalid",
    revertDuration: 300,
    scroll: true
  });
  
  jNode.find( ".folder" ).each(function() {
    $S($S(this).parents("tr")[0]).droppable({
      accept: ".file, .folder",
      drop: function(e, ui) { 
        $S($S(ui.draggable).parents("tr")[0]).appendBranchTo(this);
      },
      hoverClass: "accept",
      over: function(e, ui) {
        if(this.id != $S(ui.draggable.parents("tr")[0]).id && !$S(this).is(".expanded")) {
          $S(this).expand();
        }
      }
    });
  });
  */
  /*
  // Make visible that a row is clicked
  jNode.find( "tbody tr").mousedown(function() {
    jNode.find("tr.selected").removeClass("selected"); // Deselect currently selected rows
    $S(this).addClass("selected");
  });
  
  // Make sure row is selected when span is clicked
  jNode.find( "tbody tr span").mousedown(function() {
    $S($S(this).parents("tr")[0]).trigger("mousedown");
  });
  */

  
});

/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author Dominik Bonsch <dominik.bonsch@webfrap.net>
 */
(function( $S ) {
  
  /**
   * Einfaches selectbox item
   */
  $S.widget( "wgt.rselectbox", {
    
    // These options will be used as defaults
    options: { 
      decorate: true,
      icon: 'control/arrow_down.png',
      icon_alt: 'Open',
      type: 'simple',
      data: [],
      data_source: null
    },
    
    elemId:null,
    
    rNode:null,
    
    asgdForm:null,
    
    _create: function() {
      
      var self = this;
      this.elemId    = this.element.attr('id');
      this.rNode     = this.element.get(0);
      
      this.asgdForm  = $WGT.getClassByPrefix( 'asgd-', this.element.prop('class'), true );
      
      // soll die selectbox hübsch dekoriert werden?
      if( this.options.decorate ){
        this.decorate();
      }
      
      
      if( this.options.data_source ){
        this.element.bind( 'click.wgt_selectbox', function(){
          
          if( !self.element.attr('loaded') ){
            
            var active = self.element.find('option:first').attr('value');
            
            var formData = $S('#'+self.asgdForm).data(self.options.data_source);
            
            if( !formData ){
              var sourceData = self.loadData( self.options.data_source );
              
              formData = '';
              
              for( var key =0; key < sourceData.length; key++ ) {
                formData += '<option value="'+sourceData[key].i+'" >'+sourceData[key].v+'</option>';
              }
              
              $S('#'+self.asgdForm).data(self.options.data_source,formData);
              
            }
            
            self.element.html( formData );
            self.setActive( active );
            
            self.element.attr('loaded',true);
          }
          
        });
      }

    },
    
    decorate: function() {
      
      var self      = this,
        el = this.element;
      
      
      var img = '<image src="'+$C.WEB_ICONS+'xsmall/'+this.options.icon+'" class="icon xsmall" alt="'+this.options.icon_alt+'" />';
      
      el
      .wrap( '<div style="position:relative;" class="inline" />' )
      .after(
        '<input class="wgt-overlay embed medium wgt-ignore" '
          + ' value="'+( undefined !== this.rNode.options[this.rNode.selectedIndex] ? this.rNode.options[this.rNode.selectedIndex].innerHTML : '')
          + '" type="text" name="display-'+el.attr('name')+'" id="display-'+this.elemId+'" />'
          + '<button id="trigger-'+this.elemId+'" class="wgt-button append wgt-overlay embed" >' 
          + img +'</button>'
      )
      .addClass( 'wgt-behind' );
      
      var slctWidth = el.next().outerWidth() + el.next().next().outerWidth();
      el.css( "width", slctWidth );

      el.bind( 'click.wgt_selectbox',  function(){
        $S( 'input#display-'+self.elemId).val( self.rNode.options[self.rNode.selectedIndex].innerHTML );
      });
      
      el.bind( 'keyup.wgt_selectbox', function( event ){
        if( event.which == window.key.RETURN ){
          $S( 'input#display-'+self.elemId).val( self.rNode.options[self.rNode.selectedIndex].innerHTML );
        }
      });
      
    },
    
    loadData: function( sourceId ) {
      
      var tmp = $S( '#'+sourceId );
      
      return tmp.is('var') 
        ? $WGT.robustParseJSON(tmp.text())
        : [];
      
    },
    
    setActive: function( id ) {
      
      if( !id )
        return;
      
      this.element.find('option')
        .attr('selected',null);

      this.element.find('option[value="'+id+'"]:first').attr('selected', 'selected');
    },

    destroy: function() {
      
      $S.Widget.prototype.destroy.call( this );
    }
      
  });
  
  /**
   * @author dominik alexander bonsch <db@webfrap.net>
   */
  $R.addAction( 'widget_selectbox', function( jNode ){
    
    if( $C.DEBUG.WCM.WIDGET )
      console.log( 'wcm widget_selectbox path: ' +jNode.getNodePath('/')  );

    var tmp = jNode.next();

    var tmpProps = tmp.is( 'var' ) 
      ? $WGT.robustParseJSON( tmp.text() )
      : {};
      
    var dSource = jNode.attr( 'data_source' );
    if( dSource )
        tmpProps.data_source = dSource;

    jNode.removeClass( "wcm_widget_selectbox" );
    jNode.rselectbox( tmpProps );

  });

  
})( $S );





/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author Dominik Bonsch <dominik.bonsch@webfrap.net>
 */
$R.addAction( 'widget_grid', function( jNode ){

  if( $C.DEBUG.WCM.WIDGET )
    console.log( 'wcm widget_grid path: ' +jNode.getNodePath('/')  );
  
  jNode.removeClass("wcm_widget_grid");

  var settings = {};

  try{

    var cfgData = $S('var#'+jNode.attr('id')+'-cfg-grid');
    settings = cfgData.is('var')
      ? $WGT.robustParseJSON(cfgData.text())
      : {};
  }
  catch(err){

    $D.errorWindow( 'UI Error', err.description );
  }

  jNode.grid(settings);
  
});
/* Licence see: /LICENCES/wgt/licence.txt */




/**
 * @author Dominik Bonsch <dominik.bonsch@webfrap.net>
 */
$R.addAction( 'widget_process_editor', function( jNode ){

  if( $C.DEBUG.WCM.WIDGET )
    console.log( 'wcm widget_process_editor path: ' +jNode.getNodePath('/')  );
  
  $WGT.loadModule('editor',function(){
	  //jsPlumb.setRenderMode(jsPlumb.SVG);
	  jsPlumb.Defaults.Connector = [ "Bezier", { curviness:40 } ];
	  jsPlumb.Defaults.DragOptions = { cursor: "pointer", zIndex:2000 };
	  jsPlumb.Defaults.PaintStyle = { strokeStyle:"gray", lineWidth:1 };
	  jsPlumb.Defaults.Endpoint = [ "Blank", { fillStyle:"gray" } ];
	  jsPlumb.Defaults.EndpointStyle = { fillStyle:"gray" };
	  jsPlumb.Defaults.HoverPaintStyle = {strokeStyle:"#ec9f2e" };
	  jsPlumb.Defaults.EndpointHoverStyle = {fillStyle:"#ec9f2e" };              
	  jsPlumb.Defaults.Anchors =  [ "BottomCenter", "TopCenter" ];
	  jsPlumb.Defaults.RenderMode = jsPlumb.SVG;
	  jsPlumb.Defaults.ConnectionsDetachable = true;
  });
  
  jNode.removeClass("wcm_widget_process_editor");

  var settings = {};

  try{

    var cfgData = $S('var#'+jNode.attr('id')+'-cfg-process_editor');
    settings = cfgData.is('var')
      ? $WGT.robustParseJSON(cfgData.text())
      : {};
  }
  catch(err){

    $D.errorWindow( 'UI Error', err.description );
  }

  jNode.process_editor(settings);
  
});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author Dominik Bonsch <dominik.bonsch@webfrap.net>
 */
$R.addAction( 'widget_tag_cloud', function( jNode ){
  
  if( $C.DEBUG.WCM.WIDGET )
    console.log( 'wcm widget_tag_cloud path: ' +jNode.getNodePath('/')  );
  
  // laden der wysiwyg konfiguration
  try{
    
    var cfgData = jNode.find( 'var#'+jNode.attr('id')+'-cfg-tag_cloud' );
    var settings = cfgData.is( 'var' )
      ? $WGT.robustParseJSON(cfgData.text())
      : {};
  }
  catch(err){
    
    $D.errorWindow( 'UI Error', err.description );
  }

  jNode.tagCloud( settings );
  jNode.removeClass( 'wcm_widget_tag_cloud' );

});

/* Licence see: /LICENCES/wgt/licence.txt */



/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'widget_contextmenu', function( jNode ){

  if( $C.DEBUG.WCM.WIDGET )
    console.log( 'wcm widget_contextmenu path: ' +jNode.getNodePath('/')  );

  jNode.removeClass("wcm_widget_contextmenu");

  var settings = {},
      $doc     = $S(document);

  try{

    var cfgData = $S('var#'+jNode.attr('id')+'-cfg-contextmenu');
    settings = cfgData.is('var')
      ? $WGT.robustParseJSON(cfgData.text())
      : {};
  }
  catch(err){
    
    if( undefined !== $D )
      $D.errorWindow( 'UI Error', err.description );
  }
  
  jNode.dropdown( settings );

  // Rechtsklick simulieren
  jNode.bind( 'mousedown.context',  function(e) {
    
    var evt = e;
    evt.stopPropagation();
    
    jNode.bind( 'mouseup.context',  function(e) {
      e.stopPropagation();

      jNode.unbind('mouseup.context');
      if( evt.button == 2 ) {
          
        console.log("rechtsklick");
        
        $doc.unbind('click');
        
        // Hide bindings
        setTimeout( function() { // Delay for Mozilla
          $doc.click( function() {
            $doc.unbind('click');
            return false;
          });
        }, 0);
        
        jNode.dropdown( 'open', {triggerEvent:null} );
        
      }
      
      return false;
    });

  });
  
  // Disable browser context menu (requires both selectors to work in IE/Safari + FF/Chrome)
  jNode.bind('contextmenu', function() { return false; });

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'feature_sortable', function( jNode ){
 
    var varData = $S('var#'+jNode.prop('id')+"-sortable");
    var updateFunc = null;

    var props = varData.is('var') 
      ? $WGT.robustParseJSON( varData.text() )
      : {};
      
    if( props.url !== undefined ){
      
      if( props.start !== undefined )
        props.url += "&start="+props.start;
      
      updateFunc = function( event, ui ){
        $R.post( props.url, jNode.find('input.order').serialize() );
      };
    
    }    
    
    // switch workarea
    jNode.sortable({
      update: updateFunc,
      placeholder: 'ui-state-highlight',
      opacity: 0.6,
      delay: 200
    });

    jNode.removeClass('wcm_feature_sortable');
    

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'feature_moveable', function( jNode ){
 
    var varData = $S('var#'+jNode.prop('id')+"-moveable");

    var props = varData.is('var') 
      ? $WGT.robustParseJSON( varData.text() )
      : {};

    
    // switch workarea
    jNode.draggable();

    jNode.removeClass('wcm_feature_moveable');
    

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'chart_area', function( jNode ){

  $WGT.loadModule('graph');
  
  jNode.removeClass("wcm_chart_area");

  var dataContainer = jNode.find('var.data');
  var chartData = $WGT.robustParseJSON(dataContainer.text());
  
  // remove the data container
  dataContainer.remove();
  
  //init AreaChart
  var areaChart = new $jit.AreaChart({
    //id of the visualization container
    injectInto: jNode.find('.container').prop('id'),
    //add animations
    animate: true,
    //separation offsets
    Margin: {
      top: 5,
      left: 5,
      right: 5,
      bottom: 5
    },
    labelOffset: 10,
    //whether to display sums
    showAggregates: true,
    //whether to display labels at all
    showLabels: true,
    //could also be 'stacked'
    type: $UI.graph.useGradients? 'stacked:gradient' : 'stacked',
    //label styling
    Label: {
      type: $UI.graph.labelType, //can be 'Native' or 'HTML'
      size: 13,
      family: 'Arial',
      color: 'black'
    },
    //enable tips
    Tips: {
      enable: true,
      onShow: function(tip, elem) {
        tip.innerHTML = "<b>" + elem.name + "</b>: " + elem.value;
      }
    },
    //add left and right click handlers
    filterOnClick: true,
    restoreOnRightClick:true
  });
  
  //load JSON data.
  areaChart.loadJSON(chartData);
  
  //end
  var list = $jit.id(jNode.find('.legend').prop('id')); //,
  /*
      button = $jit.id('update'),
      restoreButton = $jit.id('restore');
  */
  /*
  //update json on click
  $jit.util.addEvent(button, 'click', function() {
    var util = $jit.util;
    if(util.hasClass(button, 'gray')) return;
    util.removeClass(button, 'white');
    util.addClass(button, 'gray');
    areaChart.updateJSON(json2);
  });
  */
  
  /*
  //restore graph on click
  $jit.util.addEvent(restoreButton, 'click', function() {
    areaChart.restore();
  });
  */
  
  
  //dynamically add legend to list
  var legend = areaChart.getLegend(),
      listItems = [];
  
  for(var name in legend) {
    listItems.push('<div class=\'query-color\' style=\'background-color:'
        + legend[name] +'\'>&nbsp;</div>' + name);
  }
  
  list.innerHTML = '<li>' + listItems.join('</li><li>') + '</li>';
  
  /*
  // update
  jNode.data('update',function( formId ){ 
    areaChart.updateJSON($R.form(formId).data);
  });
  */

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'chart_pie', function( jNode ){

  $WGT.loadModule('graph');
  
  jNode.removeClass("wcm_chart_pie");

  var dataContainer = jNode.find('var.data');
  var chartData = $WGT.robustParseJSON(dataContainer.text());
  
  // remove the data container
  dataContainer.remove();
  
  //init PieChart
  var pieChart = new $jit.PieChart({
    //id of the visualization container
    injectInto: jNode.find('.container').prop('id'),
    //whether to add animations
    animate: true,
    //offsets
    offset: 30,
    sliceOffset: 0,
    labelOffset: 20,
    //slice style
    type: $UI.graph.useGradients? 'stacked:gradient' : 'stacked',
    //whether to show the labels for the slices
    showLabels:true,
    //resize labels according to
    //pie slices values set 7px as
    //min label size
    resizeLabels: 7,
    //label styling
    Label: {
      type: $UI.graph.labelType, //Native or HTML
      size: 20,
      family: 'Verdana',
      color: 'black'
    },
    //enable tips
    Tips: {
      enable: true,
      onShow: function(tip, elem) {
         tip.innerHTML = "<b>" + elem.name + "</b>: " + elem.value;
      }
    }
  });
  
  //load JSON data.
  pieChart.loadJSON(chartData);
  //end
  
  var list = $jit.id(jNode.find('.legend').prop('id'));

  //dynamically add legend to list
  var legend = pieChart.getLegend(),
      listItems = [];
  
  for(var name in legend) {
    listItems.push('<div class=\'query-color\' style=\'background-color:'
        + legend[name] +'\'>&nbsp;</div>' + name);
  }
  
  list.innerHTML = '<li>' + listItems.join('</li><li>') + '</li>';
    
  /*
  // update
  jNode.data('update',function( formId ){ 
    
    var jsonData = $R.form(formId).data;
    //alert(jsonData.label[0]);
    
    pieChart.updateJSON(jsonData);
  });
  */

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'chart_hbar', function( jNode ){
  
  $WGT.loadModule('graph');

  jNode.removeClass("wcm_chart_hbar");

  var dataContainer = jNode.find('var.data');
  var chartData = $WGT.robustParseJSON(dataContainer.text());
  
  // remove the data container
  dataContainer.remove();
  
  //init BarChart
  var barChart = new $jit.BarChart({
    //id of the visualization container
    injectInto: jNode.find('.container').prop('id'),
    //whether to add animations
    animate: true,
    //horizontal or vertical barcharts
    orientation: 'horizontal',
    //bars separation
    barsOffset: 0.5,
    //visualization offset
    Margin: {
      top: 5,
      left: 5,
      right: 5,
      bottom: 5
    },
    //labels offset position
    labelOffset:5,
    //bars style
    type: $UI.graph.useGradients? 'stacked:gradient' : 'stacked',
    //whether to show the aggregation of the values
    showAggregates:true,
    //whether to show the labels for the bars
    showLabels:true,
    //label styles
    Label: {
      type: $UI.graph.labelType, //Native or HTML
      size: 10,
      family: 'Verdana',
      color: 'black'
    },
    //tooltip options
    Tips: {
      enable: true,
      onShow: function(tip, elem) {
        tip.innerHTML = "<b>" + elem.name + "</b>: " + elem.value;
      }
    }
  });
  
  //load JSON data.
  barChart.loadJSON(chartData);
  //end
  
  var list = $jit.id(jNode.find('.legend').prop('id'));

  //dynamically add legend to list
  var legend = barChart.getLegend(),
      listItems = [];
  
  for(var name in legend) {
    listItems.push('<div class=\'query-color\' style=\'background-color:'
        + legend[name] +'\'>&nbsp;</div>' + name);
  }
  
  list.innerHTML = '<li>' + listItems.join('</li><li>') + '</li>';
    
  
  /*
  // update
  jNode.data('update',function( formId ){ 
    barChart.updateJSON($R.form(formId).data);
  });
  */
  
});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'chart_bar', function( jNode ){

  
  $WGT.loadModule('graph');
  
  jNode.removeClass("wcm_chart_bar");

  var dataContainer = jNode.find('var.data');
  var chartData = $WGT.robustParseJSON(dataContainer.text());
  
  // remove the data container
  dataContainer.remove();
  
  //init BarChart
  var barChart = new $jit.BarChart({
    //id of the visualization container
    injectInto: jNode.find('.container').prop('id'),
    //whether to add animations
    animate: true,
    //horizontal or vertical barcharts
    orientation: 'vertical',
    //bars separation
    barsOffset: 20,
    //visualization offset
    Margin: {
      top:5,
      left: 5,
      right: 5,
      bottom:5
    },
    //labels offset position
    labelOffset:5,
    //bars style
    type: $UI.graph.useGradients? 'stacked:gradient' : 'stacked',
    //whether to show the aggregation of the values
    showAggregates:true,
    //whether to show the labels for the bars
    showLabels:true,
    //label styles
    Label: {
      type: $UI.graph.labelType, //Native or HTML
      size: 13,
      family: 'Verdana',
      color: 'black'
    },
    //tooltip options
    Tips: {
      enable: true,
      onShow: function(tip, elem) {
        tip.innerHTML = "<b>" + elem.name + "</b>: " + elem.value;
      }
    }
  });
  
  //load JSON data.
  barChart.loadJSON(chartData);
  //end
  
  var list = $jit.id(jNode.find('.legend').prop('id'));

  //dynamically add legend to list
  var legend = barChart.getLegend(),
      listItems = [];
  
  for(var name in legend) {
    listItems.push('<div class=\'query-color\' style=\'background-color:'
        + legend[name] +'\'>&nbsp;</div>' + name);
  }
  
  list.innerHTML = '<li>' + listItems.join('</li><li>') + '</li>';
    
  
  /*
  // update
  jNode.data('update',function( formId ){ 
    barChart.updateJSON($R.form(formId).data);
  });
  */
  
});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'chart_rgraph', function( jNode ){

  $WGT.loadModule('graph');
  
  jNode.removeClass("wcm_chart_rgraph");

  var dataContainer = jNode.find('var.data');
  var chartData     = $WGT.robustParseJSON(dataContainer.text());
  
  // remove the data container
  dataContainer.remove();
  
  //init PieChart
  var chart = new $jit.RGraph({
    
    //id of the visualization container
    injectInto: jNode.find('.container').prop('id'),
    
    //Optional: create a background canvas that plots  
    //concentric circles.  
    background: {  
      CanvasStyles: {  
        strokeStyle: '#555'  
      }  
    },  
    
    //Add navigation capabilities:  
    //zooming by scrolling and panning.  
    Navigation: {  
      enable: true,  
      panning: true,  
      type:'replot',
      zooming: 20  
    },  
    
    //Set Node  styles.  
    Node: {  
        color: '#ddeeff'  
    },  
    // Set Edge Styles
    Edge: {  
      color: '#C17878',  
      lineWidth:1.5  
    },  

    onBeforeCompute: function(node)
    {    
      //Add the relation list in the right column.  
      //This list is taken from the data property of each JSON node.  
      //$jit.id('inner-details').innerHTML = node.data.relation;  
    },  
      
    onAfterCompute: function()
    {  

    },  
    //Add the name of the node in the correponding label  
    //and a click handler to move the graph.  
    //This method is called once, on label creation.  
    onCreateLabel: function(domElement, node)
    {  
      
      domElement.innerHTML = node.name;  
      var style = domElement.style;
      
      var callbackClick = jNode.parent().data('nodeClick');
      var callbackHover = jNode.parent().data('nodeHover');

      domElement.onclick = function()
      {  
        chart.onClick(node.id);  
        if(callbackClick != undefined)
          callbackClick(node.data);
      };
      
      domElement.onmouseover = function()
      {  
        style.fontSize = "14px";  
        style.backgroundColor = '#FFDCA8'; 
        style.zIndex = 2; 
        
        if(callbackHover != undefined)
          callbackHover(node.data);   
      };
      
      domElement.onmouseout = function()
      {  
        style.fontSize = "12px";  
        style.backgroundColor = ''; 
        style.zIndex = 1; 
      };
       
    },  
    //Change some label dom properties.  
    //This method is called each time a label is plotted.  
    onPlaceLabel: function(domElement, node)
    {  
      var style = domElement.style;  
      style.display = '';  
      style.cursor = 'pointer';  

      if (node._depth <= 1) 
      {  
        style.fontSize = "12px";  
        style.color = "#000000";  
      } 
      else if(node._depth == 2)
      {  
        style.fontSize = "12px";  
        style.color = "#494949"; 
      } 
      else 
      {  
        style.display = 'none';  
      }  

      var left = parseInt(style.left);  
      var w = domElement.offsetWidth;  
      style.left = (left - w / 2) + 'px';  
    }  
  });
  
  //load JSON data.
  chart.loadJSON(chartData);
  //end
  
  //trigger small animation  
  chart.graph.eachNode(function(n) {  
    var pos = n.getPos();  
    pos.setc(-200, -200);  
  });  

  
  chart.compute('end');  
  chart.fx.animate({  
    modes:['polar'],  
    duration: 100
  });  

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'chart_hypertree', function( jNode ){

  
  $WGT.loadModule('graph');
  
  jNode.removeClass("wcm_chart_hypertree");

  var dataContainer = jNode.find('var.data');
  var chartData     = $WGT.robustParseJSON(dataContainer.text());
  
  // remove the data container
  dataContainer.remove();
  
  // get width & height
  var container = jNode.find('.container');
  var cNode = container.get(0);
  var w = cNode.offsetWidth - 50, 
    h = cNode.offsetHeight - 50;

  
  //init PieChart
  var chart = new $jit.Hypertree({
    
    //id of the visualization container
    injectInto: container.prop('id'),
    
    //canvas width and height  
    width: w,  
    height: h,    
    
    //Change node and edge styles such as  
    //color, width and dimensions.  
    Node: {  
      dim: 9,  
      color: "#f00"  
    },  
    Edge: {  
      lineWidth: 2,  
      color: "#088"  
    },  

    onBeforeCompute: function(node)
    {    
      //Add the relation list in the right column.  
      //This list is taken from the data property of each JSON node.  
      //$jit.id('inner-details').innerHTML = node.data.relation;  
    },  
      
    onAfterCompute: function()
    {  

    },  
    
    //Add the name of the node in the correponding label  
    //and a click handler to move the graph.  
    //This method is called once, on label creation.  
    onCreateLabel: function(domElement, node)
    {  
      
      var callbackClick = jNode.parent().data('nodeClick');
      var callbackHover = jNode.parent().data('nodeHover');
      var callbackOut   = jNode.parent().data('nodeOut');
      
      domElement.innerHTML = node.name;  
      $jit.util.addEvent(domElement, 'click', function () 
      {  
        if(callbackClick != undefined)
          callbackClick(node.data);
        
        chart.onClick(node.id);  
      });  
      
      domElement.onmouseover = function()
      {  
        if(callbackHover != undefined)
          callbackHover(node.data);   
      };
      
      domElement.onmouseout = function()
      {  
        if(callbackOut != undefined)
          callbackOut(node.data); 
      };

       
    },  
    
    //Change node styles when labels are placed  
    //or moved.  
    onPlaceLabel: function(domElement, node)
    {  
      var style = domElement.style;  
      style.display = '';  
      style.cursor = 'pointer';  
      if (node._depth <= 1) 
      {  
        style.fontSize = "1em";  
        style.color = "#222";  
       
      } 
      else if(node._depth == 2)
      {  
        style.fontSize = "0.9em";  
        style.color = "#444";  
     
      } 
      else 
      {  
        style.display = 'none';  
      }  
       
      var left = parseInt(style.left);  
      var w = domElement.offsetWidth;  
      style.left = (left - w / 2) + 'px';  
    },  
        
    onAfterCompute: function()
    {  

    }
    
  });
  
  //load JSON data.
  chart.loadJSON(chartData);
  //end
  
  //compute node positions and layout  
  chart.refresh();   
  
  //end
  chart.controller.onAfterCompute();


});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'chart_spacetree', function( jNode ){
  
  $WGT.loadModule('graph');

  jNode.removeClass("wcm_chart_spacetree");

  var dataContainer = jNode.find('var.data');
  var chartData     = $WGT.robustParseJSON(dataContainer.text());
  
  // remove the data container
  dataContainer.remove();
  
  //init PieChart
  var chart = new $jit.ST({
    
    //id of the visualization container
    injectInto: jNode.find('.container').prop('id'),
    
    // Annimation Speed / Duration
    duration: 300,  
    
    // distance between node and its children
    levelDistance: 50,
    
    // Annimation transition type
    transition: $jit.Trans.Quart.easeInOut,  
    
    //Add navigation capabilities:  
    //zooming by scrolling and panning.  
    Navigation: {  
      enable: true,  
      panning: true 
      //zooming: 20  
    },  
    
    //Optional: create a background canvas that plots  
    //concentric circles.  
    /*
    background: {  
      CanvasStyles: {  
        //strokeStyle: '#555'  
      }  
    },
    */  
    

    //Set Node  styles.  
    Node: 
    {  
      height: 23,  
      width: 200,  
      type: 'rectangle',  
      color: '#aaa',  
      overridable: true  
    },  
    
    // Set Edge Styles
    Edge: {  
      type: 'bezier',  
      overridable: true  
    },  

    onBeforeCompute: function(node)
    {    
      //Add the relation list in the right column.  
      //This list is taken from the data property of each JSON node.  
      //$jit.id('inner-details').innerHTML = node.data.relation;  
    },  
      
    onAfterCompute: function()
    {  

    },  
    
    //Add the name of the node in the correponding label  
    //and a click handler to move the graph.  
    //This method is called once, on label creation.  
    onCreateLabel: function(label, node)
    {  
      
      var callbackClick = jNode.parent().data('nodeClick');
      var callbackHover = jNode.parent().data('nodeHover');
      var callbackOut = jNode.parent().data('nodeOut');
      
      label.id = node.id;              
      label.innerHTML = node.name;  
      label.onclick  = function()
      {  
        if(callbackClick != undefined)
          callbackClick(node.data);
        
        chart.onClick(node.id);  
      };

      //set label styles  
      var style = label.style;  
      style.width = 200 + 'px';  
      style.height = 20 + 'px';              
      style.cursor = 'pointer';  
      style.color = '#333';  
      style.fontSize = '0.9em';  
      style.textAlign= 'center';  
      style.paddingTop = '3px';  
      
      label.onmouseover = function()
      {  
        if(callbackHover != undefined)
          callbackHover(node.data);   
      };
      
      label.onmouseout = function()
      {  
        if(callbackOut != undefined)
          callbackOut(node.data); 
      };
       
    },  
    
    //This method is called right before plotting  
    //a node. It's useful for changing an individual node  
    //style properties before plotting it.  
    //The data properties prefixed with a dollar  
    //sign will override the global node style properties.  
    onBeforePlotNode: function(node)
    {  
      //add some color to the nodes in the path between the  
      //root node and the selected node.  
      if (node.selected) 
      {  
        node.data.$color = "#ff7";  
      }  
      else 
      {  
        delete node.data.$color;  
        //if the node belongs to the last plotted level  
        if(!node.anySubnode("exist")) 
        {  
          //count children number  
          var count = 0;  
          node.eachSubnode(function(n) { count++; });  
     
          //assign a node color based on  
          //how many children it has  
          node.data.$color = ['#eee', '#ddd', '#ccc', '#bbb', '#aaa', '#999'][count];                      
        }  
      }  
    },  
    
    //This method is called right before plotting  
    //an edge. It's useful for changing an individual edge  
    //style properties before plotting it.  
    //Edge data proprties prefixed with a dollar sign will  
    //override the Edge global style properties.  
    onBeforePlotLine: function(adj)
    {  
      if (adj.nodeFrom.selected && adj.nodeTo.selected) 
      {  
        adj.data.$color = "#eed";  
        adj.data.$lineWidth = 3;  
      }  
      else 
      {  
        delete adj.data.$color;  
        delete adj.data.$lineWidth;  
      }  
    }  
  });
  
  //load JSON data.
  chart.loadJSON(chartData);
  //end
  
  //compute node positions and layout  
  chart.compute();  
  //optional: make a translation of the tree  
  chart.geom.translate(new $jit.Complex(-200, 0), "current");  
  //emulate a click on the root node.  
  chart.onClick(chart.root);  

});
/* Licence see: /LICENCES/wgt/licence.txt */

/*
[
  {
    "adjacencies": [
      "graphnode21", 
      {
        "nodeTo": "graphnode1",
        "nodeFrom": "graphnode0",
        "data": {
          "$color": "#557EAA"
        }
      }, 
      {
        "nodeTo": "graphnode13",
        "nodeFrom": "graphnode0",
        "data": {
          "$color": "#909291"
        }
      }, 
      {
              "nodeTo": "graphnode14",
              "nodeFrom": "graphnode0",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode15",
              "nodeFrom": "graphnode0",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode16",
              "nodeFrom": "graphnode0",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode17",
              "nodeFrom": "graphnode0",
              "data": {
                "$color": "#557EAA"
              }
            }
        ],
        "data": {
          "$color": "#83548B",
          "$type": "circle",
          "$dim": 10
        },
        "id": "graphnode0",
        "name": "graphnode0"
      }, {
        "adjacencies": [
            {
              "nodeTo": "graphnode2",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode4",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#909291"
              }
            }, {
              "nodeTo": "graphnode5",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#909291"
              }
            }, {
              "nodeTo": "graphnode6",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#909291"
              }
            }, {
              "nodeTo": "graphnode7",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#909291"
              }
            }, {
              "nodeTo": "graphnode8",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#909291"
              }
            }, {
              "nodeTo": "graphnode10",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode11",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#909291"
              }
            }, {
              "nodeTo": "graphnode12",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#909291"
              }
            }, {
              "nodeTo": "graphnode13",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode14",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode15",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode16",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#909291"
              }
            }, {
              "nodeTo": "graphnode17",
              "nodeFrom": "graphnode1",
              "data": {
                "$color": "#557EAA"
              }
            }
        ],
        "data": {
          "$color": "#EBB056",
          "$type": "circle",
          "$dim": 11
        },
        "id": "graphnode1",
        "name": "graphnode1"
      }, {
        "adjacencies": [
            {
              "nodeTo": "graphnode5",
              "nodeFrom": "graphnode2",
              "data": {
                "$color": "#909291"
              }
            }, {
              "nodeTo": "graphnode9",
              "nodeFrom": "graphnode2",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode18",
              "nodeFrom": "graphnode2",
              "data": {
                "$color": "#557EAA"
              }
            }
        ],
        "data": {
          "$color": "#416D9C",
          "$type": "circle",
          "$dim": 7
        },
        "id": "graphnode2",
        "name": "graphnode2"
      }, {
        "adjacencies": [
            {
              "nodeTo": "graphnode5",
              "nodeFrom": "graphnode3",
              "data": {
                "$color": "#909291"
              }
            }, {
              "nodeTo": "graphnode9",
              "nodeFrom": "graphnode3",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode10",
              "nodeFrom": "graphnode3",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode12",
              "nodeFrom": "graphnode3",
              "data": {
                "$color": "#557EAA"
              }
            }
        ],
        "data": {
          "$color": "#416D9C",
          "$type": "square",
          "$dim": 10
        },
        "id": "graphnode3",
        "name": "graphnode3"
      }, {
        "adjacencies": [],
        "data": {
          "$color": "#83548B",
          "$type": "square",
          "$dim": 11
        },
        "id": "graphnode4",
        "name": "graphnode4"
      }, {
        "adjacencies": [
          {
            "nodeTo": "graphnode9",
            "nodeFrom": "graphnode5",
            "data": {
              "$color": "#909291"
            }
          }
        ],
        "data": {
          "$color": "#C74243",
          "$type": "triangle",
          "$dim": 8
        },
        "id": "graphnode5",
        "name": "graphnode5"
      }, {
        "adjacencies": [
            {
              "nodeTo": "graphnode10",
              "nodeFrom": "graphnode6",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode11",
              "nodeFrom": "graphnode6",
              "data": {
                "$color": "#557EAA"
              }
            }
        ],
        "data": {
          "$color": "#83548B",
          "$type": "circle",
          "$dim": 11
        },
        "id": "graphnode6",
        "name": "graphnode6"
      }, {
        "adjacencies": [],
        "data": {
          "$color": "#EBB056",
          "$type": "triangle",
          "$dim": 12
        },
        "id": "graphnode7",
        "name": "graphnode7"
      }, {
        "adjacencies": [],
        "data": {
          "$color": "#C74243",
          "$type": "star",
          "$dim": 10
        },
        "id": "graphnode8",
        "name": "graphnode8"
      }, {
        "adjacencies": [],
        "data": {
          "$color": "#83548B",
          "$type": "circle",
          "$dim": 12
        },
        "id": "graphnode9",
        "name": "graphnode9"
      }, {
        "adjacencies": [
          {
            "nodeTo": "graphnode11",
            "nodeFrom": "graphnode10",
            "data": {
              "$color": "#909291"
            }
          }
        ],
        "data": {
          "$color": "#70A35E",
          "$type": "triangle",
          "$dim": 11
        },
        "id": "graphnode10",
        "name": "graphnode10"
      }, {
        "adjacencies": [],
        "data": {
          "$color": "#70A35E",
          "$type": "circle",
          "$dim": 11
        },
        "id": "graphnode11",
        "name": "graphnode11"
      }, {
        "adjacencies": [],
        "data": {
          "$color": "#83548B",
          "$type": "triangle",
          "$dim": 10
        },
        "id": "graphnode12",
        "name": "graphnode12"
      }, {
        "adjacencies": [
          {
            "nodeTo": "graphnode14",
            "nodeFrom": "graphnode13",
            "data": {
              "$color": "#557EAA"
            }
          }
        ],
        "data": {
          "$color": "#EBB056",
          "$type": "star",
          "$dim": 7
        },
        "id": "graphnode13",
        "name": "graphnode13"
      }, {
        "adjacencies": [],
        "data": {
          "$color": "#EBB056",
          "$type": "triangle",
          "$dim": 12
        },
        "id": "graphnode14",
        "name": "graphnode14"
      }, {
        "adjacencies": [
            {
              "nodeTo": "graphnode16",
              "nodeFrom": "graphnode15",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode17",
              "nodeFrom": "graphnode15",
              "data": {
                "$color": "#557EAA"
              }
            }
        ],
        "data": {
          "$color": "#83548B",
          "$type": "triangle",
          "$dim": 11
        },
        "id": "graphnode15",
        "name": "graphnode15"
      }, {
        "adjacencies": [
          {
            "nodeTo": "graphnode17",
            "nodeFrom": "graphnode16",
            "data": {
              "$color": "#557EAA"
            }
          }
        ],
        "data": {
          "$color": "#C74243",
          "$type": "star",
          "$dim": 7
        },
        "id": "graphnode16",
        "name": "graphnode16"
      }, {
        "adjacencies": [],
        "data": {
          "$color": "#416D9C",
          "$type": "circle",
          "$dim": 7
        },
        "id": "graphnode17",
        "name": "graphnode17"
      }, {
        "adjacencies": [
            {
              "nodeTo": "graphnode19",
              "nodeFrom": "graphnode18",
              "data": {
                "$color": "#557EAA"
              }
            }, {
              "nodeTo": "graphnode20",
              "nodeFrom": "graphnode18",
              "data": {
                "$color": "#557EAA"
              }
            }
        ],
        "data": {
          "$color": "#EBB056",
          "$type": "triangle",
          "$dim": 9
        },
        "id": "graphnode18",
        "name": "graphnode18"
      }, {
        "adjacencies": [],
        "data": {
          "$color": "#70A35E",
          "$type": "circle",
          "$dim": 8
        },
        "id": "graphnode19",
        "name": "graphnode19"
      }, {
        "adjacencies": [],
        "data": {
          "$color": "#C74243",
          "$type": "star",
          "$dim": 8
        },
        "id": "graphnode20",
        "name": "graphnode20"
      }
  ];
 */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$R.addAction( 'chart_force_directed', function( jNode ){
  
  $WGT.loadModule('graph');

  jNode.removeClass("wcm_chart_force_directed");

  var dataContainer = jNode.find('var.data');
  var chartData     = $WGT.robustParseJSON(dataContainer.text());
  
  // remove the data container
  dataContainer.remove();
  
  var fd = new $jit.ForceDirected({
    //id of the visualization container
    injectInto: jNode.find('.container').prop('id'),
    //Enable zooming and panning
    //by scrolling and DnD
    Navigation: {
      enable: true,
      //Enable panning events only if we're dragging the empty
      //canvas (and not a node).
      panning: 'avoid nodes',
      zooming: 10 //zoom speed. higher is more sensible
    },
    // Change node and edge styles such as
    // color and width.
    // These properties are also set per node
    // with dollar prefixed data-properties in the
    // JSON structure.
    Node: {
      overridable: true,
      height: 25,
      width: 120,
      color: '#C3C3C3',
      type: 'rectangle'
    },
    Edge: {
      overridable: true,
      color: '#23A4FF',
      lineWidth: 0.4
    },
    //Native canvas text styling
    Label: {
      type: $UI.graph.labelType, //Native or HTML
      size: 10,
      style: 'bold',
      textAlign: 'center',
      color: '#303030'
    },
    //Add Tips
    Tips: {
      enable: true,
      onShow: function(tip, node) {
        //count connections
        var count = 0;
        node.eachAdjacency(function() { count++; });
        //display node info in tooltip
        tip.innerHTML = "<div class=\"tip-title\">" + node.name + "</div>"
          + "<div class=\"tip-text\"><b>connections:</b> " + count + "</div>";
      }
    },
    // Add node events
    Events: {
      enable: true,
      type: 'Native',
      //Change cursor style when hovering a node
      onMouseEnter: function() {
        fd.canvas.getElement().style.cursor = 'move';
      },
      onMouseLeave: function() {
        fd.canvas.getElement().style.cursor = '';
      },
      //Update node positions when dragged
      onDragMove: function(node, eventInfo, e) {
          var pos = eventInfo.getPos();
          node.pos.setc(pos.x, pos.y);
          fd.plot();
      },
      //Implement the same handler for touchscreens
      onTouchMove: function(node, eventInfo, e) {
        $jit.util.event.stop(e); //stop default touchmove event
        this.onDragMove(node, eventInfo, e);
      },
      //Add also a click handler to nodes
      onClick: function(node){
        
        /*
        if(!node) return;
        // Build the right column relations list.
        // This is done by traversing the clicked node connections.
        var html = "<h4>" + node.name + "</h4><b> connections:</b><ul><li>",
            list = [];
        node.eachAdjacency(function(adj){
          list.push(adj.nodeTo.name);
        });
        //append connections information
        $jit.id('inner-details').innerHTML = html + list.join("</li><li>") + "</li></ul>";
        */
      }
    },
    //Number of iterations for the FD algorithm
    iterations: 50,
    //Edge length
    levelDistance: 450,
    // Add text to the labels. This method is only triggered
    // on label creation and only for DOM labels (not native canvas ones).
    onCreateLabel: function(domElement, node){
      domElement.innerHTML = node.name;
      var style = domElement.style;
      style.fontSize = "0.8em";
      style.color = "#ddd";
    },
    // Change node styles when DOM labels are placed
    // or moved.
    onPlaceLabel: function(domElement, node){
      var style = domElement.style;
      var left = parseInt(style.left);
      var top = parseInt(style.top);
      var w = domElement.offsetWidth;
      style.left = (left - w / 2) + 'px';
      style.top = (top + 10) + 'px';
      style.display = '';
    }
  });
  
  // load JSON data.
  fd.loadJSON(chartData);
  
  // compute positions incrementally and animate.
  fd.computeIncremental({
    iter: 40,
    property: 'end',
    onStep: function(perc){
      //Log.write(perc + '% loaded...');
    },
    onComplete: function(){
      fd.animate({
        modes: ['linear'],
        transition: $jit.Trans.linear,
        duration: 0
      });
    }
  });
  // end

});
/* Licence see: /LICENCES/wgt/licence.txt */


;(function( $S, window,undefined){
  
  "use strict";
  
  /**
   * @author dominik alexander bonsch <db@webfrap.net>
   */
  var WgtDesktop = function( ){
    
    /**
     * make it extendable
     */
    this.fn = WgtDesktop.prototype;
    
    /**
     * Array mit Closures welche clear funktionen implementieren
     */
    this.clearCall = {};
    
    /**
     * Der aktive Maincontainer
     */
    this.actMainCont = null;
    
    /**
     * self reference
     */
    var self = this;
    
    /**
     * Schliesen des aktiven Menüs
     * Wird gesetzt um alle möglichen menüs 
     */
    this.requestCloseMenu = function(){};
    
    /**
     * Schliesen des aktiven Menüs
     * Wird gesetzt um alle möglichen menüs 
     */
    this.globalCloseMenu = function(){};

    /**
     * Shortcut für Save on Strg + S
     */
    this.shortCutSave = function(){};
    
    /**
     * aktivieren und deaktivieren der lightbox
     * @param activate boolean
     */
    this.lightBox = function( activate ){
      ///TODO implement a lighbox here
    };
    
    /**
     * Den Desktop aufräumen,
     * Tooltips, schliesen, offenen Menüs schliesen etc.
     */
    this.clear = function(  ){
      ///TODO implement a lighbox here
    };
    
   /**
     * Den Desktop aufräumen,
     * Tooltips, schliesen, offenen Menüs schliesen etc.
     */
    this.setTitle = function( title ){
      window.document.title = title;
    };
    
    /**
     * create an error window
     * use this function instead of ulgy alert windows
     * @param title
     * @param message
     */
    this.errorWindow = function( title, message ){
      
      
      if( typeof title === 'string' ){
        // den 2ten parameter optional machen we
        if( !message ){
          message = title;
          title = 'Error';
        }
      }
      else if( undefined === message ){
        
        // ok sieht so aus als ob wir eine exception bekommen haben
        message = title.message;
        title = title.name;
      }
      
      var template = this.template( $S("#wgt-template-dialog").html(), {'title':title,'message':message} );

      if( $S.dialog ){
        $S(template).dialog({
          bgiframe: false,
          resizable: true,
          height:200,
          modal: true,
          overlay:{
            backgroundColor: '#000',
            opacity: 0.5
          },
          buttons:{
            confirm : function(){$S(this).dialog('close');}
          }
        });
      }
      else{
        // ausgabe per allert wenn dialog fehlen sollte
        alert( message );
      }

    };

    /**
     * @param title the title for the dialog
     * @param message the message content for the dialog
     * @param Confirm
     * @param callBack function to be called on confirm
     */
    this.confirmWindow = function( title, message, Confirm, callBack ){

      var templateNode = this.template( 
        $S("#wgt-template-dialog").html(), 
        {'title':title,'message':message} 
      );

      $S(templateNode).dialog({
        bgiframe  : false,
        resizable : true,
        height    : 200,
        modal     : true,
        overlay   :{
          backgroundColor: '#000',
          opacity: 0.5
        },
        buttons:{
          Confirm : function(){
            callBack();
            $S(this).dialog('close');
          },
          Cancel : function(){
            $S(this).dialog('close');
          }
        }
      });
      
    };


    /**
     * open a new dialog window
     * @param content
     * @param params
     */
    this.openWindow = function( content , params ){
        
      // umschreiben auf extends
      if( params === undefined  ){
        params = {};
      }
      if( params.resizable === undefined  ){
        params.resizable = true;
      }
      if( params.height === undefined  ){
        params.height = 300;
      }
      if( params.width === undefined ){
        params.width = 400;
      }

      $S(content).dialog(params);

    };//end this.openWindow 

    /**
     * open an new browser window / popup
     * @param params
     * @return
     */
    this.openBrowserWindow = function( params ){

      // check for required parameters
      if( typeof params === 'undefined' || typeof params.src === 'undefined'  ){
        throw new WgtException('Tried to open Windows without source');
      }

      // check optional Parameters
      if( typeof params.title === 'undefined' ){
        params.title = 'WebFrap Wgt Window';
      }
      if( typeof params.width === 'undefined' ){
        params.width = 1000;
      }
      if( typeof params.height === 'undefined' ){
        params.height = 600;
      }

      var windowParam = "width="+params.width+",height="+params.height;
      windowParam += ",scrollbars=yes,locationbar=false,menubar=false";

      var newWindow = window.open(params.src, params.title, windowParam );
      newWindow.focus();

    };//end this.openBrowserWindow
    
    /**
    *
    * @param params
    * @return
    */
   this.openImageWindow = function( params ) {

     // check for required parameters
     if( typeof params === 'undefined' || typeof params.src === 'undefined'  ){
       throw new WgtException('Tried to open Windows without source');
     }

     // check optional Parameters
     if( typeof params.title === 'undefined' ){
       params.title = 'Image Viewer';
     }
     if( typeof params.width === 'undefined' ){
       params.width = 1000;
     }
     if( typeof params.height === 'undefined' ){
       params.height = 600;
     }
     if( typeof params.alt === 'undefined' ){
       params.alt = 'Some Image';
     }

     var windowParam = "width="+params.width+",height="+params.height;
       windowParam += ",scrollbars=yes,locationbar=false,menubar=false";

     var newWindow = window.open('', params.title, windowParam );
     newWindow.document.writeln('<html><head><title>'+params.title+'</title></head><body><img onclick="window.close()" src="'+params.src+'" alt="'+params.src+'" /></body></html>');
     newWindow.focus();

   };//end this.openBrowserWindow

    /**
     * show the progress bar
     */
    this.showProgressBar = function(){
      
      
      // sicher stellen, dass der z-index auch ganz oben ist
      var zIndex = window.$WGT.getNextHighestZindex();

      var progBar = $S('#wgt_progress_bar');
      progBar.show();

      progBar.css( 'z-index', zIndex );

    };//end this.showProgressBar

    /**
     * hide the pogress bar
     */
    this.hideProgressBar = function(){
      
      $S('#wgt_progress_bar').hide();
    };

    /**
     * @param e
     */
    this.activateProgressIcon = function(e){
      
      $S('#wgt_wait_icon').show();
      $S("body").bind("mousemove", self.moveProgessIcon );
      
    }; //end this.activateProgressIcon

    /**
     * @param e
     */
    this.deactivateProgressIcon = function(e){
      
      $S('#wgt_wait_icon').hide();
      $S("body").unbind("mousemove", self.moveProgessIcon );
      
    };//end this.deactivateProgressIcon

    /**
     * @param e
     */
    this.moveProgessIcon = function(e){
      
      var mouseX = document.all ? window.event.x : e.pageX;
      var mouseY = document.all ? window.event.y : e.pageY;
      $S("#wgt_wait_icon").css({top:mouseY, left:mouseX});
      
    };//end this.moveProgessIcon

    /**
     * @param template
     * @param data
     * @param asObject
     */
    this.template = function( template, data, asObject ){
      
      //if as Object ist 'undefined' return the data as object
      if( typeof asObject === 'undefined' ){
        asObject=true;
      }

      for( var key in data ){
        template = str_replace( '{$'+key+'}', data[key], template );
      }

      // return string or $S object
      if (asObject === false){
        return template;
      }
      else{
        return $S(template);
      }

    };//end this.template

    /**
     * @param tplId string
     */
    this.getTemplate = function( tplId  ){
      
      var tmp = $S( "#"+tplId ).clone();
      tmp.attr('id','');

      return tmp;

    };//end this.getTemplate

    /**
     *
     * @param tc
     * @return
     */
    this.getTabsWidth = function( tc ){
      
      return ( tc.find('.tab:last').position().left - tc.find('.tab:first').position().left + tc.find('.tab:last').outerWidth(true) + 6 );
      
    };//end this.getTabsWidth

    /**
     *
     * @param tc
     * @param offset
     * @return
     */
    this.scrollTabs = function(tc, offset){
      
      tc
      .find('.tab_scroll')
      .animate(
        {scrollLeft: offset},
        500,
        'swing',
        function(){self.checkTabButtonVisibility($S(this));}
      );
    };

    /**
     *
     * @param tc
     * @return
     */
    this.checkTabButtonVisibility = function(tc){

      var tabOuterContainer = tc.parents('.tab_outer_container');
      var leftVisible = (tc.scrollLeft() === 0);
      var rightVisible = (
            ( tc.scrollLeft() + tc.outerWidth(true) )  === self.getTabsWidth(tabOuterContainer.find('.tab_container'))
      );

      if(tabOuterContainer.find('.tab_left').is(':visible')){
        tabOuterContainer.find('.tab_left').fadeTo(1000, leftVisible ? 0.4 : 1);
      }

      if(tabOuterContainer.find('.tab_right').is(':visible')){
        tabOuterContainer.find('.tab_right').fadeTo(1000, rightVisible ? 0.4 : 1);
      }

    };//end this.checkTabButtonVisibility

    /**
     * @param message
     * @param content
     */
    this.console = function( message, content ){

      var timeStamp = new Date;

      var consoleHtml = '<h3 style="cursor: pointer;" onclick="$S(\'#wgtIdDebug_'+timeStamp+'\').toggle()">'+message+'</h3>';
      consoleHtml += '<pre id="wgtIdDebug_'+timeStamp+'" style="display: none;">'+var_dump(content)+'</pre>';

      $S('#wgt_debug_console').append(consoleHtml);

    };//end this.console


  };//end function WgtDesktop( )
  
  // create instance
  window.$D = new WgtDesktop();

})( jQuery, window);

/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * add a message system to the desktop
 */
;(function($D,$S,undefined){
  
  "use strict";

    /**
     * @author dominik alexander bonsch <db@webfrap.net>
     */
    $D.fn.message = {
      error: function( title , message  ){
        $D.errorWindow( title , message );
        
        var msg = '<tr class="ui-state-error" >';
        msg += '<td class="status" ><img src="'+$C.iconPath+'xsmall/status/error.png" alt="error"  /></td>';
        msg += '<td class="time" >'+(new Date).toLocaleString()+'</td>';
        msg += '<td class="message" >'+message.substring(0,400)+'</td>';
        msg + '</tr>';
        
        var d = new Date();
        var timeStr = d.getHours()+'-'+d.getMinutes()+'-'+d.getSeconds();
        
        var msgD = '<tr class="ui-state-error" >';
        msgD += '<td class="status" ><img src="'+$C.iconPath+'xsmall/status/error.png" alt="error"  /> '+timeStr+'</td>';
        msgD + '</tr>';
        
        $S('#footer_status tbody').html(msgD);
        $S('#wbf-footer-history tbody').append(msg);
        
      },
      warning: function( title , message  ){
        $S.toaster({
          base:'body',
          position:'bl',
          title:title,
          text:message,
          timeout:3500,
          cssclass:'important'
        });
        
        var msg = '<tr class="ui-state-highlight" >';
        msg += '<td class="status" ><img src="'+$C.iconPath+'xsmall/status/warning.png" alt="warning"  /></td>';
        msg += '<td class="time" >'+(new Date).toLocaleString()+'</td>';
        msg += '<td class="message" >'+message.substring(0,400)+'</td>';
        msg + '</tr>';
        
        var d = new Date();
        var timeStr = d.getHours()+'-'+d.getMinutes()+'-'+d.getSeconds();
        
        var msgD = '<tr class="ui-state-error" >';
        msgD += '<td class="status" ><img src="'+$C.iconPath+'xsmall/status/warning.png" alt="warning"  /> '+timeStr+'</td>';
        msgD + '</tr>';
        
        $S('#footer_status tbody').html(msgD);
        $S('#wbf-footer-history tbody').append(msg);
        
      },
      message: function( title , message  ){
        $S.toaster({
          base:'body',
          position:'bl',
          title:title,
          text:message,
          timeout:3500,
          cssclass:'important'
        });
        
        var msg = '<tr class="ui-state-default" >';
        msg += '<td class="status" ><img src="'+$C.iconPath+'xsmall/status/info.png" alt="info"  /></td>';
        msg += '<td class="time" >'+(new Date).toLocaleString()+'</td>';
        msg += '<td class="message" >'+message.substring(0,400)+'</td>';
        msg + '</tr>';
        
        var d = new Date();
        var timeStr = d.getHours()+'-'+d.getMinutes()+'-'+d.getSeconds();
        
        var msgD = '<tr class="ui-state-error" >';
        msgD += '<td class="status" ><img src="'+$C.iconPath+'xsmall/status/info.png" alt="info"  /> '+timeStr+'</td>';
        msgD + '</tr>';
        
        $S('#footer_status tbody').html(msgD);
        $S('#wbf-footer-history tbody').append(msg);
      }
    };

})(
    window.$D,
    window.$S
);
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * 
 */
;(function($D,$WGT,$S,undefined){
  
  "use strict";
  
  /**
   * @author dominik alexander bonsch <db@webfrap.net>
   */
  $D.fn.workarea = {
      
    show: function( areaId ){
      $S('#wgt_workarea').find('.wgt_workarea').hide();
      $S('#wgt_workarea_'+areaId).fadeIn('fast',function(){});
    },
    
    init: function(){
      $S('.wgt_workarea:first').fadeIn('fast',function(){});
    }
      
  };
    
  // add init event
  $WGT.addInitCall(function(){
    $D.workarea.init();
  });

})( 
  window.$D,
  window.$WGT,
  window.$S
);
/* Licence see: /LICENCES/wgt/licence.txt */

;(function(window,undefined){

  "use strict";
  
  /**
   * @author dominik alexander bonsch <db@webfrap.net>
   * @extends js_wgt/jquery.js
   * @extends js_wgt/wgt.js
   */
  function WgtUi( ){

    /**
     * 
     */
    this.fn = WgtUi.prototype;

    /**
     * pool for actions that has to be done on window ready
     */
    this.handlerPool = [];

    /**
     * request the actual running version
     */
    this.addHandler = function( type,key, handler ){
      this.handlerPool.push( [type,key,handler] );
    };
    
    
    /**
     * aktivieren und deaktivieren der lightbox
     * @param boolean activate
     */
    this.resetForm = function( formId ){
      
      // reset also assigned elements
      $S('.asgd-'+formId+',.fparam-'+formId).not('input[type="checkbox"],input[type="radio"]').val('');
      $R.cleanFormParams( formId );
      
      $S('form#'+formId).each(function(){
        this.reset();
      });
      
    };

    
  }//end class WgtUi

  // Expose Wgt to the global object
  window.$UI = new WgtUi;

})(window);
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author Dominik Bonsch <dominik.bonsch@webfrap.net>
 *
 */
;(function($UI,undefined){
/*
 * ////////////////////////////////////////////////////////////////////////////// //
 * First extend UI
 * //////////////////////////////////////////////////////////////////////////////
 */
  
/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
  $UI.fn.tab = {

    create: function( containerId, params ){

      var $sCont = $S('#'+containerId);
        
      if( undefined != $sCont ){
        var cont = new tabContainer( containerId, params );
        
        $sCont.data('wgt-tab_cont-obj',cont);
        return cont;
      }
      else{
        $D.message.error('Internal Error');
        $D.console('Tried to create a tabcontainer for a nonexisting id: '+containerId);
        return null;
      }

    },
  
    init: function( containerId, settings ){
        
      try{
        
        var $sCont = $S('#'+containerId);
        // alert(containerId);
        if( undefined !== $sCont ){
          
          var cont = new WgtTabContainer( containerId, settings );
          $sCont.data('wgt-tab_cont-obj',cont);
          
          if( !cont.hasTabs() ){
            
            cont.setNoTabs();
            cont.addMenuButton();
            
          }
          else{
            
            cont.loadTabs();
            cont.appendTabbingEvents();          
            cont.addResizeEvent();
            cont.addMenuButton();
            cont.setActiv(0);
            cont.addScrolling();
          }
  
          return cont;
          
        }
        else{
          
          $D.message.error(' Internal Error' );
          $D.console( 'Tried to create a tabcontainer for a nonexisting id: '+containerId );
          return null;
          
        }
        
      }
      catch( err ){
        //alert( err.description );
      }
    },
  
    get: function( containerId ) {
      
      return $S('#'+containerId).data('wgt-tab_cont-obj');  

    },
      
    add: function( containerId, tabData ) {
      
      try {
        
        var cnt = $UI.tab.get(containerId);
        var tabIndex = cnt.addTab(tabData);
        cnt.appendTabbingEvents();
        cnt.setActiv( tabIndex );
        cnt.addScrolling();
        
      }
      catch( err ) {
        console.log( err.description );
      }

    },
    
    remove: function( containerId, tabId ) {
      var cnt = $UI.tab.get(containerId);
      cnt.removeTab(tabId);
      cnt.removeScrolling();
    },
    
    removeonadd: function( containerId, tabId ) {
      var cnt = $UI.tab.get(containerId);
      cnt.removeTabOnAdd(tabId);
      cnt.removeScrolling();
    },
    // tab entfernen wenn er existiert
    removeIfExists: function( containerId, tabId ) {
      var cnt = $UI.tab.get(containerId);
      
      if( cnt.tabExists( tabId ) ){
        console.log( 'Remove TAB '+tabId+' first' );
        cnt.removeTab( tabId );
        cnt.removeScrolling();
      }
    },
    
    render: function( _containerId ) {
      cnt = $UI.tab.get( _containerId );
    },
    
    parentTab: function( _node ) {
      
      var pTab = _node.parentX('.wgt-maintab'); 
      
      if( !pTab )
        return null;
      
      return pTab.data('wgt-tab-obj');
      
    }
      
  };// end WgtUi.prototype.tab
  
   
/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
  function WgtTabContainer( tabId, _settings ){

    /**
     * @param string
     */
    var container   = $S('#'+tabId),
    
    /**
     * head container
     * 
     * @param string
     */
    headContainer = $S('#'+tabId+'-head'),
    
    /**
     * head container
     * 
     * @param string
     */
    bodyContainer = $S('#'+tabId+'-body'),

    /**
     * @param string
     */
    contId = tabId,
     
    /**
     * @param tabs
     */
    tabs = new Array(),

    /**
     * @var settings Settings
     */
    settings = $S.extend(
      {},
      {"reFocus":true},
      _settings
    ),

    /**
     * @param string
     */
    self = this,
    
    /**
     * 
     */
    clicked = [];

    console.log( "refocus "+settings.reFocus );
     
    // constructor block

    if( !headContainer.length )
      headContainer = container.find('.wgt_tab_head').first();
    
    if( !bodyContainer.length )
      bodyContainer = container.find('.wgt_tab_body').first();
    
    // Methodes
     
    /**
     * @lang de:
     * 
     * Methode zum erstellen der Tabs
     * 
     */
    this.loadTabs = function(){

      // check if there is allready a tabcontainer
      // if not load from template
      if( !headContainer.find(".wgt-container-controls").length ){
        self.appendTabHead();
      }
      
      // New Style Tabs
      bodyContainer.find('div.wgt_tab').each(function( ) {

        var tabObj   = $S(this);

        // only use tabs that have the tabid as class
        if( !tabObj.hasClass(contId) )
          return;

        tabObj.addClass('wgt_tab_content');

        var tabData  = {};
        
        tabData.text = '';
        var tabIcon = tabObj.attr("wgt_icon");
        if( tabIcon )
          tabData.text += '<img alt="'+tabObj.attr("title")+'" src="'+$C.WEB_ICONS+tabIcon+'" /> ';
        
        tabData.text += tabObj.attr("title");
        
        // das title attribute entfernen, sonst nervt der browser mit den titles
        tabObj.removeAttr("title");
        
        // flags laden
        tabData.disabled  = tabObj.hasClass('tab_disabled');
        tabData.closeable = tabObj.hasClass('tab_close_able');
        
        
        tabData.id = tabObj.prop("id");

        console.log( 'TAB id '+tabData.id );

        // if there is a on
        if( tabObj.find("a.wgt_ref").is("a.wgt_ref") ){
          tabData.initLoad = tabObj.find("a.wgt_ref").prop('href');
        }

        self.addTab( tabData );
       

      });
      
    };// end this.loadTabs
    
    /**
     * Prüfen ob es überhaupt Tabs im Container gibt
     * Nötig für Elemente die Standardmäßig einen Tabcontainer haben
     * wie Maintabs oder Subwindows
     */
    this.hasTabs = function(){

      //alert( 'length '+bodyContainer.find('div.wgt_tab').length );
      
      // New Style Tabs
      if( bodyContainer.find('div.wgt_tab').length > 0 )
        return true;
      else
        return false;

    };// end this.hasTabs
    
    /**
     * Das Element hat keine Tabs, also kann der outercontainer entfernt werden
     */
    this.setNoTabs = function(){
        
      headContainer.find('.tab_outer_container').remove();

    };// end this.setNoTabs
    
    /**
     * 
     */
    this.addMenuButton = function() {
      
      headContainer.find('.tab_outer_container .tab_left, .tab_outer_container .tab_right').remove();
      
      var num_hidden = 0;
      var newimg = $S("<div/>", {
        "class": "tab_nav ui-corner-top",
        style: "position:absolute;right:5px;cursor:pointer;margin:2px;width:32px;height:22px;",
        click: function(){ 
          
          var menuItems = [];
         
          headContainer.find(".tab_container .tab_hidden").each(function(){
            
            var click = "$S('#"+$S(this).prop('id')+"').find('a').click();";
            num_hidden ++;         
            var name = "<b>"+$S(this).find('a').html()+"</b>";
            menuItems.push({
              caption: name,
              onClickLink: click
            });

          });

          $S(this).menuSelector1({
            overlayStyle:{},
            menuItems   : menuItems
          });
       
          
        },
        mouseover: function(){
          $S(this).addClass('ui-state-highlight');
        },
        mouseout: function(){
          $S(this).removeClass('ui-state-highlight');
        }
      });
      var span = $S("<span style='position:relative; color:#2E6E9E; top:0px;left:-1px'>>></span>");
      var label = $S("<label style='position:relative; color:#2E6E9E; top:10px;left:-1px'>"+num_hidden+"</label>");
      newimg.append(span);
      newimg.append(label);  
      headContainer.find('.tab_outer_container').append(newimg);

    };//end this.addMenuButton 

    
    /**
     * append a tab head to the tab body by using the default template
     */
    this.appendTabHead = function(  ){
      
      var tabHead = $D.getTemplate('wgt_template_tab_container');
      // container.find('.wgt_tab_head').append(tabHead.html());
      headContainer.append( tabHead.html() );
        
    };// end this.appendTabHead */
   
    /**
     * Dem Container einen neuen Tab hinzufügen
     * 
     * @param tab object
     *   id:
     *   text:
     *   closeable:
     *   disabled:
     *   content:
     *   script:
     *   
     * @return int the index of the new tab
     */
    this.addTab = function( tab ){
      
      var newTab = $S('#'+contId+"_tab_"+tab.id);

      if( newTab.length ){
        
        $UI.tab.removeonadd(contId,tab.id);

      }

      var tab_size = tabs.length;
      tabs[tab_size] = tab;
      
      newTab = $S($D.getTemplate('wgt_template_tab_head').html());
      
      var tabLink = newTab.find( "a" );

      tabLink.html(tab.text);
      newTab.prop( "id", contId+"_tab_"+tab.id );
      
      tabLink.addClass( "wgt_tabkey_"+tab.id );

      if( tab.initLoad != undefined  ){
        tabLink.prop('href',tab.initLoad);
      }
      
      // dem tab ein close action icon hinzufügen
      if( tab.closeable ){
        tabLink.after(
          '&nbsp;<strong class="wgt_icon_close_tab cursor" '
            +'onclick="$UI.tab.remove(\''+contId+'\',\''+tab.id+'\');">'
            +'&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp;'
        );
      }

      
      if( tab.disabled )
        newTab.addClass( 'tab_disabled' );

      headContainer.find( ".tab_container" ).append(newTab);
      
      // check for visibility

      if( tab.content != undefined )
        bodyContainer.append( '<div id="'+tab.id+'" class="wgt_tab_content '+contId+'" >'+tab.content+'</div>' );
        
      var tabObj = new Tab(contId, tab.id);
      $S('#'+tab.id).data('wgt-tab-obj',tabObj);
      
      
      if( tab.check_valid ){
        tabObj.addOnClose( 'check_valid', function(){
          
          var jObj = tabObj.getObject();
          if( jObj.find('.state-invalid').length )
            throw new WgtUserException("Please recheck your data. It seams that some of the given informations were invalid.");
          
        });
      }
      
      try{
        
        if( tab.script != undefined )
          (new Function("self",tab.script))(tabObj);
      }
      catch( err ) {
        console.error( 'Tab code Failed '+err.description );
      }
      
      var position = headContainer.find(".tab_container .tab").length-1;

      clicked.push(contId+"_tab_"+tab.id);
      
      console.log("Added tab");
      
      // fokus auf das erste inputelement
      if( 'false' !== settings.reFocus )
        $S('#'+tab.id).find('input:first').focus();
      
      // potentiell offenen menü schliesen
      $D.requestCloseMenu();
      // schliesen des Menüs nach dem Request
      $D.requestCloseMenu = function(){};

      return position;

    };// end this.addTab
    
    /**
     * prüfen ob ein bestimmter Tab existiert
     * 
     * @param tabKey
     * @return boolean
     */
    this.tabExists = function( tabKey ){

      return headContainer.find('#'+contId+"_tab_"+tabKey).length;
      
    };// end tabExists
    

    /**
     * removes a tab from the container
     * 
     * @param tabKey
     */
    this.removeTab = function( tabKey ){

      var toRemove = headContainer.find('#'+contId+"_tab_"+tabKey);
      var indexKey = headContainer.find(".tab_container .tab").index(toRemove);
      var wasActive = toRemove.hasClass('ui-state-active');
      var tabCont = bodyContainer.find("#"+tabKey);
      
      if( !tabCont.data('wgt-tab-obj').onClose() )
        return false;
      

      toRemove.remove();
      tabCont.remove();
      
      if( wasActive ){
        
        while( clicked.length > 0 ){
          
          var prevTabId = clicked.pop();
          var findTab = headContainer.find(".tab_container").find("#"+prevTabId);
          
          if( findTab.length > 0 ){
            
            findTab.click();
            break;
          }
       }
          
      }
      
      for(var i=0; i< clicked.length; i++){
        
        if(clicked[i]==toRemove.prop('id')){
          
            clicked.splice(i,1);
            break;
        }
      }
      
      if( wasActive )
        this.setActiv( (indexKey-1) );

    };// end this.removeTab
    
    /**
     * @param tabKey
     */
    this.removeTabOnAdd = function( tabKey ){

      var toRemove = headContainer.find('#'+contId+"_tab_"+tabKey);
      var indexKey = headContainer.find(".tab_container .tab").index(toRemove);
      var wasActive = toRemove.hasClass('ui-state-active');
      toRemove.remove();
      
      var tabCont = bodyContainer.find("#"+tabKey);
      tabCont.data('wgt-tab-obj').onClose();
      tabCont.remove();

      for(var i=0; i< clicked.length; i++){
        if(clicked[i]==toRemove.prop('id')){
          
          clicked.splice(i,1);
          break;
        }
      }

    };// end this.removeTabOnAdd
    

    /**
     * append the events to the tabs, to be able to switch the tabs
     */
    this.appendTabbingEvents = function(){
      
      // / TAB Wechsel
      
      var tabs = headContainer.find(".tab_container .tab").not('.initialized');
    
      var tabScroll = headContainer.find('.tab_scroll');
      var tabOuterContainer = tabScroll.parentX('.tab_outer_container');


      tabs.click( function(){
       
        var tabNode = $S(this);
        
        if( tabNode.hasClass('tab_disabled') )
          return false;
      
        var tabLink      = tabNode.find('a').first();
        var classNames   = tabLink.classes();
        var tabId        = null;
        
        for( var i=0; i<classNames.length; i++ ){
          
          var tmp = classNames[i];
  
          if( tmp.indexOf("wgt_tabkey_") != -1 ){
            
            tabId = classNames[i].substr(11);
            break; // break after the first match
            
          }
        }
          
        // if there is a url on the tab send a get request
        var tabUrl = tabLink.prop( 'href' );
  
        if( tabUrl != undefined ){
            
          if( !tabLink.hasClass('wgt_loaded') ){
            
            $R.get( tabUrl, {async:true} );
            tabLink.addClass('wgt_loaded');
          }
          
        }
  
        var children  = headContainer.find(".tab_container .tab");
        var index     = children.index(this);
        children.removeClass("ui-state-active");
          
        for( var i=0; i< clicked.length; i++ ){
          if( clicked[i]==$S(this).prop('id') ){
            
            clicked.splice(i,1);
            break;
          }
        }
          
        clicked.push(tabNode.prop('id'));
         
        if( tabNode.css('display') == "none" ){
  
          tabNode.css('display','inline').removeClass('tab_hidden');
          var rightVisible = (
              tabScroll.outerWidth()
                < self.getTabsWidth( tabOuterContainer.find('.tab_container') )
          );
              
          var temp =null;
          var lastTab =null;
          var clickedid = null;
              
          while( (!rightVisible) && (tabScroll.find(".tab_container .tab_hidden").length>0) ){
            
            var i = clicked.length - 1;
            clickedid = null;
                
            while(i >= 0){
              
              clickedid = clicked[i];
              temp = tabScroll.find(".tab_container #"+clickedid);
              if(temp.hasClass('tab_hidden'))
              { 
                temp.removeClass('tab_hidden').css('display','inline');
                lastTab = temp;
                break;
              }
           i--;
         }
            
            if( i < 0){
              
              temp = tabScroll.find('.tab_hidden:first');
              temp.removeClass('tab_hidden').css('display','inline');
            }
                
            rightVisible = (
                tabScroll.outerWidth()
                  < self.getTabsWidth( tabOuterContainer.find('.tab_container') ) 
            );
                
          }
              
          while( rightVisible ){
            
            var i = 0;
            var clickedid=null;
               
            while(i < clicked.length){
              
              clickedid = clicked[i];
              temp = tabScroll.find(".tab_container #"+clickedid);
              if( !temp.hasClass('tab_hidden') ){ 
                
                temp.addClass('tab_hidden').css('display','none');
                break;
              }
              i++;
                
            }
            
            if( i == clicked.length){
              
              temp = tabScroll.find('.tab:not(.tab_hidden,.tab_no_hide):first');
              temp.addClass('tab_hidden').css('display','none');
           }
              
            rightVisible = (
               tabScroll.outerWidth()
                 < self.getTabsWidth( tabOuterContainer.find('.tab_container') ) 
            );
                
          }
          
        }
          
        var hidden = tabScroll.find(".tab_container .tab_hidden").length;
        var menu_button = tabScroll.next('div.tab_nav');
        
        if( hidden > 0 ){
          
          menu_button.show();
          var menu_label = menu_button.find('label');
          menu_label.html(hidden);
          
        } else {
          
          menu_button.hide();
        }
  
        var thisTab   = children.eq(index);
        thisTab.addClass("ui-state-active");
          
        
        var newActiveTab = null;
        
        // show/hide the tab contentboxes
        if( tabId == null ){
          
          bodyContainer.find('div.'+contId).hide();
          newActiveTab = bodyContainer.find('div.'+contId).eq(index);
          
        }
        else {
          
          bodyContainer.find('div.'+contId).hide();
          newActiveTab = bodyContainer.find('#'+tabId);
          
        }
        newActiveTab.show().trigger('tabactivate');
        if( 'false' !== settings.reFocus )
          newActiveTab.find('input:first').focus();
        
        tabNode.addClass('initialized');
        
  
        return false;

      });

    };// end this.appendTabbingEvents */

    /**
     * 
     */
    this.addResizeEvent = function() {
       
      var tabScroll = headContainer.find('.tab_scroll');
      var record=this;
      
      $S(window).bind('resize',{t:record},function(event) {
        event.data.t.addScrolling();
        event.data.t.removeScrolling();
      });


    };//end this.addResizeEvent */
    
    /**
     * @param index
     */
    this.setActiv = function(index){
      
      headContainer.find(".tab_container .tab").eq(index).click();
      
      console.log( "set tab active "+index );
      if( 'false' !== settings.reFocus )
        bodyContainer.find("div.wgt_tab").eq(index).find('input:first').focus();
    };
    
    /**
     * 
     */
    this.addScrolling = function(){
      
      var tabScroll = headContainer.find( '.tab_scroll' );
      
      if( !tabScroll )
        throw new WgtException( 'did not find the tab scroll area' );
  
      tabScroll.css('left', headContainer.find('.wgt-container-buttons').outerWidth(true)+'px');
      //tabScroll.css('left', (headContainer.find('.wgt-container-buttons').outerWidth(true) + 50 )+'px');
     
      var tabOuterContainer = tabScroll.parentX('.tab_outer_container');
      
      if( !tabOuterContainer )
        throw new WgtException( 'did not find the tab container' );

      var rightVisible = (
           tabScroll.outerWidth()
            < self.getTabsWidth( tabOuterContainer.find('.tab_container') )
      );

      var temp = null;
      while( rightVisible ){

        var i = clicked.length - 2;
        var clickedid = null;
        if( clicked.length == 0 ){
          break;
        }  

        while( i >= 0 ) {
          
          clickedid = clicked[i];
          
          temp = tabScroll.find( ".tab_container #"+clickedid );
          if( !temp.hasClass( 'tab_hidden' ) && !temp.hasClass( 'tab_no_hide' ) ){ 
            //alert( i+" : "+clickedid );
            temp.addClass('tab_hidden').css('display','none');
            break;
          }
        i--;
          
   }
        
     if( i < 0 ){
       
       temp = tabScroll.find('.tab:not(.tab_hidden,.tab_no_hide):last');
       temp.addClass('tab_hidden').css('display','none');
     }

         rightVisible = (
             tabScroll.outerWidth()
               < self.getTabsWidth( tabOuterContainer.find('.tab_container') ) 
        );

      }
      
      
      var hidden = tabScroll.find(".tab_container .tab_hidden").length;
      var menu_button = tabScroll.next('div.tab_nav');
      
      if( hidden > 0 ){
        
        menu_button.show();
        var menu_label = menu_button.find('label');
        menu_label.html(hidden);
        
      }
      else{
        
        menu_button.hide();
      }


    };// end this.addScrolling
    
    /**
     * 
     */
    this.removeScrolling = function(){
        
      var tabScroll = headContainer.find('.tab_scroll');

      var tabOuterContainer = tabScroll.parentX('.tab_outer_container');

       
      var lastTab = null;
      var rightVisible = (
        tabScroll.outerWidth()
          < self.getTabsWidth( tabOuterContainer.find('.tab_container') )
      );
       
      var temp = null;
      while( (!rightVisible) && (tabScroll.find(".tab_container .tab_hidden").length > 0) ) {
        
      var i = clicked.length - 1;
      var clickedid=null;
      
      while( i >= 0 ) {
        
        clickedid = clicked[i];
        temp = tabScroll.find(".tab_container #"+clickedid);
        
        if(temp.hasClass('tab_hidden')){ 
          temp.removeClass('tab_hidden').css('display','inline');
              lastTab = temp;
              break;
        }
        i--;
      }
        
       if( i < 0 ){
         
         temp = tabScroll.find('.tab_hidden:first');
         temp.removeClass('tab_hidden').css('display','inline');
       }
        
       rightVisible = (
           tabScroll.outerWidth()
                < self.getTabsWidth( tabOuterContainer.find('.tab_container') ) 
        );
        
      }// end while
        
    if( rightVisible && temp )
      temp.addClass('tab_hidden').css('display','none');
      
     
     var hidden = tabScroll.find(".tab_container .tab_hidden").length;
     var menu_button = tabScroll.next('div.tab_nav');
     
     if( hidden > 0 ){
       
       menu_button.show();
       var menu_label = menu_button.find('label');
       menu_label.html(hidden);
     }
     else {
       menu_button.hide();
     }

   
   };// end this.removeScrolling


  /**
   * Auslesen der aktuellen Tabweite
   * @param tc
   * @return int
   */
   this.getTabsWidth = function( _tc ){
     
     if( !_tc.find('.tab').length )
      return 0;
     
     if( !_tc.find('.tab:not(.tab_hidden)').length )
      return 0;

    // alert(tc.find('.tab:last').css('display'));
     return (
         _tc.find('.tab:not(.tab_hidden):last').position().left
       - _tc.find('.tab:not(.tab_hidden):first').position().left
       + _tc.find('.tab:not(.tab_hidden):last').outerWidth(true)
       + 6
     );
     
   };// end this.getTabsWidth

    /**
     * 
     * @param _tabScroll
     * @return
     */
    this.checkTabButtonVisibility = function( _tabScroll ){

      var rightVisible = (
          _tabScroll.outerWidth()
                  < self.getTabsWidth( tabOuterContainer.find('.tab_container') )
      );
     
      if( rightVisible )
      {
        _tabScroll.find(".tab_container .tab:not(.tab_hidden,.tab_no_hide)").eq(1).addClass('tab_hidden').css('display','none');

      }
      else
      {
        
        _tabScroll.find(".tab_container .tab_hidden").eq(0).removeClass('tab_hidden').css('display','inline'); 
      }
      
    };// end this.checkTabButtonVisibility
    
    /**
     * Anzahl der Tabs des Tabcontainers auslesen
     * @return int
     */
    this.getTabsNumber = function(){
      
      return headContainer.find(".tab_container .tab").length;
    };// end this.getTabsNumber
            
  };// end function WgtTabContainer

  /**
   * @param _contId
   * @param _tabId
   */
  var Tab = function( _contId, _tabId ){

    /**
     * @var contId
     */
    var contId = _contId;

    /**
     * @var tabId
     */
    var tabId  = _tabId;

    /**
     * @var jObject
     */
    var jObject = $S('#'+tabId);

    /**
     * @var
     */
    var closeEvent = {};

    /**
     * flag to check if there where changes on formelements in the tab
     * 
     * @var boolean
     */
    var changed = false;

    /**
     * 
     */
    this.close = function() {
      
      if(!changed || confirm("This Tab contains unsaved data. Please save first, or confirm to drop the changes.")){
        // potentiell offenen menü schliesen
        $D.requestCloseMenu();
        // schliesen des Menüs nach dem Request
        $D.requestCloseMenu = function(){};
        
        $UI.tab.remove(contId, tabId);
      }
    };

    /**
     * @param name
     * @param callBack
     */
    this.addOnClose = function( name , callBack ){

      closeEvent[name] = callBack;
      
      return true;

    };// end function addOnClose */

    /**
     * @param name
     * @param callBack
     */
    this.onClose = function( ){

      //Overwrite me to register to the closing event;
      for( var eventKey in closeEvent ){

        var callback = closeEvent[eventKey];
        try{
          
          callback( tabId  );
        }
        catch( e ){
          
          $D.errorWindow( e.name, e.message );
          return false;
        }
      }
      
      return true;
      
    };// end function onClose */

    /**
     * @return $S
     */
    this.getObject = function(){
      
      return jObject;
    };

    /**
     * @return boolean
     */
    this.getChaged = function(){
      
      return changed;
    };

     /**
       * @param _changed:boolean
       */
    this.setChanged = function(_changed){
      
      changed = _changed;
    };

  };// end var Tab
  
  
  
  (function($S){
    
    var overlayID = "menuSelectorOverlay";
    
    // The actual function
    $S.fn.menuSelector1 = function(options){  
      
      return this.each(function() {
        
        // Save reference
        var $this = $S(this);
    
        // Merge default options with passed options
        var opts = $S.extend({}, $S.fn.menuSelector1.defaults, options);
        // Save options to element
        $this.data('menuSelectorOptions', opts);   
        $S.fn.menuSelector1.initOverlay1(opts);
        $S.fn.menuSelector1.openOverlay(this);
         
      });
      
    };
    
    // Closes the overlay box
    $S.fn.menuSelector1.closeOverlay = function(){
      
      if ($S('#'+ overlayID +':visible').length) {
        
        $S('#'+overlayID).slideUp('fast', function() {
          $S('.menuSelectorOverlay').removeClass('menuSelectorOverlay');
        });
      }
    };
    
    // Opens the overlay box
    $S.fn.menuSelector1.openOverlay = function(target){
      
      var $target = $S(target);
      // Get options of the element
      var opts = $target.data('menuSelectorOptions');
      // Close overlay box in case it's still open
      $S.fn.menuSelector1.closeOverlay();    
      $target.addClass('hasmenuSelectorOverlay');
      
      // get $S object of overlay box
      var $overlay   = $S('#'+overlayID);
      // get current value of the passed input field
      var currentVal   = typeof opts.stringField != 'undefined' ?
          opts.stringField.val() : '';  
          
     
      // Content of the overlay box
      var content = "";
      
      // If there are any additional menu items to be shown ...
      if (opts.menuItems != null){
        var length = opts.menuItems.length;
        for (var i = 0; i < length; i++){
          var item = opts.menuItems[i];
         
          content += '<div style="cursor: pointer; padding-top: 3px; padding-bottom: 3px;margin-top:1px;margin-bottom:1px;" '
            +  ' onclick="'+item.onClickLink+';$S.fn.menuSelector1.closeOverlay()" ' 
            +  ' onmouseover="$S(this).removeClass(\'ui-state-default\').addClass(\'ui-state-hover\');" '
            +  ' onmouseout="$S(this).removeClass(\'ui-state-hover\').addClass(\'ui-state-default\');" '
            +  ' class="ui-corner-all ui-state-default  menuSelectorMenuButton" >'
            +  item.caption +'</div>'; 
            
        }
      }    
      //content += '<div style=""></div>';
        
      $overlay.find('#menuSelectorContent').html(content);
      
      // get the offset coordiantes
      var style = $target.offset();
      // adjust top coordinate
      style.top = style.top + $target.outerHeight();  
      style.left=style.left - $overlay.outerWidth()+$target.outerWidth();
      $overlay.css(style);
      
      $overlay.slideDown('fast');
    };
    
    // Reset input fields
    $S.fn.menuSelector1.emptyFields = function(ids){
      
      $S('#'+ids.stringFieldID).val("");
      $S('#'+ids.hiddenFieldID).val("");
    };
    
    // Mousedown handler on the document
    function docMouseDown1(e){
      
      $S.fn.menuSelector1.closeOverlay();
    };
    
    // Initialise overlay box and apply the style
    $S.fn.menuSelector1.initOverlay1=function(opts){
      
      if ($S("#"+overlayID).length == 0){
        
        $S("body").append(
            '<div style="width:auto; position:absolute; z-index:1000; display:none"  id="'+overlayID+'" class="">'
          +  '    <div class="ui-widget ui-widget-content ui-corner-all">'
          +  '    <div class="ui-widget-content ui-corner-all" style="padding: 0;">'
          +  '      <div id="menuSelectorContent"></div>'
          //+  '      <div style="clear: left;"></div>'
          +  '    </div>'
          +  '    <!--[if lte IE 6.5]>'
          +  '      <iframe style="display:block; position:absolute;top: 0;left:0;z-index:-1;'
          +  '        filter:Alpha(Opacity=\'0\');width:3000px;height:3000px"></iframe>'
          +  '    <![endif]-->'
          +  '</div></div>'
        );
        // alert('hh');
        $S(document).mousedown(function(e){docMouseDown1(e);});
        
      }
      else{
        
        $S("#"+overlayID).html(
            '    <div class="ui-widget ui-widget-content ui-corner-all">'
          +  '    <div class="ui-widget-content ui-corner-all" style="padding: 0;">'
          +  '      <div id="menuSelectorContent"></div>'
          +  '      <div style="clear: left;"></div>'
          +  '    </div>'
          +  '    <!--[if lte IE 6.5]>'
          +  '      <iframe style="display:block; position:absolute;top: 0;left:0;z-index:-1;'
          +  '        filter:Alpha(Opacity=\'0\');width:3000px;height:3000px"></iframe>'
          +  '    <![endif]-->'
          +  '   </div>'
        ).width('auto');
        
      }
      
      $S("#"+overlayID).css(opts.overlayStyle);
    };
    
    // Default options
    $S.fn.menuSelector1.defaults = {
      overlayStyle: {},
      menuItems: null
    };
    
  })($S);

})($UI);
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * Erweiterung für UI 
 * Im moment ist die einzige Funktionalität das zurücksetzen der Form
 */ 
(function($UI){

  /**
   * 
   */
  var WgtForm = function(){	
  
    /**
     * 
     */
    this.fn =  WgtForm.prototype;
      
    /**
     * @param fId
     */
    this.reset = function( fId ){
      
      $S('#'+fId).get(0).reset();
    };

  }//end class WgtForm 
  
  
  $UI.fn.form = new WgtForm();


})($UI);
/* Licence see: /LICENCES/wgt/licence.txt */


(function($UI){
  
  // set a bunch of flags for graphs
  var ua = navigator.userAgent,
  crap = ua.match(/iPhone/i) || ua.match(/iPad/i),
  typeOfCanvas = typeof HTMLCanvasElement,
  nativeCanvasSupport = (typeOfCanvas == 'object' || typeOfCanvas == 'function'),
  textSupport = nativeCanvasSupport 
    && (typeof document.createElement('canvas').getContext('2d').fillText == 'function');
  
  $UI.fn.graph = {
      labelType: (!nativeCanvasSupport || (textSupport && !crap))? 'Native' : 'HTML',
      useGradients: nativeCanvasSupport,
      nativeTextSupport: (!nativeCanvasSupport || (textSupport && !crap)),
      animate: !(crap || !nativeCanvasSupport)
  };//end $UI.fn.graph


})($UI);
/* Licence see: /LICENCES/wgt/licence.txt */

;(function($, undefined){
	
/**
 * @author marko andrijasevic <marko_andrijasevic@sap.com>
 */
  var footerId           = '#wbf-footer';
  var footerHistoryId    = '#wbf-footer-history';
  var closeId            = "#footerCloseArea";
    
  var methods = {
		  
    init: function() {
      
      $('document').ready(function(){
	      $(footerHistoryId).hide();
	      
	      //add background area for footer closing
	      var $closer = $("<div id=\"footerCloseArea\"></div>").appendTo('body');
	      $closer.css({width: '100%', height: '100%', opacity: '0.3', position: 'fixed', 'background-color': '#100', left: '0px', top: '0px', 'z-index': 4000});
	      $closer.hide();
	      
	      var $closer = $("<div class=\"ui-dialog\" id=\"videoTutorial\"><a href=\"#\" style=\"opacity:1; top:2%; right:2%;\" onClick=\"  jQuery('#videoDiv').remove(); jQuery('#videoTutorial').fadeOut(400);  \" class=\"ui-dialog-titlebar-close ui-corner-all ui-state-hover\" role=\"button\"><span class=\"ui-icon ui-icon-closethick\">close</span></a><div style=\"width:100%; height:100%;\" id=\"videoDiv1\" ></div></div>").appendTo('body');
	      $closer.css({ width: '100%', height: '100%', opacity: '0.7', position: 'fixed', 'background-color': '#100', left: '0px', top: '0px', 'z-index': 4005});
	      $closer.hide();
	      
	      $(closeId).click(function(e){
	        $(footerHistoryId).slideUp(400);
	    	  $(closeId).data('isOpen', false);
	    	  $(closeId).fadeOut(400);
	        });
	      
	      $(footerId).click(function(){  
	    	  if($(closeId).data('isOpen')){
	    		//footer is currently open
	    		$(footerHistoryId).slideUp(400);
	    		$(closeId).data('isOpen', false);
	    		$(closeId).fadeOut(400);
	      	  }
		      else{
		    	//footer is currently closed
		  		$(footerHistoryId).slideDown(400);
		    	$(closeId).data('isOpen', true);
		        $(closeId).fadeIn(400);
		      }
	      });
      });
    },
    
	newMsg: function( time, status, message, info ) {
	  $(footerHistoryId + ' table tbody').append($(footerId +' table tbody').html());
	  $(footerId + ' table tbody').remove();
	  
	  var newRow = '<tr class="ui-state-highlight">';
	      newRow +='<td class="time">'+ time() +'</td>';
	      newRow +='<td class="status">'+ getStatusMsg(status) +'</td>';
	      newRow +='<td class="message">'+ message +'</td>';
	      newRow +='</tr>';     
	  
	  $(footerId + ' table').append($(newRow));
	    }
	  };
  
  var getStatusMsg = function(status){
	  //@todo adjust path to theme/images here
	  return "<img src=\""+status+".png\" alt=\"["+ status +"]\" />";
  };
  
  $.fn.footer = function(method){
    
    if ( methods[method] ) {
      return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
    } 
    else if ( typeof method === 'object' || ! method ) {
      return methods.init.apply( this, arguments );
    } 
    else {
      $.error( 'Method ' +  method + ' does not exist in jQuery.footer' );
    }         
  };
  
})(jQuery);
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * _variable are DOM/JQery elements
 * 
 * @author milos kosanovic
 */
;(function($, undefined){

  $S.fn.calendarInit = function( calendarId, miniCalendarId, calendarMenuId ){
    var _calendar       = $('#' + calendarId),
        _miniCalendar   = $('#' + miniCalendarId),
        _calendarMenu   = $('#' + calendarMenuId);

    if( undefined !== _calendar
          && undefined !== _miniCalendar 
          && undefined !== _calendarMenu 
    ){
      
      var cont = new WgtDesktopCalendar( 
          _calendar, 
          _miniCalendar, 
          _calendarMenu
      );

      cont.load();

      return cont;
    }
    else {
      $D.message.error('Internal Error');
      $D.console('Tried to create a tabcontainer for a nonexisting id: '.containerId);
      return null;
    } 
  };
 
 
 
/*//////////////////////////////////////////////////////////////////////////////
// class WgtDesktopCalendar
//////////////////////////////////////////////////////////////////////////////*/

  /**
   * @author milos kosanovic
   * @param _calendar     - jQuery object for calendar 
   * @param _mcalendar   - jQuery object for mini calendar 
   * @param _calendarMenu - jQuery object for calendar menu
   */
  function WgtDesktopCalendar( _calendar, _miniCalendar, _calendarMenu ) {
    
    var self    = this;
      //calendar    = $('#'+_calendarId),
      //_miniCalendar   = $('#'+_mCalendarId),
      //calendarMenu     = $('#'+_calendarMenuId),
    
    var calendars = Array();                    //array of active calendars
    
    var proxy = new WgtCalendarProxy(_calendar);
    
    /**
     * 
     */
    this.load = function() {
      loadCalendars("1", _calendarMenu.find('#calendar-menu-categories'));
      addButtons();
      addMiniCalendar();
      //$('#'+calendarId).fullCalendar('render');
    };
      
    /*//////////////////////////////////////////////////////////////////////////////
     // WgtCalendarProxy class
     //////////////////////////////////////////////////////////////////////////////*/
  
  /**
   * Proxy class responsible for communication between server and calendar
   */
  function WgtCalendarProxy(_calendar, url){
    
    var self = this;
    
    this.url = 'ajax.php?c=Widget.Calendar.';
    
    this.reset = function() {
      _calendar.fullCalendar('refetchEvents');
    };
    
    /**
     * Get Calendar DAta
     */
    this.getCalendar = function(title)
    {
      var json = $R.get(this.url + 'getCalendar&title=' + title).data;
      //alert (json);
      //json = $.parseJSON(json); 
      return json;
    }
   
   
   /**
    * Show default calendars for user with userId, else show default
    * initialize calendar-menu
    * @param userId
    */    
   this.loadCalendars = function(userId) {
     var tmp;
     var i=0;
     var json = $R.get(this.url + 'loadCalendars&userId=' + userId);
     json = json.data;
     //json = $.parseJSON(json);      // when parsing empty array it returns null
     // check if json is empty
     if(json.categories === undefined)
       return null;
     else
       return json;
   };
         
   
   /**
    * returns only names of the calendars for autocomplete
    */ 
   this.getAllCalendars = function(){
     var tmp = $R.get(this.url + 'getAllCalendars').data;
     return tmp;
   };
    
   
   
   /**
    *get Events 
    *@param ids -  json array of events
    */
   this.getEvents = function(ids){
     var view = _calendar.fullCalendar('getView'),
         start, 
         end,
         events,
         json;
     
     start = Math.round( view.start.getTime()/1000);
     end   = Math.round( view.end.getTime()/1000);   
     ids = JSON.stringify(ids);
    
     if (ids === "[]"){
       return [];
     }
     
     json = $R.get(proxy.url        + 'getEvents&'+ 
                       'ids='       +  ids    +
                       '&start='    +  start   +
                       '&end='      +  end)
                       .data;
     events =  $.parseJSON(json);
     if (events == null){
       return [];
     }
    
     return events;
   }
   
   
   /**
    * 
    */
   this.addEventSource = function(calendarId){
     _calendar.fullCalendar('addEventSource', this.url + 'getEvents&calendarId=' + calendarId);
   };
   
   
   /**
    * 
    */
   this.removeEventSource = function(calendarId) {
     this.saveDialog();
     _calendar.fullCalendar('removeEventSource', this.url + 'getEvents&calendarId=' + calendarId);
   };
   
   /**
    * Optimized remove. Fewer req to server
    */
    this.removeEventSource1 = function(calendarId)
    {
      var events = _calendar.fullCalendar('clientEvents'),
          i=0;
      
      this.saveDialog(events);
      for (i=0; i<events.length; i++){
        if (events[i].calendarId == calendarId){
          _calendar.fullCalendar('removeEvents', events[i].id);
        }
      }
    }
    
   /**
    * Show save Dialog/Warning 
    * SaveEvents can be called when view state is already changed so we must get events 
    * before opening dialog 
    */
   this.saveDialog = function()
   {
     //get events first and then open the dialog
     var events = _calendar.fullCalendar('clientEvents');
     
     _button = $('#button-save');
     if ( !(_button.hasClass('ui-state-disabled')) && _button.length !== 0 ){
       
       $( "<div> You made changes to events and did not save. Do you want to do " +
           "it now?</div>" )
           .dialog({
             resizable: false,
             height:140,
             modal: true,
             buttons: {
                 "Save all events": function() {
                     $( this ).dialog( "close" );
                     proxy.saveEvents(events);
                 },
                 Cancel: function() {
                     $( this ).dialog( "close" );
                 }
             }
       });
       
       _button.addClass('ui-state-disabled');
     };
   }
   
   
   /**
    * send all events to the server 
    */
   this.saveEvents = function(events){
     
     if (events === undefined){
       events = _calendar.fullCalendar('clientEvents'); 
     }
     
     events = toPostString(events);
     
     if (events!==""){
       $R.post('ajax.php?c=Wbfsys.CalendarAppointment_Multi.multisave', events);
     }
   };
   
   
   /**
    * save calendar data
    */
   this.saveCalendar = function(calendarId){
     var _calendar = getActiveCalendar(calendarId);
     var str = "wbfsys_calendar[" + calendarId + "][description]= " + _calendar.colorScheme;
     $R.post('ajax.php?c=Wbfsys.Calendar_Multi.multisave', str);

     //$('#button-save').addClass('ui-state-disabled');
     };
   
     
   /**
    * 
    */
   this.saveNewEvent = function(event){
     var json, newEvent;
     json = JSON.stringify(event);
     newEvent = $R.get(this.url + 'saveNewEvent&event=' + json).data;
     //event["id"] = newEvent["id"];
     return newEvent;
     };
   
   /**  
   * function is called whenever event data is changed
   * event must be original event object, not reconstructed 
   * @TODO: decide: call server, check data, give event id, and return data
   */
   this.updateEvent = function(event){  
     _calendar.fullCalendar('updateEvent', event);
     event.dirty = true;
     $('#button-save').removeClass('ui-state-disabled');
   };
    
   
   /**
    * remove from calendar, call server and remove from database
    */
   this.deleteEvent = function(id){
     _calendar.fullCalendar('removeEvents', id);
     var json = $R.get(this.url + 'deleteEvent&id=' + id);
   };
   
   /**
    * Help functon, turns event data to json
    */
   var toJson = function (events){
     var temp=[];
     $.each(events, function(index, val) {
         event={};
         event.id = val.id;
         event.title = val.title;
         event.allDay = val.allDay;
         event.dirty = val.dirty;
         event.start = $.fullCalendar.formatDate(val.start, 'u');
         event.end = $.fullCalendar.formatDate(val.end, 'u');
         event.className = val.className;
         event.calendarId = val.calendarId;
         
         //alert(val.className);
         temp[temp.length] = event;
       
     });
     data = JSON.stringify(temp);
     //chEvents = [];
     return data;
   };
   
   
   /**
    * Serialize event data so they can be sent with post
    */
   var toPostString = function (events){
     var str="";
     var start, end;

     $.each(events, function(index, val) {
         if (val.dirty===true){
           val.dirty = false;
           start = $.fullCalendar.formatDate(val.start, 'yyyy-MM-dd HH:mm:ss');
           end   = $.fullCalendar.formatDate(val.end, 'yyyy-MM-dd HH:mm:ss');
           
           str += "&wbfsys_calendar_appointment[" + val.id + "][title]="            + val.title;
           str += "&wbfsys_calendar_appointment[" + val.id + "][id_calendar]="      + val.calendarId;
           str += "&wbfsys_calendar_appointment[" + val.id + "][timestamp_start]="  + start;
           str += "&wbfsys_calendar_appointment[" + val.id + "][timestamp_end]= "   + end;
           str += "&wbfsys_calendar_appointment[" + val.id + "][description]="      + val.description;
           
           if (val.allDay === false)
             str += "&wbfsys_calendar_appointment[" + val.id + "][all_day]=";
           else
             str += "&wbfsys_calendar_appointment[" + val.id + "][all_day]="         +val.allDay;
           
           if (val.isMultiple === false)
             str += "&wbfsys_calendar_appointment[" + val.id + "][is_multiple]=";
           else
             str += "&wbfsys_calendar_appointment[" + val.id + "][is_multiple]=" + val.isMultiple;
           };
     });
     
     return str;
   };
       
 }//end proxy
   
     
////////////// initialization and settings for Full calendar //////////
    _calendar.fullCalendar({ 
      header: {
        left: '',
        center: 'title',
        right: 'month,agendaWeek,agendaDay, prev,next, today'
      },
      selectable: true,
      selectHelper: true,
      theme: true,
      weekMode: 'variable',
      aspectRatio: 1.7,
      //height: 250,
      firstHour: 7,
      minTime: 7,
      maxTime: 22,
      editable: true,
      timeFormat: {
        agenda: 'h:mm{ - h:mm}', // 5:00 - 6:30
        '': 'h(:mm)tt '            // 7p
      },
      columnFormat: {
        week: 'ddd d/M',
        day: 'dddd d/M'
      },
      events: function(start, end, callback){
        //var ids = getIds();
        var i   = 0,
            ids = [],
            events = [];
        
        /*
        if (calendars !== undefined){
          for (i=0; i < calendars.length; i++){
            ids.push(calendars[i].id);
            }
        } 
        */
        
        $.each($('.calendar-menu-checkbox'), function(i, val){
          
          if (val.checked === true){
            ids.push($(val).parent().parent().attr("calendarId"));
          }
        });
        
        events = proxy.getEvents(ids);
        callback(events);
        
      },
      viewDisplay: function( view) {
        var date = _calendar.fullCalendar('getDate');
        _miniCalendar.datepicker('setDate', date);
      },
      
      beforeChangeDisplay: function(view) {
        //var events = calendar.fullCalendar('clientEvents');
        proxy.saveDialog();
      },
      
      //on selection do 
      select: function(start, end, allDay){
        select(start, end, allDay);
      },

      eventDrop: function(event, dayDelta, minuteDelta, allDay) {
        proxy.updateEvent(event); 
      }, 
      eventResize: function(event, dayDelta, minuteDelta){
        proxy.updateEvent(event); 
      },

      eventClick: function(event, jsEvent, view){
        // event click has problems, it gets confused with draging and resizeing
      },

      eventRender: function (event, element, view){
        //element.attr('title', event.title);
        
        //select and bind menu for the menu div
        var temp = $('.fc-event-menu', element);
        var data;
        temp.addClass('circlemenu');

        //TO DO: call to server, send id and get menu information, delete json1
        data = createMenuData(event);
        temp.data('circleMenuData', data);
        temp.bindCircleMenu(cacheData = true);
      },

      eventAfterRender: function(event, element, view){
        //var tmp = element.parent().parent().css('background-color');
        $('.circlemenu', element).addClass('ui-icon-arrowthick-1-ne');
        $('.circlemenu', element).addClass('ui-icon');
      },

      loading: function(bool) {
        if (bool) 
          $('#loading').show();
        else 
          $('#loading').hide();
      }
    });

    
   
    /**
     * on select add new task 
     */
    var select = function (start, end, allDay) {
      var event = {
          start: start,
          end: end,
          allDay: allDay
      };
      createEvent(event);        
      _calendar.fullCalendar('unselect');
    };
    
    
    /**
     * 
     */
    var addButtons = function(){
      //Adding buttons to Full Calendar
      var tmp = $('<tr>' +
          '<td>' +
            '<div id="button-add-calendar" class="ui-state-default ui-no-right ui-corner-left"' + 
              '<a ><span>Add Calendar</span></a>' +
            '</div>' +
            '</td>' +
            '<td>' +
              '<div id="button-new" class="ui-state-default ui-no-right"' + 
                '<a><span>Init</span></a>' + 
              '</div>' +
            '</td>' +
            '<td>' +
              '<div id="button-save" class="ui-state-default ui-state-disabled ui-no-right"' + 
                 '<a ><span>Save</span></a>' + 
               '</div>' +
            '</td>' +
            '<td>' +
              '<div id="button-reset" class="ui-state-default ui-corner-right"' + 
                '<a ><span>Reset</span></a>' + 
              '</div>' +
            '</td>' +
          '</tr>');
 
      $('#button-add-calendar', tmp).click(function(){
        $('#add-calendar-div').dialog('open');
        $('#add-calendar-search').val("");
      });
      
      $('#button-save', tmp).click(function(){ 
          proxy.saveEvents();
          $(this).addClass('ui-state-disabled');
        });
      
      $('#button-new', tmp).click(function(){
        $R.get('ajax.php?c=Widget.Calendar.init');
      });
      
      $('#button-reset', tmp).click(function(){
        proxy.reset(null, null);
        $('#button-save').addClass('ui-state-disabled');
      });
      
      tmp = $('<tbody></tbody>').append(tmp);
      tmp = $('<table></table>').append(tmp);
      $('td.fc-header-left').append(tmp);
      
      
      //Add Calendar Dialog initialzation
      $('#add-calendar-div').dialog({
        autoOpen: false,
        title: "Add Calendar",
        width: '500px',
        modal: true,
        hide: "fold",
        open: function() {
          var availableTags = proxy.getAllCalendars();
          var input;
          
          var bl = $('#add-calendar-search').data();
          var blacat = $('#add-calendar-search1').data();
          var blacombo = $('#add-calendar-search2').data();
          
          $('#add-calendar-search').autocomplete();
          
          $('#add-calendar-search').autocomplete("option", "source", availableTags);
          $('#add-calendar-search1').catcomplete("option", "source", availableTags);
          $('#add-calendar-search2').combocomplete("option", "source", availableTags);
          
          
          $('#add-calendar-search2').combocomplete({
            select: function(event, ui){
              $('#add-calendar-search' ).data("id", ui.item.id);
            }
          });
        },
        close: function() {
          $('#add-calendar-search').val("");
          $('#add-calendar-search').data("id", undefined);
        },
        buttons: { 
          "Add": function() {
            var data = $( '#add-calendar-search' ).data("id");
            var newCalendar, events;
            
            
            if (data === undefined){
              alert("This calendar does not exist!");
              $('#add-calendar-search').data("id", undefined);
              return;
            }
            else {
              data = proxy.getCalendar(data);
            }
            
            if ( calendarNotActive(data) ){
              $('#menu-calendar-' + data.category).find('table').append(addCalendar(data));
              
              events = proxy.getEvents(data.id);
              
              for (var i=0; i < events.length; i++){
                _calendar.fullCalendar( 'renderEvent', events[i]);
              }
              
              calendars.push(data);
              
              $(this).dialog("close");
            }
            else {
              alert("This calendar is allredy added or does not exist!");
              $('#add-calendar-search').data("id", undefined);
            }
          },
          "Cancel": function() {
            $(this).dialog("close");  
          }
        }
      });
    };

    
    /**
     * add mini Calendar
     */
    var addMiniCalendar = function() {
       _miniCalendar.datepicker('option', 'onSelect',
         function(dateText, inst){      
            var date = dateText.split('-');
            
            _calendar.fullCalendar('gotoDate',date[0],date[1]-1,date[2]);
            var view = $('#calendar-full').fullCalendar('getView');
            
            if (view.name == 'agendaWeek')
              _calendar.fullCalendar( 'changeView', 'agendaWeek' );
            else
              _calendar.fullCalendar( 'changeView', 'agendaDay' );
          }   
        );
    };

    
    /**
     * Checks if calendar is allredy active/added
     */
    var calendarNotActive = function(data)
    {
      var i;
      var exist = true;
      
      for (i=0; i < calendars.length; i++){
        if (calendars[i].id == data.id){
          exist = false;
        }
      }
      return exist;
    }
    /**
     * Get calendars, and events on initialization for userId 
     */
    var loadCalendars = function(userId, calendarContainer){
      var json = proxy.loadCalendars(userId);
      var i=0;
      var categories, events;
      var content;
      var data = json.data;
      
      console.log(json);
      
      if ( Boolean(json) ){    //check if json is null or []
        categories = json.categories;
        for (i = 0; i < categories.length; i++){
          calendars = calendars.concat(categories[i].calendars);
        }
      }
      else return;
      
      for ( i = 0; i < categories.length; i++)
        {
           content = $('<hr /><div id="calendar-menu-category">' +
                     categories[i].title + 
                   '<table class="menu-calendar-list">' + 
                   '</table></div>');
              
          $.each(categories[i].calendars, function(i, calendarData){
            //alert(calendarData.id);
            content.find('table').append( addCalendar( calendarData ));
            //proxy.addEventSource(calendarData.id);
            });
          calendarContainer.append(content);
        };
      
      _calendar.fullCalendar('refetchEvents');
    }

    
    /**
     * renders calendar, it does not check the validity of calendarData 
     */
    var addCalendar = function(calendarData){  
      var calendarId = calendarData.id;
      var colorScheme = calendarData.colorScheme;
      var calendarElement = 
        $("<tr class='menu-items " + colorScheme + "' calendarid=" + calendarId + " color_scheme=" + colorScheme + ">" +
            "<td class='menu-items-first'>" + calendarData.title + "</td>" +
            "<td><input type='checkbox' class = 'calendar-menu-checkbox' checked></td>" +
            "<td>" +
              "<div class='color-menu ui-icon-arrowthick-1-ne ui-icon' calendarid=" + calendarId + 
              " classname=" + colorScheme + "></div>" + //this div saves calendarId and classScheme for this calendar
            "</td>" +
          "</tr>"); 
          
      /* new color menu */
      var menuItems = [];
      var clickAction;
      var events;
      
      clickAction = function() {
        var event = {};
        event.calendarId = calendarId;
        event.allDay = true;
        createEvent(event);
        };
        
      menuItems.push({
        type    : 'listItem',
        label   : 'add event',
        action  : clickAction
      });
        
      clickAction = function() {
        editCalendar(calendarId);
        };
        
      menuItems.push({
        type    : 'listItem',
        label   : 'edit',
        action  : clickAction
      });
 
      clickAction = function() {
        removeCalendar(calendarId);
        };
      
      menuItems.push({
        type    : 'listItem',
        label   : 'delete',
        action  : clickAction,
        className: 'color-menu-delete',
        calendarId: calendarId
      });
     
      /*
      menuItems.push({
        type    : 'colorPicker',
        label   : 'chcolor',
        className: 'color-menu-chcolor'
      });
      */
      
      //on click change color of all events and color-menu-item div
      clickAction = function() {
        var color_scheme = $(this).children('a').prop('class'); 
        var tmp;
        //alert (color_scheme + "  " + color + "  ");
        tmp = getActiveCalendar(calendarId);
        if (tmp !==  null){
          calendarElement.prop('class', 'menu item ' + color_scheme);
          tmp.colorScheme = color_scheme;
          proxy.saveCalendar(calendarId);
          changeEventColor(calendarId, color_scheme);
        }
      };
      
      menuItems.push({
        type     : 'divColor',
        action   :  clickAction
      });

      var menuCont = $('.color-menu', calendarElement).miniMenu({
        menuItems   : menuItems,
        button : 'close'
      });
      
      //Add click event to checkbox, on click show/hide that calendar events
      $('.calendar-menu-checkbox', calendarElement).click( function() {
        var calendarId = $(this).parent().parent().attr('calendarid');  
        calendarId = parseInt(calendarId, 10);  //convert from string to int
        
        if (this.checked === true){
          //get and render tasks for this calendar, and add them to calendar
          events = proxy.getEvents(calendarId);
          for (var i=0; i < events.length; i++){
            _calendar.fullCalendar( 'renderEvent', events[i]);
          }
        }
        else{      
          //remove events with calendarId form calendar
          proxy.removeEventSource1(calendarId);
          }
        });

     return calendarElement;
      };

      
      /**
       * Removes calendar from menu list, calendarId i ID of calendar
       */
      var removeCalendar = function(calendarId){
        
        var bla = $('.menu-items[calendarId=' + calendarId + ']'); 
        
        proxy.removeEventSource1(calendarId);
        bla.remove();
        
        for (var i=0; i<calendars.length; i++){
          if (calendars[i].id === calendarId){
            calendars.splice(i,1);
          }
        }
        
      };


      /**
       * Edit Calendar
       */
      editCalendar = function(calendarId){
        alert ("Edit Calendar");
      }
      
      
      /**
       * Create new event
       * Dialog is dynamicly created, this way it is easy to change program to
       * open and show several dialogs in the same time
       */
      var createEvent = function(event){
        var sdate, edate, stime, etime;
        var test = $('#edit-dialog');
        var json="";
        var availableTags;
        var dialogTitle;
        var newEvent;
        
        var _startDate      = test.find('#start-date'),
            _startTime      = test.find('#start-time'),
            _endDate        = test.find('#end-date'),
            _endTime        = test.find('#end-time'),
            _calendarId     = test.find('#calendar-id'),
            _allDay         = test.find('#allday'),
            _isMultiple     = test.find('#ismultiple'),
            _title          = test.find('#title'),
            _description    = test.find('#description'),
            
            pattern         = test.find("input[@name=pattern]:checked").val(),
            endType         = test.find("input[@name=end-type]:checked").val(),
            
            _radioEndType1  = test.find("#repeating-end-type1");
            _radioEndType2  = test.find("#repeating-end-type2");
            _radioPattern1  = test.find("#pattern1");
            _radioPattern2  = test.find("#pattern2");
            _radioPattern3  = test.find("#pattern3");
            _patternData1   = test.find("#dialog-pattern1");
            _patternData2   = test.find("#dialog-pattern2");
            _patternData3   = test.find("#dialog-pattern3");
            _repeatingData  = test.find('#repeating-data'),
            
            _rEndDate       = test.find('#repeating-end-date'),
            _noOfRepeating    = test.find('#no-of-repeating'),
            _repeatInterval = test.find('#repeat-interval'),
            _repeatType     = test.find('#repeat-type'),
            _skipMonth      = test.find('#skip-month'),
            _nthDayInMonth   = test.find('#nth-day-in-month'),
            _skipDay        = test.find('#skip-day'),
            _daysOfTheWeek  = test.find('.dialog-weekdays input'),
            _months         = test.find('.dialog-months input');
            
        var allFields = $([]) .add(_startDate)
                              .add(_startTime)
                              .add(_endDate)
                              .add(_endTime)
                              .add(_calendarId)
                              .add(_allDay)
                              .add(_isMultiple)
                              .add(_title)
                              .add(_description)
                              .add(_rEndDate)
                              .add(_noOfRepeating)
                              .add(_repeatInterval)
                              .add(_repeatType)
                              .add(_skipMonth)
                              .add(_nthDayInMonth)
                              .add(_skipDay)
                              .add(_daysOfTheWeek)
                              .add(_months);
        
        /**
         * Prepare and transform data, populate dialog fields
         */
        var beforeDialogOpen = function(event){
          
          //add ui class so fields will be themable
          allFields.addClass('ui-corner-all ui-widget-content');
          _calendarId.removeClass('ui-corner-all');
          
          //disable repeating events
          _isMultiple.attr('disabled', 'disabled');
          
          //check if new event or updete event
          if (event.id === undefined){
            newEvent = true;
            dialogTitle ="New Event";
          }
          else{
            newEvent = false;
            dialogTitle = "Edit Event"
          };
          
          //Set fields and data
          
          //if add new Event from calendar menu
          if (event.calendarId !== undefined) {
            _calendarId.data("id", event.calendarId);
            _calendarId.attr('value', getActiveCalendar(event.calendarId).title);
            _calendarId.combocomplete('disable');
          }
          else {
            // calendar is not defined, get calendars from server or only showed in menu?
            availableTags = proxy.getAllCalendars();
            _calendarId.combocomplete('option', 'source', availableTags);
            _calendarId.combocomplete('option', 'select', 
                function(event, ui){
                  _calendarId.data("id", ui.item.id);
                });
          };

          //if add new event by selection on month view
          if (event.start === undefined){
            sdate = $.fullCalendar.formatDate(new Date(), 'yyyy-MM-dd');
            stime = '';
          }
          else {
            sdate = $.fullCalendar.formatDate(event.start, 'yyyy-MM-dd');
            stime = $.fullCalendar.formatDate(event.start, 'HH:mm');
          }
          
          //if add new event by selection on week/day view
          if (event.end === undefined ) {
            //test.find('#allday').checked=true;
            edate = '';
            etime = '';
          }
          else{
            edate = $.fullCalendar.formatDate(event.end, 'yyyy-MM-dd');
            etime = $.fullCalendar.formatDate(event.end, 'HH:mm');
          }
          
          if (event.allDay === true){
            _allDay.get(0).checked = true;
            _endDate.datepicker('disable');
            _endTime.attr('disabled', 'disabled');
            _startTime.attr('disabled', 'disabled');
            
            stime = '';
            edate = '';
            etime = '';
         }
          else{
            _allDay.get(0).checked = false; 
            
          };
         
          if (event.title !== undefined){
            _title.attr('value', event.title);
          };
          
          _startDate.attr('value', sdate);
          _startTime.attr('value', stime);
          _endDate.attr('value', edate);
          _endTime.attr('value', etime);
        
        
        //FOR REPEATING TASKS
          if (event.isMultiple === true){
            _isMultiple.get(0).checked = true;
            
            if (event.endType === "no-of-repeating"){
              _radioEndType1.get(0).checked = true;
              _noOfRepeating.attr('disabled', '')
                            .val(event.noOfRepeating);
              
            };
            
            if (event.endType === "repeating-end-date"){
              _radioEndType2.get(0).checked = true;
              _rEndDate.datepicker( 'enabled');
              _rEndDate.val(event.rEndDate);
              
            };
            
            if(event.pattern === "pattern1"){
              _radioPattern1.get(0).checked = true;
              _patternData1.show();
              _repeatInterval.val(event.repeatInterval);
              _repeatType.val(event.repeatType);
            };
            
            if(event.pattern === "pattern2"){
              _radioPattern2.get(0).checked = true;
              _patternData2.show();
            };

            if(event.pattern === "pattern3"){
              _radioPattern3.get(0).checked = true;
              _patternData3.show();
            };
            
            _repeatingData.show();
          }
          else{
            _isMultiple.get(0).checked = false;
            _radioEndType1.get(0).checked = true;
            _noOfRepeating.attr('disabled', '');
            
            _radioPattern1.get(0).checked = true;
            _patternData1.show();
            
            _repeatingData.hide();
          };
          
      };
  
         
        /**
         * on open edit event dialog Initialize widgets 
         */
        var onDialogOpen = function(event){
          var tmp = Array();
          var oldTime;
          
          if(event.endType !== "repeating-end-date"){
            _rEndDate.datepicker( "disable" );
          }
       
          //time picker actions
          oldTime = _startTime[0].timePicker.getTime();
          _startTime.change(function() {
            if (_endTime.val()) { 
              // Only update when second input has a value. Calculate duration.
              var duration = (_endTime[0].timePicker.getTime() - oldTime);
              var time = _startTime[0].timePicker.getTime();
              // Calculate and update the time in the second input.
              _endTime[0].timePicker.setTime(new Date(new Date(time.getTime() + duration)));
              oldTime = time;
            }
          });
          
          _allDay.click( function(){
            if (this.checked === true){
              _endDate.datepicker('disable');
              _endTime.attr('disabled', 'disabled');
              _startTime.attr('disabled', 'disabled');
              _endTime.val('');
              _startTime.val('');
              _endDate.val('');
            }
            else{
              _endDate.datepicker('enable');
              _endTime.attr('disabled', '');
              _startTime.attr('disabled', '');
              _endTime.val('07:00');
              _startTime.val('07:00');
              _endDate.val(_startDate.val());
            }
          });
          
          _isMultiple.click( function(){
            if (this.checked === true){
              _repeatingData.show();
            }
            else{
              _repeatingData.hide();
            }
          });
          
         _radioEndType1.change( function(){
           if (this.checked === true){
            // _rEndDate.attr('disabled', 'disabled');
             _rEndDate.datepicker( "disable" );
             _noOfRepeating.attr('disabled', '');
           }
         });
         
         _radioEndType2.change( function(){
           if (this.checked === true){
             //_rEndDate.attr('disabled', '');
             _rEndDate.datepicker( "enable" );
             _noOfRepeating.attr('disabled', 'disabled');
           }
         })
          
          _radioPattern1.change( function(){
            if( this.checked === true){
              _patternData2.hide();
              _patternData3.hide();
              _patternData1.show();
            }
          });
          
          _radioPattern2.change( function(){
            if( this.checked === true){
              _patternData3.hide();
              _patternData1.hide();
              _patternData2.show();
            }
          });
          
          _radioPattern3.change( function(){
            if( this.checked === true){
              _patternData2.hide();
              _patternData1.hide();
              _patternData3.show();
            }
          });
          
        };

       beforeDialogOpen(event);
      
        test.dialog({
          autoOpen: false,
          width: '500px',
          modal: true,
          hide: "fold",
          title: dialogTitle,
          open: function() {
            onDialogOpen(event);
          },
          
          close: function(event, ui) {
            allFields.val("");
            
            _endTime.attr('disabled', '');
            _startTime.attr('disabled', '');
            _endDate.datepicker( "enable" );
            
            _calendarId.combocomplete('enable');
            _rEndDate.datepicker( "disable" );
            
            test.find("input[@name=pattern]:checked").checked = false;
            test.find("input[@name=end-type]:checked").checked = false;
            
            _patternData1.hide();
            _patternData2.hide();
            _patternData3.hide();
          },
          buttons: { 
            "Save": function() {
              //var data = $(this).find('input').serializeArray();
              
            if (_allDay.get(0).checked === true){
              event.allDay = true;
              event.start = _startDate.val() + ' ' + _startTime.val() + "00:00:00";
              event.end ="";
            }
            else{
              event.allDay = false;
              event.start = _startDate.val() + ' ' + _startTime.val() + ":00";
              event.end = _endDate.val() + ' ' + _endTime.val() + ":00";
            }
            
            if (_isMultiple.get(0).checked === true){
              event.isMultiple = true;
            }
            else{
              event.isMultiple = false;
            }
            
            event.title = _title.val();
            
            if(Boolean(_description.val())){
              event.description = _description.val();
            }
            else {
              event.description = "";
            }
            
            event.calendarId = _calendarId.data("id");
            
            if ( validateEvent(event) ){
              $(this).dialog("close");
              
              if (newEvent){
                event = proxy.saveNewEvent(event);
                //we add source so it can be renderd when other events from 
                //the same calendar are shown
                event.newEvent = true;
                event.source = proxy.url + 'getEvents&calendarId=' + event.calendarId;
                _calendar.fullCalendar('renderEvent', event);
              }
              else{
                proxy.updateEvent(event);
              }
            }
            else{
              alert("validation not passed, iput correct values");
              }
            },
          "Cancel": function() { 
            $(this).dialog("close"); 
            }
           }
         });
        
        test.dialog('open');
      };
      
      
    /** TO DO:
     * Edit repeating event
     */
    var editRepeatingEvent = function (event){
      alert("Repeating event");
    };


    /**
     * TO DO
     * create scheme class which we add to events
     * Domnik's module
     */
    var createScheme = function (color){
      var color_scheme = "some_color_scheme";
      
      return color_scheme;
    };

    
    /**
     * change calendarId events color  
     */
    var changeEventColor = function(calendarId, color_scheme)  {
      
      var events = _calendar.fullCalendar('clientEvents');
      $.each(events, function(i, event) {
        if (+event.calendarId === calendarId)  {
          
          event.className = color_scheme;
          //event.css('backgroundColor', 'gray');
        }  

        _calendar.fullCalendar('updateEvent', event);
      });
    };

    
    /**
     *  Data for Event menu
     */
    var createMenuData = function(event){
      var json1 = 
        [
          {
          "id": "node0",
          "name": " ",
          "data": {"$color": "#EFAB00"},
          "adjacencies": 
          [
            {
              "nodeTo": "node1",
              "data": {'$type': 'none'}
            }, 
            {
              "nodeTo": "node2",
              "data": {'$type': 'none'}
            }, 
            {
              "nodeTo": "node3",
              "data": {'$type': 'none'}
            }, 
            {
              "nodeTo": "node4",
              "data": {"$type": "none"}
            }, 
            {
              "nodeTo": "node5",
              "data": {"$type": "none"}
            }, 
            {
              "nodeTo": "node9",
              "data": {"$type": "none"}
            }, 
          ]
          }, 
          {
          "id": "node1",
          "name": "Edit",
          "data": {"$angularWidth": 36, "$color": "#0081FF", "$height": 70, "$url": "testurl1", "$handlerCode": 
              function(){ 
                //alert("title: " + event.title + " " + event.length + "  allday:" + event.allDay );
                if (event.length==null){
                  createEvent(event);
                }
                else{
                  editRepeatingEvent(event);
                }
              }
            }
          },
          {
            "id": "node2",
            "name": "Delete",
            "data": {"$angularWidth": 36, "$color": "#0078ED", "$height": 70, "$url": "testurl1", "$handlerCode": 
              function(){
                proxy.deleteEvent(event.id);
                }
            }
          }, 
          {
          "id": "node3",
          "name": "Add",
          "data": {"$angularWidth": 36, "$color": "#0070DE",  "$height": 70, "$url": "testurl1", "$handlerCode": function(){alert('Add event');}}
          }, 
          {
          "id": "node4",
          "name": "Notify",
          "data": {"$angularWidth": 36, "$color": "#0066C9", "$height": 70, "$url": "testurl1", "$handlerCode": function(){alert('Notify event');}}
          }, 
          {
          "id": "node5",
          "name": "Subtasks",
          "data": {"$angularWidth": 36, "$color": "#0055A8", "$height": 70, "$handlerCode": function(){alert('Subtasks event');}}
          }, 
          {
          "id": "node9",
          "name": "Close",
          "data": {"$angularWidth": 36, "$color": "#00478C", "$height": 70, "$handlerCode": function(){alert('Close event');}}
          }
        ];
        
      return json1;
    };
    
    
    /**
     * Validation of event Data
     */
    var validateEvent = function(event){
      var reg = new RegExp('[0-2][0-9]:[0-6][0-9]:[0-6][0-9]');
      
      if (event.title === undefined)
        return false;
      
      if (event.start === undefined)
        return false;
      
      if (event.calendarId === undefined)
        return false;
      
     
      return true;
    };
    
    
    /**
     * Get one of local calanders which are curently acive/displayed
     * @param calendarId
     */
    var getActiveCalendar = function(id){
      
      for(var i=0; i<calendars.length; i++)
        if (calendars[i].id == id){
          return calendars[i];
        }
      return null;
    };

 
    
    
    
    /**
     * Help function for creating  event object
     */
    var createEventObject = function( title, start, end, calendarId, id, allDay, dirty, newEvent) {
      var event = {
          title: title,
          start: start,
          end: end,
          calendarId: calendarId,
          id: id,
          allDay: allDay,
          dirty:  dirty, 
          newEvent: newEvent
      };

      return event;
    };

  }// end WgtDesktopCalendar

})(jQuery);
/* Licence see: /LICENCES/wgt/licence.txt */

(function(jQuery){

  // the id for the overlay
  var overlayID = "wgt-dropform-overlay";

  // The actual function
  jQuery.fn.miniMenu = function( options ){
    
    /**
     * Soll das Menü bei globalen klicks (Auserhalb des Menüs) geschlossen werden?
     */
    this.globalClose = true;

    $S(this).each( function(){
      
      // Save reference
      var $this = jQuery(this);

      // FUCK YOU IE9 AND DAMN LAME W3C
      ///@todo check in IE9 if the given element ist the Document
      try
      {
        if( undefined !== HTMLDocument  ){
          if( this instanceof HTMLDocument ){
            console.error( "added minimenu to HTMLDocument" );
            return;
          }
        }
      }
      catch( e ){
        if( $this.is(document) ){ // just a try
          console.error( "added minimenu to HTMLDocument" );
          return;
        }
      }

      // Merge default options with passed options
      var opts = jQuery.extend({}, jQuery.fn.miniMenu.defaults, options);

      // Save options to element
      $this.data( 'miniMenuOptions', opts );

      if( $this.hasClass( 'wgt-dropform-menu-selector' ) )
        return this;

      // Initialise the overlay box
      initMiniMenuOverlay( opts, $this );

      $this.addClass('wgt-dropform-menu-selector');
      
      // Set click handler
      //console.log( "minimenu trigger "+opts.triggerEvent );
     
      $this.bind( opts.triggerEvent, function( event ){
        jQuery.fn.miniMenu.open( $this );

        // close on mouseklick outside
        event.stopPropagation();
      });

    });
    
    return $S(this);

  };

  // Closes the overlay box
  jQuery.fn.miniMenu.close = function(  ){

    
    // das menü schliesen wenn es sichtbar ist
	//if( jQuery( '#'+ overlayID +':visible,.'+ overlayID +':visible' ).length ){
    if( jQuery( '.'+ overlayID +':visible' ).length ){
      
      //jQuery('#'+overlayID+',.'+overlayID).hide();
      jQuery('.'+overlayID).hide();

      // remove global close check
      jQuery(document).unbind( 'mouseup.wgt_mini_menu' );

      /**/
      /// was soll der abschnitt eigentlich machen???
      if( this instanceof Function ){
        //console.log( "minimenu instance of close is a function" );
      }
      else{
        
        var theOverlay = $S(this); 
        if( theOverlay.find('var.conf').is('var.conf') ){
          //console.log('#'+theOverlay.find('var.conf').text());
          $S('#'+theOverlay.find('var.conf').text()).hide();
        }
      }

      //jQuery('.wgt-dropform-overlay').removeClass('wgt-dropform-overlay');
    }
    
  };

  // Opens the overlay box
  jQuery.fn.miniMenu.open = function( target ){

    var $target   = jQuery(target);
    var $targetId = $target.attr( 'id' );
    var $overlay  = null;
    
    // Get options of the element
    var opts    = $target.data('miniMenuOptions');
    
    // globales schliesen konfigurieren
    if( opts.globalClose ){
      jQuery.fn.miniMenu.globalClose = true;
    }
    else{
      jQuery.fn.miniMenu.globalClose = false;
    }
    
    // Einfach mal die Box schliesen für den Fall, dass sie aktuell noch offen ist
    jQuery.fn.miniMenu.close();

    if( !jQuery( '#'+$targetId+'-mnm-overl' ).length ){
      
      console.log( "Minimenu no dropdown: "+'#'+$targetId+'-mnm-overl' );
      
      // get jQuery object of overlay box
      $overlay  = jQuery( '#'+overlayID ).clone();
      $overlay.removeClass( 'template' );
     
      // Content of the overlay box
      $overlay.attr( 'id' , $targetId+'-mnm-overl' ).addClass( overlayID );
      $overlay.find('.miniMenuContent').html('<div></div>');
  
      var menuBody = $overlay.find('.miniMenuContent > div');
      
      var builders = jQuery.fn.miniMenu.builders;
      // If there are any additional menu items to be shown ...
      if (opts.menuItems != null){
        
        var length = opts.menuItems.length;
        for (var i = 0; i < length; i++){
  
          var item = opts.menuItems[i];
  
          if( item.type == undefined ){
            item.type = 'url';
          }
  
          if( builders[item.type] != undefined ){
            builders[item.type](item , menuBody, $target );
          }
          else{
            // check for some error handling
            console.error( "Got unknown minimenu part "+item.type );
          }
        }
      }
      
      $overlay.appendTo('body');
      
      // schliesen des Overlays wenn es verlassen wird
      if( true === opts.closeOnLeave || 'true' === opts.closeOnLeave  ){

        var dEnter = null;
        var dClose = null;

        setTimeout( function(){
            if( !$overlay.hasClass('mouse_in') && !$target.hasClass('mouse_in') ){
              jQuery.fn.miniMenu.close();
            }
            	
          },
          600
        );

        $target.mouseenter( function(){
          $target.addClass('mouse_in');
          $overlay.removeClass('mouse_in');
        }).mouseleave( function(){
          $target.removeClass('mouse_in');
        });

        $overlay.mouseenter( function(){

          dEnter = new Date().getTime();
          $overlay.addClass('mouse_in');
          //$target.removeClass('mouse_in');

          $overlay.mouseleave( function(){

            dClose = new Date().getTime();
            $overlay.unbind('mouseleave');
            $overlay.removeClass('mouse_in');

            setTimeout( function(){
                if( (dClose - 400) > dEnter ){
                  jQuery.fn.miniMenu.close();
                }
              },
              450
            );

          });
       });
     }

      // flag setzen, dass das element auf global close events reagieren soll
      if( opts.globalClose ){
        $overlay.addClass('flag_global_close');
      }
      
    }
    else{
      
      console.log( "Minimenu found dropdown: "+'#'+$targetId+'-mnm-overl' );

      $overlay = jQuery( '#'+$targetId+'-mnm-overl' );

      if( true === opts.closeOnLeave || 'true' === opts.closeOnLeave ){
        setTimeout( function(){

            if( !$overlay.hasClass('mouse_in') && !$target.hasClass('mouse_in') ){
              jQuery.fn.miniMenu.close();
            }
          },
          700
        );
      }
    	
    }


    // event setzen
    if( opts.globalClose ){
      jQuery(document).bind( 'mouseup.wgt_mini_menu', docMouseDown );
    }
    
      
    //$target.addClass('flag-menu-overlay');
    // Die ausrichtung und position des Overlays berechnen
    // sicher stellen, dass es nicht über die Ränder hinaus floatet
    var style     = $target.offset();
    var tStyleW   = $target.outerWidth();
    var oStyleH   = $overlay.outerHeight();
    var oStyleW   = $overlay.outerWidth();
    var winW      = $S(document).width();
    var winH      = $S(document).height()-40;
    
    if( !style ){
      
      console.error( 'missing style' );

      if( console.trace )
        console.trace(  );
      
      return;
    }
    
    if( 'right' == opts.align ){
      
      style.left =  style.left + tStyleW - oStyleW;
      
      if( ( style.left + opts.overlayStyle.width ) > winW ){
        style.left = winW - opts.overlayStyle.width;
      }
      
    }
    else if( 'middle' == opts.align ){

      style.left = style.left + ( ( tStyleW - oStyleW ) / 2 ) ;
      
      if( ( style.left + opts.overlayStyle.width ) > winW ){
        style.left = winW - opts.overlayStyle.width;
      }
      
    }
    else{
      
      if( ( style.left + opts.overlayStyle.width ) > winW ){
        style.left = winW - opts.overlayStyle.width;
      }
    }
    
    if(  style.left < 0 ){
      style.left = 0;
    }
    
    if( ( style.top + oStyleH ) > winH ){
      style.top = winH - oStyleH;
    }
    
    style['z-index'] = '10000';

    // adjust top coordinate
    style.top = style.top + $target.outerHeight();
    style.position = 'absolute';
    $overlay.css(style);
    $overlay.show( );
    
  
  };


  // Mousedown handler on the document
  /**
   * @param evt
   */
  function docMouseDown( evt ){

    console.log('Minimenu Global Event');
    
    if( $S("."+overlayID+":visible").length == 0 ){
      return;
    }
    else if( $S(evt.currentTarget).is("."+overlayID+' descendant') ){
      return;
    }
    else if( !$S("."+overlayID+":visible").hasClass('flag_global_close')  ){
      
      // abbrechen wenn global close dektiviert ist
      return;
    }
    else{
      
      $S.fn.miniMenu.close();
    }

  };

  // Initialise overlay box and apply the style
  /**
   * @param opts
   * @param callerObj
   */
  function initMiniMenuOverlay( opts, callerObj ){


    if( jQuery( '#'+callerObj.attr('id')+'-mnm-overl' ).length ){
      console.log( 'Remove overlay #'+callerObj.attr('id')+'-mnm-overl' );
      jQuery( '#'+callerObj.attr('id')+'-mnm-overl' ).remove();
    }



    var codeCloseButton = '';
    if( !opts.plain ){
      codeCloseButton = '    <div class="miniMenuCloseButton" >'
      +'      <a href="javascript: void(0);" onclick="jQuery.fn.miniMenu.close()"'
      +'        onmouseover="jQuery(this).removeClass(\'ui-state-default\').addClass(\'ui-state-hover\');" '
      +'        onmouseout="jQuery(this).removeClass(\'ui-state-hover\').addClass(\'ui-state-default\');"'
      +'        class="ui-corner-all ui-state-default">'
      +'        '+opts.button
      +'      </a>'
      +'      <br style="clear: both;" /><div></div>'
      +'    </div>';
    }
      
    var codeCloseParent = '';
    if( opts.closeParent ){
      codeCloseParent += '<var class="conf" >'+callerObj.attr('id')+'</var>';
    }

    var tplOverlay = '<div id="'+overlayID+'" class="template" style="position:absolute;" >'
            +'  <div class="ui-widget ui-widget-content">'
            +'    <div class="ui-widget-content" style="padding: 0px;">'
            +'      <div class="miniMenuContent"></div>'
            +'      <div style="clear:both;"></div>'
            +'    </div>'
            + codeCloseButton
            +'    <div class="wgt-clear xxsmall" ></div>'
            //+'    <div class="bottom" ></div>'
            /*+'    <!--[if lte IE 6.5]>'
            +'    <iframe style="display:block; position:absolute;top: 0;left:0;z-index:-1;'
            +'        filter:Alpha(Opacity=\'0\');width:3000px;height:3000px"></iframe>'
            +'    <![endif]-->'*/
            +'  </div>'
            + codeCloseParent
            +'</div>';
        
      

    if ($S("#"+overlayID).length == 0){
      $S("body").append( tplOverlay );
    }
    else{
      $S("#"+overlayID).replaceWith( tplOverlay );
    }

    
    $S("#"+overlayID).attr("style", "");
    $S("#"+overlayID).css(opts.overlayStyle);
    
  };

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders = {};

  /**
  * example:
  *
  * menuItems
  * - action   the click action as javascript callback
  * - icon      the path to the icon relativ to the theme project
  * - caption   the caption for the item
  * - type      possible values: url, callback  default is url
  *
  */

  // Default options
  jQuery.fn.miniMenu.defaults = {
    overlayStyle  : {},
    menuItems     : null,
    plain         : false,
    closeOnLeave  : false,
    globalClose   : true,     // soll das menü bei globalen clicks geschlossen werden?
    align         : 'left',
    triggerEvent  : 'click',
    button        : $I18N.Close||'Close'
  };

})(jQuery);

/* Licence see: /LICENCES/wgt/licence.txt */

(function($S){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['activInput'] = function( element, menuBody, targetElement ){

    var content =  '<div class="miniMenuMenuButton" >'
     + '  <input type="text" style="width:96%" id="miniMenuActivInput"  />'
     + '  <br style="clear: both;" />'
     + '</div>';

    menuBody.append( content );

    $UI.activInput(
      '#miniMenuActivInput', {
        filter      :element.filter,
        resetFilter :element.reset,
        close       :function(){jQuery.fn.miniMenu.close();}
      },{
        minChars    :element.minChars
      }
    );

  };


})($S);


/* Licence see: /LICENCES/wgt/licence.txt */

(function($S,$C){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['url'] = function( element, menuBody, targetElement ){
    
    var onclick = ''+element.action+'$S.fn.miniMenu.close();';
    var content = '<div class="miniMenuMenuButton" >'
     + '  <a style="cursor: pointer;" onclick="'+onclick+'"'
     + '    onmouseover="jQuery(this).removeClass(\'default\').addClass(\'ui-state-hover\');" '
     + '    onmouseout="jQuery(this).removeClass(\'ui-state-hover\').addClass(\'default\');"'
     + '    class="ui-corner-all default" >'
     + '    <img class="icon xsmall " src="'+$C.iconPath+'xsmall/'+element.icon+'" />'
     + '    <b>'+ element.label +'</b>'
     + '  </a>'
     + '  <br style="clear: both;" />'
     + '</div>';

     menuBody.append( content );
  };


})($S,$C);


/* Licence see: /LICENCES/wgt/licence.txt */

(function($S){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['checklist'] = function( element, menuBody, targetElement ){

    var content   = '<p>filter by:</p>';

    var numEle    = element.elements.length;
    for (var pos  = 0; pos < numEle; pos++) {
      var elem    = element.elements[pos];
      var checked = '';

      if( elem[2] == 1 ) {
        checked = 'checked="checked"';
      }

      content += '<div class="miniMenuMenuButton" >'
       + '<input type="checkbox" name="'+ elem.name +'['+elem[0]+']" '+checked+'  />'
       + '<b>'+ elem[1] +'</b>'
       + '<br style="clear: both;" />'
       + '</div>';
    }

    menuBody.append( content );

  };


})($S);


/* Licence see: /LICENCES/wgt/licence.txt */

(function($S){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['colorPicker'] = function( element, menuBody, targetElement ){
    
    var content = '<div class="color-menu-item ' + element.className + '"'
    //+ ' onclick='+ element.action 
      + '  onmouseover="jQuery(this).removeClass(\'default\').addClass(\'ui-state-hover\');" '
      + '  onmouseout="jQuery(this).removeClass(\'ui-state-hover\').addClass(\'default\');">'
     + '<a style="cursor: pointer;" '
     + '  class="ui-corner-all default" >'
     //+ '<img class="icon xsmall " src="'+$C.iconPath+'xsmall/'+element.icon+'" />'
     +  element.label
     + '</a>'
     + '<br style="clear: both;" />'
     + '</div>';
    
    var bla = ((jQuery)(content));

    bla.click( function() {
      bla.ColorPicker({
        color: '#0000ff',
        //flat: true,
        onShow: function (colpkr) {
        $('.color-menu-ul', calendarElement).slideUp(300);
          $(colpkr).fadeIn(600);
          return false;
          },
        onHide: function (colpkr) {
          $(colpkr).fadeOut(500);
          return false;
          },
        onSubmit: function (hsb, hex, rgb) {
            //var calendarId = $(this).parent().parent().attr('calendarId');
            changeEventColor(calendarId, hex);
            calendarElement.css('backgroundColor', '#' + hex);
          }
        });
      });
    
    menuBody.append( bla );
  };


})($S);


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author Dominik Bonsch
 * @quality good
 */
(function($S){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['dom'] = function( element, menuBody, targetElement ){
    
	var id = element.content.attr('id');

	var dNode = element.content.get( 0 );
	var menuDom = menuBody.get( 0 );
	
	menuDom.appendChild( dNode );
	  
    $S( '#'+id ).wrap( '<div class="miniMenuMenuButton" />' );
    
  };


})($S);

/* Licence see: /LICENCES/wgt/licence.txt */

(function($S){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['divColor'] = function( element, menuBody, targetElement ){
    
    var content = ($S)("<table class='color-menu-ul-scheme-table'>" +
        "<tr>" +
          "<td><a class='color-menu-scheme1' ></a></td>" +
          "<td><a class='color-menu-scheme2' ></a></td>" +
          "<td><a class='color-menu-scheme3' ></a></td>" +
        "</tr>" +
        "<tr>" +
          "<td><a class='color-menu-scheme4' ></a></td>" +
          "<td><a class='color-menu-scheme5' ></a></td>" +
          "<td><a class='color-menu-scheme6' ></a></td>" +
        "</tr>" +
        "<tr>" +
          "<td><a class='color-menu-scheme7' ></a></td>" +
          "<td><a class='color-menu-scheme8' ></a></td>" +
          "<td><a class='color-menu-scheme9' ></a></td>" +
        "</tr>" +
      "</table>");
      
      
      var bla = ($S)('td', content); 
      //alert(bla.length);
      //bla.click(alert('gds'));
      //bla.attr('class', 'jiojio');
      bla.click(element.action);
      
      menuBody.append( content );
    };


})($S);


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author Dominik Bonsch
 * @quality good
 */
(function($S){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['html'] = function( element, menuBody, targetElement ){
    
    var content = '<div class="miniMenuMenuButton" >'+ element.content + '</div>';
    menuBody.append( content );
  };


})($S);

/* Licence see: /LICENCES/wgt/licence.txt */

(function($S){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['listItem'] = function( element, menuBody, targetElement ){
    
    if ( element.className === undefined )
      element.className = "";
    
    var content = '<div class="color-menu-item ' + element.className + '"'
    //+ ' onclick='+ element.action 
      + '  onmouseover="$S(this).removeClass(\'default\').addClass(\'ui-state-hover\');" '
      + '  onmouseout="$S(this).removeClass(\'ui-state-hover\').addClass(\'default\');">'
     + '<a style="cursor: pointer;" '
     + '  class="ui-corner-all default" >'
     //+ '<img class="icon xsmall " src="'+$C.iconPath+'xsmall/'+element.icon+'" />'
     +  element.label
     + '</a>'
     + '<br style="clear: both;" />'
     + '</div>';
    
    var bla = (($S)(content));
    //alert(bla.length + "   "  + bla.attr('class'));
    bla.click( element.action );
    
    menuBody.append( bla );
  };


})($S);


/* Licence see: /LICENCES/wgt/licence.txt */

(function($S){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['reload'] = function( element, menuBody, targetElement ){

    // undefined and everything else will fail
    // only true is fine
    var checked = '';
    if( true === element.checked ) {
      checked = 'checked="checked"';
    }

    var content =  '<div class="miniMenuMenuButton" >'
     + '  <input type="checkbox" name="reload" '+checked+' /> reload'
     + '  <br style="clear: both;" />'
     + '</div>';

    menuBody.append( content );
  };


})($S);


/* Licence see: /LICENCES/wgt/licence.txt */

(function($S){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['sep'] = function( element, menuBody, targetElement ){
   
    var content = '<hr />';
    menuBody.append( content );
    
  };


})($S);

/* Licence see: /LICENCES/wgt/licence.txt */

(function( $S, $UI, $C ){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['sortbox'] = function( element, menuBody, targetElement ){

    var colHead = $UI.tableCol($S(targetElement).parentX('th'));
    //var tableNode = trNode.parents('table:first');

    var content = '<div class="miniMenuMenuButton" style="text-align:center;" >'
     + '  <img id="wgt_minimenu_sort_asc" class="icon xsmall" src="'+$C.iconSortAsc+'"  /> asc |'
     + '  <img id="wgt_minimenu_sort_desc" class="icon xsmall" src="'+$C.iconSortDesc+'"  /> desc '
     + '  <br style="clear: both;" />'
     + '</div>';

    menuBody.append( content );
    $S('#wgt_minimenu_sort_asc').click(function(e){ colHead.sort('asc') });
    $S('#wgt_minimenu_sort_desc').click(function(e){ colHead.sort('desc') });

  };


})( $S, $UI, $C );


/* Licence see: /LICENCES/wgt/licence.txt */

(function($S){

  /**
   * callback methodes to make this parser more extendable
   */
  $S.fn.miniMenu.builders['url'] = function( element, menuBody, targetElement ){
    
    var onclick = '$R.get(\''+element.action+'\',{callback:function(){jQuery.fn.miniMenu.close();}})';
    var content = '<div class="miniMenuMenuButton" >'
     + '<a style="cursor: pointer;" onclick="'+onclick+'"'
     + '  onmouseover="jQuery(this).removeClass(\'default\').addClass(\'ui-state-hover\');" '
     + '  onmouseout="jQuery(this).removeClass(\'ui-state-hover\').addClass(\'default\');"'
     + '  class="ui-corner-all default" >'
     + '<img class="icon xsmall " src="'+$C.iconPath+'xsmall/'+element.icon+'" />'
     + '<b>'+ element.label +'</b>'
     + '</a>'
     + '<br style="clear: both;" />'
     + '</div>';

    menuBody.append( content );

  };


})($S);


/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$WGT.addInitCall( function(){

  $R.eventInitRequest();
  $R.eventAfterAjaxRequest();
  
  //window.onbeforeunload = function() { return "You work will be lost."; };

});
/* Licence see: /LICENCES/wgt/licence.txt */

/**
 * @author dominik alexander bonsch <db@webfrap.net>
 */
$WGT.addInitCall( function(){

  /*
  $S('#window_container .window').live('resize', function(){

    var wgtWindow = $S(this);
    var tabScroll = wgtWindow.find('.tab_scroll');
    
    if (tabScroll.length == 0)
      return;

    var scrollButtons = wgtWindow.find('.tab_outer_container .tab_left, '
        + '.tab_outer_container .tab_right');

    scrollButtons.show();
    //tabScroll.width(0);
    tabScroll.width(
        wgtWindow.width()
     - tabScroll.parents('.wgt-container-controls').find('.wgt-container-buttons').outerWidth(true)
     - tabScroll.parents('.tab_outer_container').find('.tab_left').outerWidth(true)
     - tabScroll.parents('.tab_outer_container').find('.tab_right').outerWidth(true)
     -53
    );

    if (tabScroll.width() >= $D.getTabsWidth(wgtWindow.find('.tab_container'))){
      scrollButtons.hide();
    }
    else{
      $D.checkTabButtonVisibility(tabScroll);
    }

  });
  */
  
  /*
  $S(window).resize( function() {
  });
  */
  
  /*
  jQuery("#wbf-cont-splitter").splitter({
    minAsize:230,
    maxAsize:400,
    A:jQuery('#wbf-cont-menu'),
    B:jQuery('#wbf-cont-workarea'),
    closeableto:0,
    splitVertical:true
  });
  */

});
